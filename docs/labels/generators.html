<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>vectorbt.labels.generators API documentation</title>
<meta name="description" content="Basic look-ahead indicators and label generators â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@alpha" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#e82;--docsearch-primary-color:#e82;--docsearch-searchbox-focus-background:#ebedf0}body{line-height:1.5em}.version{font-weight:normal;font-style:italic;font-size:.75em;color:#8b949e}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}h2[id^="header-"]{margin-top:2em}.ident{color:#900}.headerlink{color:inherit}.headerlink:hover{color:inherit}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important;word-break:normal}.hljs-keyword{color:#ff7b72 !important}.hljs-comment{color:#8b949e !important}.hljs-meta{color:#8b949e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 1.5em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:1em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-weight:400;font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}.DocSearch-Button{width:100%;margin:0px;height:38px}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{min-width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}.hljs{margin-left:-15px;margin-right:-15px}.source pre code{margin-left:0px;margin-right:0px}dd{margin:0 0 1em 3em}dd dd{margin-left:2em}.flex{display:flex !important}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4QLCS0J048"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4QLCS0J048');
</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:100px;max-height:100px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.labels.generators</code></h1>
</header>
<section id="section-intro">
<p>Basic look-ahead indicators and label generators.</p>
<p>You can access all the indicators either by <code>vbt.*</code> or <code>vbt.labels.*</code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;Basic look-ahead indicators and label generators.

You can access all the indicators either by `vbt.*` or `vbt.labels.*`.&#34;&#34;&#34;

from vectorbt import _typing as tp
from vectorbt.indicators.configs import flex_elem_param_config
from vectorbt.indicators.factory import IndicatorFactory
from vectorbt.labels import nb
from vectorbt.labels.enums import TrendMode

# ############# Look-ahead indicators ############# #

FMEAN = IndicatorFactory(
    class_name=&#39;FMEAN&#39;,
    module_name=__name__,
    input_names=[&#39;close&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;fmean&#39;]
).from_apply_func(
    nb.future_mean_apply_nb,
    kwargs_to_args=[&#39;wait&#39;, &#39;adjust&#39;],
    ewm=False,
    wait=1,
    adjust=False
)

FMEAN.__doc__ = &#34;&#34;&#34;Look-ahead indicator based on `vectorbt.labels.nb.future_mean_apply_nb`.&#34;&#34;&#34;

FSTD = IndicatorFactory(
    class_name=&#39;FSTD&#39;,
    module_name=__name__,
    input_names=[&#39;close&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;fstd&#39;]
).from_apply_func(
    nb.future_std_apply_nb,
    kwargs_to_args=[&#39;wait&#39;, &#39;adjust&#39;, &#39;ddof&#39;],
    ewm=False,
    wait=1,
    adjust=False,
    ddof=0
)

FSTD.__doc__ = &#34;&#34;&#34;Look-ahead indicator based on `vectorbt.labels.nb.future_std_apply_nb`.&#34;&#34;&#34;

FMIN = IndicatorFactory(
    class_name=&#39;FMIN&#39;,
    module_name=__name__,
    input_names=[&#39;close&#39;],
    param_names=[&#39;window&#39;],
    output_names=[&#39;fmin&#39;]
).from_apply_func(
    nb.future_min_apply_nb,
    kwargs_to_args=[&#39;wait&#39;],
    wait=1
)

FMIN.__doc__ = &#34;&#34;&#34;Look-ahead indicator based on `vectorbt.labels.nb.future_min_apply_nb`.&#34;&#34;&#34;

FMAX = IndicatorFactory(
    class_name=&#39;FMAX&#39;,
    module_name=__name__,
    input_names=[&#39;close&#39;],
    param_names=[&#39;window&#39;],
    output_names=[&#39;fmax&#39;]
).from_apply_func(
    nb.future_max_apply_nb,
    kwargs_to_args=[&#39;wait&#39;],
    wait=1
)

FMAX.__doc__ = &#34;&#34;&#34;Look-ahead indicator based on `vectorbt.labels.nb.future_max_apply_nb`.&#34;&#34;&#34;


# ############# Label generators ############# #


def _plot(self, column: tp.Optional[tp.Label] = None, **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    &#34;&#34;&#34;Plot `close` and overlay it with the heatmap of `labels`.

    `**kwargs` are passed to `vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap`.&#34;&#34;&#34;
    self_col = self.select_one(column=column, group_by=False)

    return self_col.close.rename(&#39;close&#39;).vbt.overlay_with_heatmap(self_col.labels.rename(&#39;labels&#39;), **kwargs)


FIXLB = IndicatorFactory(
    class_name=&#39;FIXLB&#39;,
    module_name=__name__,
    input_names=[&#39;close&#39;],
    param_names=[&#39;n&#39;],
    output_names=[&#39;labels&#39;]
).from_apply_func(
    nb.fixed_labels_apply_nb
)


class _FIXLB(FIXLB):
    &#34;&#34;&#34;Label generator based on `vectorbt.labels.nb.fixed_labels_apply_nb`.&#34;&#34;&#34;

    plot = _plot


setattr(FIXLB, &#39;__doc__&#39;, _FIXLB.__doc__)
setattr(FIXLB, &#39;plot&#39;, _FIXLB.plot)

MEANLB = IndicatorFactory(
    class_name=&#39;MEANLB&#39;,
    module_name=__name__,
    input_names=[&#39;close&#39;],
    param_names=[&#39;window&#39;, &#39;ewm&#39;],
    output_names=[&#39;labels&#39;]
).from_apply_func(
    nb.mean_labels_apply_nb,
    kwargs_to_args=[&#39;wait&#39;, &#39;adjust&#39;],
    ewm=False,
    wait=1,
    adjust=False
)


class _MEANLB(MEANLB):
    &#34;&#34;&#34;Label generator based on `vectorbt.labels.nb.mean_labels_apply_nb`.&#34;&#34;&#34;

    plot = _plot


setattr(MEANLB, &#39;__doc__&#39;, _MEANLB.__doc__)
setattr(MEANLB, &#39;plot&#39;, _MEANLB.plot)

LEXLB = IndicatorFactory(
    class_name=&#39;LEXLB&#39;,
    module_name=__name__,
    input_names=[&#39;close&#39;],
    param_names=[&#39;pos_th&#39;, &#39;neg_th&#39;],
    output_names=[&#39;labels&#39;]
).from_apply_func(
    nb.local_extrema_apply_nb,
    param_settings=dict(
        pos_th=flex_elem_param_config,
        neg_th=flex_elem_param_config
    ),
    pass_flex_2d=True
)


class _LEXLB(LEXLB):
    &#34;&#34;&#34;Label generator based on `vectorbt.labels.nb.local_extrema_apply_nb`.&#34;&#34;&#34;

    plot = _plot


setattr(LEXLB, &#39;__doc__&#39;, _LEXLB.__doc__)
setattr(LEXLB, &#39;plot&#39;, _LEXLB.plot)

TRENDLB = IndicatorFactory(
    class_name=&#39;TRENDLB&#39;,
    module_name=__name__,
    input_names=[&#39;close&#39;],
    param_names=[&#39;pos_th&#39;, &#39;neg_th&#39;, &#39;mode&#39;],
    output_names=[&#39;labels&#39;]
).from_apply_func(
    nb.trend_labels_apply_nb,
    param_settings=dict(
        pos_th=flex_elem_param_config,
        neg_th=flex_elem_param_config,
        mode=dict(dtype=TrendMode)
    ),
    pass_flex_2d=True,
    mode=TrendMode.Binary
)


class _TRENDLB(TRENDLB):
    &#34;&#34;&#34;Label generator based on `vectorbt.labels.nb.trend_labels_apply_nb`.&#34;&#34;&#34;

    plot = _plot


setattr(TRENDLB, &#39;__doc__&#39;, _TRENDLB.__doc__)
setattr(TRENDLB, &#39;plot&#39;, _TRENDLB.plot)

BOLB = IndicatorFactory(
    class_name=&#39;BOLB&#39;,
    module_name=__name__,
    input_names=[&#39;close&#39;],
    param_names=[&#39;window&#39;, &#39;pos_th&#39;, &#39;neg_th&#39;],
    output_names=[&#39;labels&#39;]
).from_apply_func(
    nb.breakout_labels_nb,
    param_settings=dict(
        pos_th=flex_elem_param_config,
        neg_th=flex_elem_param_config
    ),
    pass_flex_2d=True,
    kwargs_to_args=[&#39;wait&#39;],
    pos_th=0.,
    neg_th=0.,
    wait=1
)


class _BOLB(BOLB):
    &#34;&#34;&#34;Label generator based on `vectorbt.labels.nb.breakout_labels_nb`.&#34;&#34;&#34;

    plot = _plot


setattr(BOLB, &#39;__doc__&#39;, _BOLB.__doc__)
setattr(BOLB, &#39;plot&#39;, _BOLB.plot)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.labels.generators.BOLB"><code class="flex name class">
<span>class <span class="ident parent-name">BOLB</span></span>
(<span class="params">wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names</span>)
</code></dt>
<dd>
<div class="desc"><p>Label generator based on <code><a title="vectorbt.labels.nb.breakout_labels_nb" href="nb.html#vectorbt.labels.nb.breakout_labels_nb">breakout_labels_nb()</a></code>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.labels.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr_.AttrResolver" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.labels.generators._BOLB</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.labels.generators.BOLB.run"><code class="name flex">
<span>def <span class="ident child-name">run</span></span>(<span class="params">close, window, pos_th=Default(0.0), neg_th=Default(0.0), short_name='bolb', hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.labels.generators.BOLB" href="#vectorbt.labels.generators.BOLB">BOLB</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>pos_th</code>, <code>neg_th</code></li>
<li>Outputs: <code>labels</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.run_combs"><code class="name flex">
<span>def <span class="ident child-name">run_combs</span></span>(<span class="params">close, window, pos_th=Default(0.0), neg_th=Default(0.0), r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.labels.generators.BOLB" href="#vectorbt.labels.generators.BOLB">BOLB</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>pos_th</code>, <code>neg_th</code></li>
<li>Outputs: <code>labels</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.labels.generators.BOLB.run" href="#vectorbt.labels.generators.BOLB.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.labels.generators.BOLB.close"><code class="name">var <span class="ident child-name">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.labels"><code class="name">var <span class="ident child-name">labels</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.neg_th_list"><code class="name">var <span class="ident child-name">neg_th_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>neg_th</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.pos_th_list"><code class="name">var <span class="ident child-name">pos_th_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>pos_th</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.window_list"><code class="name">var <span class="ident child-name">window_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>window</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.labels.generators.BOLB.apply_func"><code class="name flex">
<span>def <span class="ident child-name">apply_func</span></span>(<span class="params">close, window, pos_th, neg_th, wait=1, flex_2d=True)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>For each value, return 1 if any value in the next period is greater than the
positive threshold (in %), -1 if less than the negative threshold, and 0 otherwise.</p>
<p>First hit wins.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def breakout_labels_nb(close: tp.Array2d,
                       window: int,
                       pos_th: tp.MaybeArray[float],
                       neg_th: tp.MaybeArray[float],
                       wait: int = 1,
                       flex_2d: bool = True) -&gt; tp.Array2d:
    &#34;&#34;&#34;For each value, return 1 if any value in the next period is greater than the
    positive threshold (in %), -1 if less than the negative threshold, and 0 otherwise.

    First hit wins.&#34;&#34;&#34;
    pos_th = np.asarray(pos_th)
    neg_th = np.asarray(neg_th)
    out = np.full_like(close, 0, dtype=np.float_)

    for col in range(close.shape[1]):
        for i in range(close.shape[0]):
            _pos_th = abs(flex_select_auto_nb(pos_th, i, col, flex_2d))
            _neg_th = abs(flex_select_auto_nb(neg_th, i, col, flex_2d))

            for j in range(i + wait, min(i + window + wait, close.shape[0])):
                if _pos_th &gt; 0 and close[j, col] &gt;= close[i, col] * (1 + _pos_th):
                    out[i, col] = 1
                    break
                if _neg_th &gt; 0 and close[j, col] &lt;= close[i, col] * (1 - _neg_th):
                    out[i, col] = -1
                    break

    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.close_above"><code class="name flex">
<span>def <span class="ident child-name">close_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.close_below"><code class="name flex">
<span>def <span class="ident child-name">close_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.close_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.close_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.close_equal"><code class="name flex">
<span>def <span class="ident child-name">close_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.close_stats"><code class="name flex">
<span>def <span class="ident child-name">close_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>close</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.custom_func"><code class="name flex">
<span>def <span class="ident child-name">custom_func</span></span>(<span class="params">input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                col: tp.Optional[int] = None,
                flex_2d: tp.Optional[bool] = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                use_ray: bool = False,
                **_kwargs) -&gt; tp.Union[None, CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.labels_above"><code class="name flex">
<span>def <span class="ident child-name">labels_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.labels_below"><code class="name flex">
<span>def <span class="ident child-name">labels_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.labels_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">labels_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.labels_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">labels_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.labels_equal"><code class="name flex">
<span>def <span class="ident child-name">labels_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.labels_stats"><code class="name flex">
<span>def <span class="ident child-name">labels_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>labels</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.BOLB.plot"><code class="name flex">
<span>def <span class="ident child-name">plot</span></span>(<span class="params">self, column=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code>close</code> and overlay it with the heatmap of <code>labels</code>.</p>
<p><code>**kwargs</code> are passed to <code><a title="vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap">GenericSRAccessor.overlay_with_heatmap()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot(self, column: tp.Optional[tp.Label] = None, **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    &#34;&#34;&#34;Plot `close` and overlay it with the heatmap of `labels`.

    `**kwargs` are passed to `vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap`.&#34;&#34;&#34;
    self_col = self.select_one(column=column, group_by=False)

    return self_col.close.rename(&#39;close&#39;).vbt.overlay_with_heatmap(self_col.labels.rename(&#39;labels&#39;), **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.deep_getattr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots_defaults" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.post_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.pre_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.replace" href="../utils/config.html#vectorbt.utils.config.Configured.replace">replace</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_self" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.self_aliases" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats_defaults" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.labels.generators.FIXLB"><code class="flex name class">
<span>class <span class="ident parent-name">FIXLB</span></span>
(<span class="params">wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names</span>)
</code></dt>
<dd>
<div class="desc"><p>Label generator based on <code><a title="vectorbt.labels.nb.fixed_labels_apply_nb" href="nb.html#vectorbt.labels.nb.fixed_labels_apply_nb">fixed_labels_apply_nb()</a></code>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.labels.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr_.AttrResolver" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.labels.generators._FIXLB</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.labels.generators.FIXLB.run"><code class="name flex">
<span>def <span class="ident child-name">run</span></span>(<span class="params">close, n, short_name='fixlb', hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.labels.generators.FIXLB" href="#vectorbt.labels.generators.FIXLB">FIXLB</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>n</code></li>
<li>Outputs: <code>labels</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.run_combs"><code class="name flex">
<span>def <span class="ident child-name">run_combs</span></span>(<span class="params">close, n, r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.labels.generators.FIXLB" href="#vectorbt.labels.generators.FIXLB">FIXLB</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>n</code></li>
<li>Outputs: <code>labels</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.labels.generators.FIXLB.run" href="#vectorbt.labels.generators.FIXLB.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.labels.generators.FIXLB.close"><code class="name">var <span class="ident child-name">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.labels"><code class="name">var <span class="ident child-name">labels</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.n_list"><code class="name">var <span class="ident child-name">n_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>n</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.labels.generators.FIXLB.apply_func"><code class="name flex">
<span>def <span class="ident child-name">apply_func</span></span>(<span class="params">close, n)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get percentage change from the current value to a future value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def fixed_labels_apply_nb(close: tp.Array2d, n: int) -&gt; tp.Array2d:
    &#34;&#34;&#34;Get percentage change from the current value to a future value.&#34;&#34;&#34;
    return (generic_nb.bshift_nb(close, n) - close) / close</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.close_above"><code class="name flex">
<span>def <span class="ident child-name">close_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.close_below"><code class="name flex">
<span>def <span class="ident child-name">close_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.close_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.close_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.close_equal"><code class="name flex">
<span>def <span class="ident child-name">close_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.close_stats"><code class="name flex">
<span>def <span class="ident child-name">close_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>close</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.custom_func"><code class="name flex">
<span>def <span class="ident child-name">custom_func</span></span>(<span class="params">input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                col: tp.Optional[int] = None,
                flex_2d: tp.Optional[bool] = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                use_ray: bool = False,
                **_kwargs) -&gt; tp.Union[None, CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.labels_above"><code class="name flex">
<span>def <span class="ident child-name">labels_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.labels_below"><code class="name flex">
<span>def <span class="ident child-name">labels_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.labels_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">labels_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.labels_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">labels_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.labels_equal"><code class="name flex">
<span>def <span class="ident child-name">labels_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.labels_stats"><code class="name flex">
<span>def <span class="ident child-name">labels_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>labels</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FIXLB.plot"><code class="name flex">
<span>def <span class="ident child-name">plot</span></span>(<span class="params">self, column=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code>close</code> and overlay it with the heatmap of <code>labels</code>.</p>
<p><code>**kwargs</code> are passed to <code><a title="vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap">GenericSRAccessor.overlay_with_heatmap()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot(self, column: tp.Optional[tp.Label] = None, **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    &#34;&#34;&#34;Plot `close` and overlay it with the heatmap of `labels`.

    `**kwargs` are passed to `vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap`.&#34;&#34;&#34;
    self_col = self.select_one(column=column, group_by=False)

    return self_col.close.rename(&#39;close&#39;).vbt.overlay_with_heatmap(self_col.labels.rename(&#39;labels&#39;), **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.deep_getattr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots_defaults" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.post_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.pre_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.replace" href="../utils/config.html#vectorbt.utils.config.Configured.replace">replace</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_self" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.self_aliases" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats_defaults" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.labels.generators.FMAX"><code class="flex name class">
<span>class <span class="ident parent-name">FMAX</span></span>
(<span class="params">wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names</span>)
</code></dt>
<dd>
<div class="desc"><p>Look-ahead indicator based on <code><a title="vectorbt.labels.nb.future_max_apply_nb" href="nb.html#vectorbt.labels.nb.future_max_apply_nb">future_max_apply_nb()</a></code>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.labels.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr_.AttrResolver" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.labels.generators.FMAX.run"><code class="name flex">
<span>def <span class="ident child-name">run</span></span>(<span class="params">close, window, short_name='fmax', hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.labels.generators.FMAX" href="#vectorbt.labels.generators.FMAX">FMAX</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code></li>
<li>Outputs: <code>fmax</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.run_combs"><code class="name flex">
<span>def <span class="ident child-name">run_combs</span></span>(<span class="params">close, window, r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.labels.generators.FMAX" href="#vectorbt.labels.generators.FMAX">FMAX</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code></li>
<li>Outputs: <code>fmax</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.labels.generators.FMAX.run" href="#vectorbt.labels.generators.FMAX.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.labels.generators.FMAX.close"><code class="name">var <span class="ident child-name">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.fmax"><code class="name">var <span class="ident child-name">fmax</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.window_list"><code class="name">var <span class="ident child-name">window_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>window</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.labels.generators.FMAX.apply_func"><code class="name flex">
<span>def <span class="ident child-name">apply_func</span></span>(<span class="params">close, window, wait=1)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get the maximum of the next period.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def future_max_apply_nb(close: tp.Array2d, window: int, wait: int = 1) -&gt; tp.Array2d:
    &#34;&#34;&#34;Get the maximum of the next period.&#34;&#34;&#34;
    out = generic_nb.rolling_max_nb(close[::-1], window, minp=window)[::-1]
    if wait &gt; 0:
        return generic_nb.bshift_nb(out, wait)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.close_above"><code class="name flex">
<span>def <span class="ident child-name">close_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.close_below"><code class="name flex">
<span>def <span class="ident child-name">close_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.close_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.close_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.close_equal"><code class="name flex">
<span>def <span class="ident child-name">close_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.close_stats"><code class="name flex">
<span>def <span class="ident child-name">close_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>close</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.custom_func"><code class="name flex">
<span>def <span class="ident child-name">custom_func</span></span>(<span class="params">input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                col: tp.Optional[int] = None,
                flex_2d: tp.Optional[bool] = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                use_ray: bool = False,
                **_kwargs) -&gt; tp.Union[None, CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.fmax_above"><code class="name flex">
<span>def <span class="ident child-name">fmax_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmax</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.fmax_below"><code class="name flex">
<span>def <span class="ident child-name">fmax_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmax</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.fmax_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">fmax_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmax</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.fmax_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">fmax_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmax</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.fmax_equal"><code class="name flex">
<span>def <span class="ident child-name">fmax_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmax</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMAX.fmax_stats"><code class="name flex">
<span>def <span class="ident child-name">fmax_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>fmax</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.deep_getattr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots_defaults" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.post_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.pre_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.replace" href="../utils/config.html#vectorbt.utils.config.Configured.replace">replace</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_self" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.self_aliases" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats_defaults" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.labels.generators.FMEAN"><code class="flex name class">
<span>class <span class="ident parent-name">FMEAN</span></span>
(<span class="params">wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names</span>)
</code></dt>
<dd>
<div class="desc"><p>Look-ahead indicator based on <code><a title="vectorbt.labels.nb.future_mean_apply_nb" href="nb.html#vectorbt.labels.nb.future_mean_apply_nb">future_mean_apply_nb()</a></code>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.labels.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr_.AttrResolver" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.labels.generators.FMEAN.run"><code class="name flex">
<span>def <span class="ident child-name">run</span></span>(<span class="params">close, window, ewm=Default(False), short_name='fmean', hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.labels.generators.FMEAN" href="#vectorbt.labels.generators.FMEAN">FMEAN</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code></li>
<li>Outputs: <code>fmean</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.run_combs"><code class="name flex">
<span>def <span class="ident child-name">run_combs</span></span>(<span class="params">close, window, ewm=Default(False), r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.labels.generators.FMEAN" href="#vectorbt.labels.generators.FMEAN">FMEAN</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code></li>
<li>Outputs: <code>fmean</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.labels.generators.FMEAN.run" href="#vectorbt.labels.generators.FMEAN.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.labels.generators.FMEAN.close"><code class="name">var <span class="ident child-name">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.ewm_list"><code class="name">var <span class="ident child-name">ewm_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>ewm</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.fmean"><code class="name">var <span class="ident child-name">fmean</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.window_list"><code class="name">var <span class="ident child-name">window_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>window</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.labels.generators.FMEAN.apply_func"><code class="name flex">
<span>def <span class="ident child-name">apply_func</span></span>(<span class="params">close, window, ewm, wait=1, adjust=False)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get the mean of the next period.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def future_mean_apply_nb(close: tp.Array2d,
                         window: int,
                         ewm: bool,
                         wait: int = 1,
                         adjust: bool = False) -&gt; tp.Array2d:
    &#34;&#34;&#34;Get the mean of the next period.&#34;&#34;&#34;
    if ewm:
        out = generic_nb.ewm_mean_nb(close[::-1], window, minp=window, adjust=adjust)[::-1]
    else:
        out = generic_nb.rolling_mean_nb(close[::-1], window, minp=window)[::-1]
    if wait &gt; 0:
        return generic_nb.bshift_nb(out, wait)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.close_above"><code class="name flex">
<span>def <span class="ident child-name">close_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.close_below"><code class="name flex">
<span>def <span class="ident child-name">close_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.close_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.close_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.close_equal"><code class="name flex">
<span>def <span class="ident child-name">close_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.close_stats"><code class="name flex">
<span>def <span class="ident child-name">close_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>close</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.custom_func"><code class="name flex">
<span>def <span class="ident child-name">custom_func</span></span>(<span class="params">input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                col: tp.Optional[int] = None,
                flex_2d: tp.Optional[bool] = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                use_ray: bool = False,
                **_kwargs) -&gt; tp.Union[None, CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.fmean_above"><code class="name flex">
<span>def <span class="ident child-name">fmean_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmean</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.fmean_below"><code class="name flex">
<span>def <span class="ident child-name">fmean_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmean</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.fmean_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">fmean_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmean</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.fmean_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">fmean_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmean</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.fmean_equal"><code class="name flex">
<span>def <span class="ident child-name">fmean_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmean</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMEAN.fmean_stats"><code class="name flex">
<span>def <span class="ident child-name">fmean_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>fmean</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.deep_getattr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots_defaults" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.post_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.pre_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.replace" href="../utils/config.html#vectorbt.utils.config.Configured.replace">replace</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_self" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.self_aliases" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats_defaults" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.labels.generators.FMIN"><code class="flex name class">
<span>class <span class="ident parent-name">FMIN</span></span>
(<span class="params">wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names</span>)
</code></dt>
<dd>
<div class="desc"><p>Look-ahead indicator based on <code><a title="vectorbt.labels.nb.future_min_apply_nb" href="nb.html#vectorbt.labels.nb.future_min_apply_nb">future_min_apply_nb()</a></code>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.labels.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr_.AttrResolver" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.labels.generators.FMIN.run"><code class="name flex">
<span>def <span class="ident child-name">run</span></span>(<span class="params">close, window, short_name='fmin', hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.labels.generators.FMIN" href="#vectorbt.labels.generators.FMIN">FMIN</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code></li>
<li>Outputs: <code>fmin</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.run_combs"><code class="name flex">
<span>def <span class="ident child-name">run_combs</span></span>(<span class="params">close, window, r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.labels.generators.FMIN" href="#vectorbt.labels.generators.FMIN">FMIN</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code></li>
<li>Outputs: <code>fmin</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.labels.generators.FMIN.run" href="#vectorbt.labels.generators.FMIN.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.labels.generators.FMIN.close"><code class="name">var <span class="ident child-name">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.fmin"><code class="name">var <span class="ident child-name">fmin</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.window_list"><code class="name">var <span class="ident child-name">window_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>window</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.labels.generators.FMIN.apply_func"><code class="name flex">
<span>def <span class="ident child-name">apply_func</span></span>(<span class="params">close, window, wait=1)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get the minimum of the next period.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def future_min_apply_nb(close: tp.Array2d, window: int, wait: int = 1) -&gt; tp.Array2d:
    &#34;&#34;&#34;Get the minimum of the next period.&#34;&#34;&#34;
    out = generic_nb.rolling_min_nb(close[::-1], window, minp=window)[::-1]
    if wait &gt; 0:
        return generic_nb.bshift_nb(out, wait)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.close_above"><code class="name flex">
<span>def <span class="ident child-name">close_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.close_below"><code class="name flex">
<span>def <span class="ident child-name">close_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.close_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.close_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.close_equal"><code class="name flex">
<span>def <span class="ident child-name">close_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.close_stats"><code class="name flex">
<span>def <span class="ident child-name">close_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>close</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.custom_func"><code class="name flex">
<span>def <span class="ident child-name">custom_func</span></span>(<span class="params">input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                col: tp.Optional[int] = None,
                flex_2d: tp.Optional[bool] = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                use_ray: bool = False,
                **_kwargs) -&gt; tp.Union[None, CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.fmin_above"><code class="name flex">
<span>def <span class="ident child-name">fmin_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmin</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.fmin_below"><code class="name flex">
<span>def <span class="ident child-name">fmin_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmin</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.fmin_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">fmin_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmin</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.fmin_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">fmin_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmin</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.fmin_equal"><code class="name flex">
<span>def <span class="ident child-name">fmin_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fmin</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FMIN.fmin_stats"><code class="name flex">
<span>def <span class="ident child-name">fmin_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>fmin</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.deep_getattr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots_defaults" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.post_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.pre_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.replace" href="../utils/config.html#vectorbt.utils.config.Configured.replace">replace</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_self" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.self_aliases" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats_defaults" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.labels.generators.FSTD"><code class="flex name class">
<span>class <span class="ident parent-name">FSTD</span></span>
(<span class="params">wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names</span>)
</code></dt>
<dd>
<div class="desc"><p>Look-ahead indicator based on <code><a title="vectorbt.labels.nb.future_std_apply_nb" href="nb.html#vectorbt.labels.nb.future_std_apply_nb">future_std_apply_nb()</a></code>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.labels.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr_.AttrResolver" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.labels.generators.FSTD.run"><code class="name flex">
<span>def <span class="ident child-name">run</span></span>(<span class="params">close, window, ewm=Default(False), short_name='fstd', hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.labels.generators.FSTD" href="#vectorbt.labels.generators.FSTD">FSTD</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code></li>
<li>Outputs: <code>fstd</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.run_combs"><code class="name flex">
<span>def <span class="ident child-name">run_combs</span></span>(<span class="params">close, window, ewm=Default(False), r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.labels.generators.FSTD" href="#vectorbt.labels.generators.FSTD">FSTD</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code></li>
<li>Outputs: <code>fstd</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.labels.generators.FSTD.run" href="#vectorbt.labels.generators.FSTD.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.labels.generators.FSTD.close"><code class="name">var <span class="ident child-name">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.ewm_list"><code class="name">var <span class="ident child-name">ewm_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>ewm</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.fstd"><code class="name">var <span class="ident child-name">fstd</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.window_list"><code class="name">var <span class="ident child-name">window_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>window</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.labels.generators.FSTD.apply_func"><code class="name flex">
<span>def <span class="ident child-name">apply_func</span></span>(<span class="params">close, window, ewm, wait=1, adjust=False, ddof=0)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get the standard deviation of the next period.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def future_std_apply_nb(close: tp.Array2d,
                        window: int,
                        ewm: bool,
                        wait: int = 1,
                        adjust: bool = False,
                        ddof: int = 0) -&gt; tp.Array2d:
    &#34;&#34;&#34;Get the standard deviation of the next period.&#34;&#34;&#34;
    if ewm:
        out = generic_nb.ewm_std_nb(close[::-1], window, minp=window, adjust=adjust, ddof=ddof)[::-1]
    else:
        out = generic_nb.rolling_std_nb(close[::-1], window, minp=window, ddof=ddof)[::-1]
    if wait &gt; 0:
        return generic_nb.bshift_nb(out, wait)
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.close_above"><code class="name flex">
<span>def <span class="ident child-name">close_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.close_below"><code class="name flex">
<span>def <span class="ident child-name">close_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.close_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.close_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.close_equal"><code class="name flex">
<span>def <span class="ident child-name">close_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.close_stats"><code class="name flex">
<span>def <span class="ident child-name">close_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>close</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.custom_func"><code class="name flex">
<span>def <span class="ident child-name">custom_func</span></span>(<span class="params">input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                col: tp.Optional[int] = None,
                flex_2d: tp.Optional[bool] = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                use_ray: bool = False,
                **_kwargs) -&gt; tp.Union[None, CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.fstd_above"><code class="name flex">
<span>def <span class="ident child-name">fstd_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fstd</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.fstd_below"><code class="name flex">
<span>def <span class="ident child-name">fstd_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fstd</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.fstd_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">fstd_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fstd</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.fstd_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">fstd_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fstd</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.fstd_equal"><code class="name flex">
<span>def <span class="ident child-name">fstd_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>fstd</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.FSTD.fstd_stats"><code class="name flex">
<span>def <span class="ident child-name">fstd_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>fstd</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.deep_getattr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots_defaults" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.post_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.pre_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.replace" href="../utils/config.html#vectorbt.utils.config.Configured.replace">replace</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_self" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.self_aliases" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats_defaults" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.labels.generators.LEXLB"><code class="flex name class">
<span>class <span class="ident parent-name">LEXLB</span></span>
(<span class="params">wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names</span>)
</code></dt>
<dd>
<div class="desc"><p>Label generator based on <code><a title="vectorbt.labels.nb.local_extrema_apply_nb" href="nb.html#vectorbt.labels.nb.local_extrema_apply_nb">local_extrema_apply_nb()</a></code>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.labels.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr_.AttrResolver" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.labels.generators._LEXLB</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.labels.generators.LEXLB.run"><code class="name flex">
<span>def <span class="ident child-name">run</span></span>(<span class="params">close, pos_th, neg_th, short_name='lexlb', hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.labels.generators.LEXLB" href="#vectorbt.labels.generators.LEXLB">LEXLB</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>pos_th</code>, <code>neg_th</code></li>
<li>Outputs: <code>labels</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.run_combs"><code class="name flex">
<span>def <span class="ident child-name">run_combs</span></span>(<span class="params">close, pos_th, neg_th, r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.labels.generators.LEXLB" href="#vectorbt.labels.generators.LEXLB">LEXLB</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>pos_th</code>, <code>neg_th</code></li>
<li>Outputs: <code>labels</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.labels.generators.LEXLB.run" href="#vectorbt.labels.generators.LEXLB.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.labels.generators.LEXLB.close"><code class="name">var <span class="ident child-name">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.labels"><code class="name">var <span class="ident child-name">labels</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.neg_th_list"><code class="name">var <span class="ident child-name">neg_th_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>neg_th</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.pos_th_list"><code class="name">var <span class="ident child-name">pos_th_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>pos_th</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.labels.generators.LEXLB.apply_func"><code class="name flex">
<span>def <span class="ident child-name">apply_func</span></span>(<span class="params">close, pos_th, neg_th, flex_2d=True)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get array of local extrema denoted by 1 (peak) or -1 (trough), otherwise 0.</p>
<p>Two adjacent peak and trough points should exceed the given threshold parameters.</p>
<p>If any threshold is given element-wise, it will be applied per new/updated extremum.</p>
<p>Inspired by <a href="https://www.mdpi.com/1099-4300/22/10/1162/pdf">https://www.mdpi.com/1099-4300/22/10/1162/pdf</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def local_extrema_apply_nb(close: tp.Array2d,
                           pos_th: tp.MaybeArray[float],
                           neg_th: tp.MaybeArray[float],
                           flex_2d: bool = True) -&gt; tp.Array2d:
    &#34;&#34;&#34;Get array of local extrema denoted by 1 (peak) or -1 (trough), otherwise 0.

    Two adjacent peak and trough points should exceed the given threshold parameters.

    If any threshold is given element-wise, it will be applied per new/updated extremum.

    Inspired by https://www.mdpi.com/1099-4300/22/10/1162/pdf&#34;&#34;&#34;
    pos_th = np.asarray(pos_th)
    neg_th = np.asarray(neg_th)
    out = np.full(close.shape, 0, dtype=np.int_)

    for col in range(close.shape[1]):
        prev_i = 0
        direction = 0

        for i in range(1, close.shape[0]):
            _pos_th = abs(flex_select_auto_nb(pos_th, prev_i, col, flex_2d))
            _neg_th = abs(flex_select_auto_nb(neg_th, prev_i, col, flex_2d))
            if _pos_th == 0:
                raise ValueError(&#34;Positive threshold cannot be 0&#34;)
            if _neg_th == 0:
                raise ValueError(&#34;Negative threshold cannot be 0&#34;)

            if direction == 1:
                # Find next high while updating current lows
                if close[i, col] &lt; close[prev_i, col]:
                    prev_i = i
                elif close[i, col] &gt;= close[prev_i, col] * (1 + _pos_th):
                    out[prev_i, col] = -1
                    prev_i = i
                    direction = -1
            elif direction == -1:
                # Find next low while updating current highs
                if close[i, col] &gt; close[prev_i, col]:
                    prev_i = i
                elif close[i, col] &lt;= close[prev_i, col] * (1 - _neg_th):
                    out[prev_i, col] = 1
                    prev_i = i
                    direction = 1
            else:
                # Find first high/low
                if close[i, col] &gt;= close[prev_i, col] * (1 + _pos_th):
                    out[prev_i, col] = -1
                    prev_i = i
                    direction = -1
                elif close[i, col] &lt;= close[prev_i, col] * (1 - _neg_th):
                    out[prev_i, col] = 1
                    prev_i = i
                    direction = 1

            if i == close.shape[0] - 1:
                # Find last high/low
                if direction != 0:
                    out[prev_i, col] = -direction
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.close_above"><code class="name flex">
<span>def <span class="ident child-name">close_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.close_below"><code class="name flex">
<span>def <span class="ident child-name">close_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.close_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.close_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.close_equal"><code class="name flex">
<span>def <span class="ident child-name">close_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.close_stats"><code class="name flex">
<span>def <span class="ident child-name">close_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>close</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.custom_func"><code class="name flex">
<span>def <span class="ident child-name">custom_func</span></span>(<span class="params">input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                col: tp.Optional[int] = None,
                flex_2d: tp.Optional[bool] = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                use_ray: bool = False,
                **_kwargs) -&gt; tp.Union[None, CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.labels_above"><code class="name flex">
<span>def <span class="ident child-name">labels_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.labels_below"><code class="name flex">
<span>def <span class="ident child-name">labels_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.labels_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">labels_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.labels_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">labels_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.labels_equal"><code class="name flex">
<span>def <span class="ident child-name">labels_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.labels_stats"><code class="name flex">
<span>def <span class="ident child-name">labels_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>labels</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.LEXLB.plot"><code class="name flex">
<span>def <span class="ident child-name">plot</span></span>(<span class="params">self, column=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code>close</code> and overlay it with the heatmap of <code>labels</code>.</p>
<p><code>**kwargs</code> are passed to <code><a title="vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap">GenericSRAccessor.overlay_with_heatmap()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot(self, column: tp.Optional[tp.Label] = None, **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    &#34;&#34;&#34;Plot `close` and overlay it with the heatmap of `labels`.

    `**kwargs` are passed to `vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap`.&#34;&#34;&#34;
    self_col = self.select_one(column=column, group_by=False)

    return self_col.close.rename(&#39;close&#39;).vbt.overlay_with_heatmap(self_col.labels.rename(&#39;labels&#39;), **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.deep_getattr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots_defaults" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.post_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.pre_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.replace" href="../utils/config.html#vectorbt.utils.config.Configured.replace">replace</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_self" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.self_aliases" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats_defaults" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.labels.generators.MEANLB"><code class="flex name class">
<span>class <span class="ident parent-name">MEANLB</span></span>
(<span class="params">wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names</span>)
</code></dt>
<dd>
<div class="desc"><p>Label generator based on <code><a title="vectorbt.labels.nb.mean_labels_apply_nb" href="nb.html#vectorbt.labels.nb.mean_labels_apply_nb">mean_labels_apply_nb()</a></code>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.labels.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr_.AttrResolver" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.labels.generators._MEANLB</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.labels.generators.MEANLB.run"><code class="name flex">
<span>def <span class="ident child-name">run</span></span>(<span class="params">close, window, ewm=Default(False), short_name='meanlb', hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.labels.generators.MEANLB" href="#vectorbt.labels.generators.MEANLB">MEANLB</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code></li>
<li>Outputs: <code>labels</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.run_combs"><code class="name flex">
<span>def <span class="ident child-name">run_combs</span></span>(<span class="params">close, window, ewm=Default(False), r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.labels.generators.MEANLB" href="#vectorbt.labels.generators.MEANLB">MEANLB</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>window</code>, <code>ewm</code></li>
<li>Outputs: <code>labels</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.labels.generators.MEANLB.run" href="#vectorbt.labels.generators.MEANLB.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.labels.generators.MEANLB.close"><code class="name">var <span class="ident child-name">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.ewm_list"><code class="name">var <span class="ident child-name">ewm_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>ewm</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.labels"><code class="name">var <span class="ident child-name">labels</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.window_list"><code class="name">var <span class="ident child-name">window_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>window</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.labels.generators.MEANLB.apply_func"><code class="name flex">
<span>def <span class="ident child-name">apply_func</span></span>(<span class="params">close, window, ewm, wait=1, adjust=False)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Get the percentage change from the current value to the average of the next period.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def mean_labels_apply_nb(close: tp.Array2d,
                         window: int,
                         ewm: bool,
                         wait: int = 1,
                         adjust: bool = False) -&gt; tp.Array2d:
    &#34;&#34;&#34;Get the percentage change from the current value to the average of the next period.&#34;&#34;&#34;
    return (future_mean_apply_nb(close, window, ewm, wait, adjust) - close) / close</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.close_above"><code class="name flex">
<span>def <span class="ident child-name">close_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.close_below"><code class="name flex">
<span>def <span class="ident child-name">close_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.close_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.close_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.close_equal"><code class="name flex">
<span>def <span class="ident child-name">close_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.close_stats"><code class="name flex">
<span>def <span class="ident child-name">close_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>close</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.custom_func"><code class="name flex">
<span>def <span class="ident child-name">custom_func</span></span>(<span class="params">input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                col: tp.Optional[int] = None,
                flex_2d: tp.Optional[bool] = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                use_ray: bool = False,
                **_kwargs) -&gt; tp.Union[None, CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.labels_above"><code class="name flex">
<span>def <span class="ident child-name">labels_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.labels_below"><code class="name flex">
<span>def <span class="ident child-name">labels_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.labels_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">labels_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.labels_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">labels_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.labels_equal"><code class="name flex">
<span>def <span class="ident child-name">labels_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.labels_stats"><code class="name flex">
<span>def <span class="ident child-name">labels_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>labels</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.MEANLB.plot"><code class="name flex">
<span>def <span class="ident child-name">plot</span></span>(<span class="params">self, column=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code>close</code> and overlay it with the heatmap of <code>labels</code>.</p>
<p><code>**kwargs</code> are passed to <code><a title="vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap">GenericSRAccessor.overlay_with_heatmap()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot(self, column: tp.Optional[tp.Label] = None, **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    &#34;&#34;&#34;Plot `close` and overlay it with the heatmap of `labels`.

    `**kwargs` are passed to `vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap`.&#34;&#34;&#34;
    self_col = self.select_one(column=column, group_by=False)

    return self_col.close.rename(&#39;close&#39;).vbt.overlay_with_heatmap(self_col.labels.rename(&#39;labels&#39;), **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.deep_getattr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots_defaults" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.post_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.pre_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.replace" href="../utils/config.html#vectorbt.utils.config.Configured.replace">replace</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_self" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.self_aliases" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats_defaults" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB"><code class="flex name class">
<span>class <span class="ident parent-name">TRENDLB</span></span>
(<span class="params">wrapper, input_list, input_mapper, in_output_list, output_list, param_list, mapper_list, short_name, level_names</span>)
</code></dt>
<dd>
<div class="desc"><p>Label generator based on <code><a title="vectorbt.labels.nb.trend_labels_apply_nb" href="nb.html#vectorbt.labels.nb.trend_labels_apply_nb">trend_labels_apply_nb()</a></code>.</p></div>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li>vectorbt.labels.generators.ParamIndexer</li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr_.AttrResolver" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li>vectorbt.labels.generators._TRENDLB</li>
</ul>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.labels.generators.TRENDLB.run"><code class="name flex">
<span>def <span class="ident child-name">run</span></span>(<span class="params">close, pos_th, neg_th, mode=Default(0), short_name='trendlb', hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Run <code><a title="vectorbt.labels.generators.TRENDLB" href="#vectorbt.labels.generators.TRENDLB">TRENDLB</a></code> indicator.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>pos_th</code>, <code>neg_th</code>, <code>mode</code></li>
<li>Outputs: <code>labels</code></li>
</ul>
<p>Pass a list of parameter names as <code>hide_params</code> to hide their column levels.
Set <code>hide_default</code> to False to show the column levels of the parameters with a default value.</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.indicators.factory.run_pipeline" href="../indicators/factory.html#vectorbt.indicators.factory.run_pipeline">run_pipeline()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.run_combs"><code class="name flex">
<span>def <span class="ident child-name">run_combs</span></span>(<span class="params">close, pos_th, neg_th, mode=Default(0), r=2, param_product=False, comb_func=itertools.combinations, run_unique=True, short_names=None, hide_params=None, hide_default=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Create a combination of multiple <code><a title="vectorbt.labels.generators.TRENDLB" href="#vectorbt.labels.generators.TRENDLB">TRENDLB</a></code> indicators using function <code>comb_func</code>.</p>
<ul>
<li>Inputs: <code>close</code></li>
<li>Parameters: <code>pos_th</code>, <code>neg_th</code>, <code>mode</code></li>
<li>Outputs: <code>labels</code></li>
</ul>
<p><code>comb_func</code> must accept an iterable of parameter tuples and <code>r</code>.
Also accepts all combinatoric iterators from itertools such as <code>itertools.combinations</code>.
Pass <code>r</code> to specify how many indicators to run.
Pass <code>short_names</code> to specify the short name for each indicator.
Set <code>run_unique</code> to True to first compute raw outputs for all parameters,
and then use them to build each indicator (faster).</p>
<p>Other keyword arguments are passed to <code><a title="vectorbt.labels.generators.TRENDLB.run" href="#vectorbt.labels.generators.TRENDLB.run">run()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;A factory for building new indicators with ease.

The indicator factory class `IndicatorFactory` offers a convenient way to create technical
indicators of any complexity. By providing it with information such as calculation functions and
the names of your inputs, parameters, and outputs, it will create a stand-alone indicator class
capable of running the indicator for an arbitrary combination of your inputs and parameters. It also
creates methods for signal generation and supports common pandas and parameter indexing operations.

Each indicator is basically a pipeline that:

* Accepts a list of input arrays (for example, OHLCV data)
* Accepts a list of parameter arrays (for example, window size)
* Accepts other relevant arguments and keyword arguments
* For each parameter combination, performs calculation on the input arrays
* Concatenates results into new output arrays (for example, rolling average)

This pipeline can be well standardized, which is done by `run_pipeline`.

`IndicatorFactory` simplifies the usage of `run_pipeline` by generating and pre-configuring
a new Python class with various class methods for running the indicator.

Each generated class includes the following features:

* Accepts input arrays of any compatible shape thanks to broadcasting
* Accepts output arrays written in-place instead of returning
* Accepts arbitrary parameter grids
* Supports caching and other optimizations out of the box
* Supports pandas and parameter indexing
* Offers helper methods for all inputs, outputs, and properties

Consider the following price DataFrame composed of two columns, one per asset:

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; from numba import njit
&gt;&gt;&gt; from datetime import datetime

&gt;&gt;&gt; price = pd.DataFrame({
...     &#39;a&#39;: [1, 2, 3, 4, 5],
...     &#39;b&#39;: [5, 4, 3, 2, 1]
... }, index=pd.Index([
...     datetime(2020, 1, 1),
...     datetime(2020, 1, 2),
...     datetime(2020, 1, 3),
...     datetime(2020, 1, 4),
...     datetime(2020, 1, 5),
... ])).astype(float)
&gt;&gt;&gt; price
            a    b
2020-01-01  1.0  5.0
2020-01-02  2.0  4.0
2020-01-03  3.0  3.0
2020-01-04  4.0  2.0
2020-01-05  5.0  1.0
```

For each column in the DataFrame, let&#39;s calculate a simple moving average and get its
crossover with price. In particular, we want to test two different window sizes: 2 and 3.

## Naive approach

A naive way of doing this:

```python-repl
&gt;&gt;&gt; ma_df = pd.DataFrame.vbt.concat(
...     price.rolling(window=2).mean(),
...     price.rolling(window=3).mean(),
...     keys=pd.Index([2, 3], name=&#39;ma_window&#39;))
&gt;&gt;&gt; ma_df
ma_window          2         3
              a    b    a    b
2020-01-01  NaN  NaN  NaN  NaN
2020-01-02  1.5  4.5  NaN  NaN
2020-01-03  2.5  3.5  2.0  4.0
2020-01-04  3.5  2.5  3.0  3.0
2020-01-05  4.5  1.5  4.0  2.0

&gt;&gt;&gt; above_signals = (price.vbt.tile(2).vbt &gt; ma_df)
&gt;&gt;&gt; above_signals = above_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; above_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02   True  False  False  False
2020-01-03  False  False   True  False
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False

&gt;&gt;&gt; below_signals = (price.vbt.tile(2).vbt &lt; ma_df)
&gt;&gt;&gt; below_signals = below_signals.vbt.signals.first(after_false=True)
&gt;&gt;&gt; below_signals
ma_window              2             3
                a      b      a      b
2020-01-01  False  False  False  False
2020-01-02  False   True  False  False
2020-01-03  False  False  False   True
2020-01-04  False  False  False  False
2020-01-05  False  False  False  False
```

Now the same using `IndicatorFactory`:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; myind = MyInd.run(price, [2, 3])
&gt;&gt;&gt; above_signals = myind.price_crossed_above(myind.ma)
&gt;&gt;&gt; below_signals = myind.price_crossed_below(myind.ma)
```

The `IndicatorFactory` class is used to construct indicator classes from UDFs. First, we provide
all the necessary information (indicator conig) to build the facade of the indicator, such as the names
of inputs, parameters, and outputs, and the actual calculation function. The factory then generates a
self-contained indicator class capable of running arbitrary configurations of inputs and parameters.
To run any configuration, we can either use the `run` method (as we did above) or the `run_combs` method.

## run and run_combs methods

The main method to run an indicator is `run`, which accepts arguments based on the config
provided to the `IndicatorFactory` (see the example above). These arguments include input arrays,
in-place output arrays, parameters, and arguments for `run_pipeline`.

The `run_combs` method takes the same inputs as the method above, but computes all combinations
of passed parameters based on a combinatorial function and returns multiple instances that
can be compared with each other. For example, this is useful to generate crossover signals
of multiple moving averages:

```python-repl
&gt;&gt;&gt; myind1, myind2 = MyInd.run_combs(price, [2, 3, 4])

&gt;&gt;&gt; myind1.ma
myind_1_window                  2         3
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     1.5  4.5  1.5  4.5  NaN  NaN
2020-01-03     2.5  3.5  2.5  3.5  2.0  4.0
2020-01-04     3.5  2.5  3.5  2.5  3.0  3.0
2020-01-05     4.5  1.5  4.5  1.5  4.0  2.0

&gt;&gt;&gt; myind2.ma
myind_2_window        3                   4
                 a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     2.0  4.0  NaN  NaN  NaN  NaN
2020-01-04     3.0  3.0  2.5  3.5  2.5  3.5
2020-01-05     4.0  2.0  3.5  2.5  3.5  2.5

&gt;&gt;&gt; myind1.ma_crossed_above(myind2.ma)
myind_1_window                          2             3
myind_2_window            3             4             4
                   a      b      a      b      a      b
2020-01-01     False  False  False  False  False  False
2020-01-02     False  False  False  False  False  False
2020-01-03      True  False  False  False  False  False
2020-01-04     False  False   True  False   True  False
2020-01-05     False  False  False  False  False  False
```

Its main advantage is that it doesn&#39;t need to re-compute each combination thanks to smart caching.

To get details on what arguments are accepted by any of the class methods, use `help`:

```python-repl
&gt;&gt;&gt; help(MyInd.run)
Help on method run:

run(price, window, short_name=&#39;custom&#39;, hide_params=None, hide_default=True, **kwargs) method of builtins.type instance
    Run `Indicator` indicator.

    * Inputs: `price`
    * Parameters: `window`
    * Outputs: `ma`

    Pass a list of parameter names as `hide_params` to hide their column levels.
    Set `hide_default` to False to show the column levels of the parameters with a default value.

    Other keyword arguments are passed to `vectorbt.indicators.factory.run_pipeline`.
```

## Parameters

`IndicatorFactory` allows definition of arbitrary parameter grids.

Parameters are variables that can hold one or more values. A single value can be passed as a
scalar, an array, or any other object. Multiple values are passed as a list or an array
(if the flag `is_array_like` is set to False for that parameter). If there are multiple parameters
and each is having multiple values, their values will broadcast to a single shape:

```plaintext
       p1         p2            result
0       0          1          [(0, 1)]
1  [0, 1]        [2]  [(0, 2), (1, 2)]
2  [0, 1]     [2, 3]  [(0, 2), (1, 3)]
3  [0, 1]  [2, 3, 4]             error
```

To illustrate the usage of parameters in indicators, let&#39;s build a basic indicator that returns 1
if the rolling mean is within upper and lower bounds, and -1 if it&#39;s outside:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window, price.shape[0]):
...             mean = np.mean(price[i - window:i, col])
...             output[i, col] = lower &lt; mean &lt; upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)
```

By default, when `per_column` is set to False, each parameter is applied to the entire input.

One parameter combination:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=2,
...     lower=3,
...     upper=5
... ).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Multiple parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=3,
...     upper=5
... ).output
custom_window         2         3
custom_lower          3         3
custom_upper          5         5
                 a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  NaN  NaN
2020-01-04     0.0  1.0  0.0  1.0
2020-01-05     1.0  0.0  0.0  0.0
```

Product of parameter combinations:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     param_product=True
... ).output
custom_window                   2                   3
custom_lower          3         4         3         4
custom_upper          5         5         5         5
                 a    b    a    b    a    b    a    b
2020-01-01     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-02     NaN  NaN  NaN  NaN  NaN  NaN  NaN  NaN
2020-01-03     0.0  1.0  0.0  1.0  NaN  NaN  NaN  NaN
2020-01-04     0.0  1.0  0.0  0.0  0.0  1.0  0.0  0.0
2020-01-05     1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0
```

Multiple parameter combinations, one per column:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[2, 3],
...     lower=[3, 4],
...     upper=5,
...     per_column=True
... ).output
custom_window    2    3
custom_lower     3    4
custom_upper     5    5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  NaN
2020-01-04     0.0  0.0
2020-01-05     1.0  0.0
```

Parameter defaults can be passed directly to the `IndicatorFactory.from_custom_func` and
`IndicatorFactory.from_apply_func`, and overriden in the run method:

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, window=2, lower=3, upper=4)

&gt;&gt;&gt; MyInd.run(price, upper=5).output
custom_window         2
custom_lower          3
custom_upper          5
                 a    b
2020-01-01     NaN  NaN
2020-01-02     NaN  NaN
2020-01-03     0.0  1.0
2020-01-04     0.0  1.0
2020-01-05     1.0  0.0
```

Some parameters are meant to be defined per row, column, or element of the input.
By default, if we pass the parameter value as an array, the indicator will treat this array
as a list of multiple values - one per input. To make the indicator view this array as a single
value, set the flag `is_array_like` to True in `param_settings`. Also, to automatically broadcast
the passed scalar/array to the input shape, set `bc_to_input` to True, 0 (index axis), or 1 (column axis).

In our example, the parameter `window` can broadcast per column, and both parameters
`lower` and `upper` can broadcast per element:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         for i in range(window[col], price.shape[0]):
...             mean = np.mean(price[i - window[col]:i, col])
...             output[i, col] = lower[i, col] &lt; mean &lt; upper[i, col]
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=dict(is_array_like=True, bc_to_input=1, per_column=True),
...         lower=dict(is_array_like=True, bc_to_input=True),
...         upper=dict(is_array_like=True, bc_to_input=True)
...     )
... )

&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=np.array([1, 2]),
...     upper=np.array([3, 4]),
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     0.0     1.0     NaN
2020-01-05        0.0     1.0     0.0     1.0
```

Broadcasting a huge number of parameters to the input shape can consume lots of memory,
especially when the array materializes. Luckily, vectorbt implements flexible broadcasting,
which preserves the original dimensions of the parameter. This requires two changes:
setting `keep_raw` to True in `broadcast_kwargs` and passing `flex_2d` to the apply function.

There are two configs in `vectorbt.indicators.configs` exactly for this purpose: one for column-wise
broadcasting and one for element-wise broadcasting:

```python-repl
&gt;&gt;&gt; from vectorbt.base.reshape_fns import flex_select_auto_nb
&gt;&gt;&gt; from vectorbt.indicators.configs import flex_col_param_config, flex_elem_param_config

&gt;&gt;&gt; @njit
... def apply_func_nb(price, window, lower, upper, flex_2d):
...     output = np.full(price.shape, np.nan, dtype=np.float_)
...     for col in range(price.shape[1]):
...         _window = flex_select_auto_nb(window, 0, col, flex_2d)
...         for i in range(_window, price.shape[0]):
...             _lower = flex_select_auto_nb(lower, i, col, flex_2d)
...             _upper = flex_select_auto_nb(upper, i, col, flex_2d)
...             mean = np.mean(price[i - _window:i, col])
...             output[i, col] = _lower &lt; mean &lt; _upper
...     return output

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;, &#39;lower&#39;, &#39;upper&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     param_settings=dict(
...         window=flex_col_param_config,
...         lower=flex_elem_param_config,
...         upper=flex_elem_param_config
...     ),
...     pass_flex_2d=True
... )
```

Both bound parameters can now be passed as a scalar (value per whole input), a 1-dimensional
array (value per row or column, depending upon whether input is a Series or a DataFrame),
a 2-dimensional array (value per element), or a list of any of those. This allows for the
highest parameter flexibility at the lowest memory cost.

For example, let&#39;s build a grid of two parameter combinations, each being one window size per column
and both bounds per element:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price,
...     window=[np.array([2, 3]), np.array([3, 4])],
...     lower=price.values - 3,
...     upper=price.values + 3,
... ).output
custom_window       2       3               4
custom_lower  array_0 array_0 array_1 array_1
custom_upper  array_0 array_0 array_1 array_1
                    a       b       a       b
2020-01-01        NaN     NaN     NaN     NaN
2020-01-02        NaN     NaN     NaN     NaN
2020-01-03        1.0     NaN     NaN     NaN
2020-01-04        1.0     1.0     1.0     NaN
2020-01-05        1.0     1.0     1.0     1.0
```

Indicators can also be parameterless. See `vectorbt.indicators.basic.OBV`.

## Inputs

`IndicatorFactory` supports passing none, one, or multiple inputs. If multiple inputs are passed,
it tries to broadcast them into a single shape.

Remember that in vectorbt each column means a separate backtest instance. That&#39;s why in order to use
multiple pieces of information, such as open, high, low, close, and volume, we need to provide
them as separate pandas objects rather than a single DataFrame.

Let&#39;s create a parameterless indicator that measures the position of the close price within each bar:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(high, low, close):
...     return (close - low) / (high - low)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;high&#39;, &#39;low&#39;, &#39;close&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price + 1, price - 1, price).output
              a    b
2020-01-01  0.5  0.5
2020-01-02  0.5  0.5
2020-01-03  0.5  0.5
2020-01-04  0.5  0.5
2020-01-05  0.5  0.5
```

To demonstrate broadcasting, let&#39;s pass high as a DataFrame, low as a Series, and close as a scalar:

```python-repl
&gt;&gt;&gt; df = pd.DataFrame(np.random.uniform(1, 2, size=(5, 2)))
&gt;&gt;&gt; sr = pd.Series(np.random.uniform(0, 1, size=5))
&gt;&gt;&gt; MyInd.run(df, sr, 1).output
          0         1
0  0.960680  0.666820
1  0.400646  0.528456
2  0.093467  0.134777
3  0.037210  0.102411
4  0.529012  0.652602
```

By default, if a Series was passed, it&#39;s automatically expanded into a 2-dimensional array.
To keep it as 1-dimensional, set `to_2d` to False.

Similar to parameters, we can also define defaults for inputs. In addition to using scalars
and arrays as default values, we can reference other inputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(ts1, ts2, ts3):
...     return ts1 + ts2 + ts3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;ts1&#39;, &#39;ts2&#39;, &#39;ts3&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(apply_func_nb, ts2=&#39;ts1&#39;, ts3=&#39;ts1&#39;)

&gt;&gt;&gt; MyInd.run(price).output
               a     b
2020-01-01   3.0  15.0
2020-01-02   6.0  12.0
2020-01-03   9.0   9.0
2020-01-04  12.0   6.0
2020-01-05  15.0   3.0

&gt;&gt;&gt; MyInd.run(price, ts2=price * 2).output
               a     b
2020-01-01   4.0  20.0
2020-01-02   8.0  16.0
2020-01-03  12.0  12.0
2020-01-04  16.0   8.0
2020-01-05  20.0   4.0
```

What if an indicator doesn&#39;t take any input arrays? In that case, we can force the user to
at least provide the input shape. Let&#39;s define a generator that emulates random returns and
generates synthetic price:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(input_shape, start, mu, sigma):
...     rand_returns = np.random.normal(mu, sigma, input_shape)
...     return start * vbt.nb.nancumprod_nb(rand_returns + 1)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;start&#39;, &#39;mu&#39;, &#39;sigma&#39;],
...     output_names=[&#39;output&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     require_input_shape=True,
...     seed=42
... )

&gt;&gt;&gt; MyInd.run(price.shape, 100, 0, 0.01).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
0             100.496714   99.861736
1             101.147620  101.382660
2             100.910779  101.145285
3             102.504375  101.921510
4             102.023143  102.474495
```

We can also supply pandas meta such as `input_index` and `input_columns` to the run method:

```python-repl
&gt;&gt;&gt; MyInd.run(
...     price.shape, 100, 0, 0.01,
...     input_index=price.index, input_columns=price.columns
... ).output
custom_start                     100
custom_mu                          0
custom_sigma        0.01        0.01
                       a           b
2020-01-01    100.496714   99.861736
2020-01-02    101.147620  101.382660
2020-01-03    100.910779  101.145285
2020-01-04    102.504375  101.921510
2020-01-05    102.023143  102.474495
```

One can even build input-less indicator that decides on the output shape dynamically:

```python-repl
&gt;&gt;&gt; from vectorbt.base.combine_fns import apply_and_concat_one

&gt;&gt;&gt; def apply_func(i, ps, input_shape):
...      out = np.full(input_shape, 0)
...      out[:ps[i]] = 1
...      return out

&gt;&gt;&gt; def custom_func(ps):
...     input_shape = (np.max(ps),)
...     return apply_and_concat_one(len(ps), apply_func, ps, input_shape)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     param_names=[&#39;p&#39;],
...     output_names=[&#39;output&#39;]
... ).from_custom_func(custom_func)

&gt;&gt;&gt; MyInd.run([1, 2, 3, 4, 5]).output
custom_p  1  2  3  4  5
0         1  1  1  1  1
1         0  1  1  1  1
2         0  0  1  1  1
3         0  0  0  1  1
4         0  0  0  0  1
```

## Outputs

There are two types of outputs: regular and in-place outputs:

* Regular outputs are one or more arrays returned by the function. Each should have an exact
same shape and match the number of columns in the input multiplied by the number of parameter values.
* In-place outputs are not returned but modified in-place. They broadcast together with inputs
and are passed to the calculation function as a list, one per parameter.

Two regular outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price - 1, price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out2, myind.price + 1)
```

One regular output and one in-place output:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out2):
...     in_out2[:] = price + 1
...     return price - 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;],
...     in_output_names=[&#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

Two in-place outputs:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = price - 1
...     in_out2[:] = price + 1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out1, myind.price - 1)
&gt;&gt;&gt; pd.testing.assert_frame_equal(myind.in_out2, myind.price + 1)
```

By default, in-place outputs are created as empty arrays with uninitialized values.
This allows creation of optional outputs that, if not written, do not occupy much memory.
Since not all outputs are meant to be of data type `float`, we can pass `dtype` in the `in_output_settings`.

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out):
...     in_out[:] = price &gt; np.mean(price)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_output_settings=dict(in_out=dict(dtype=bool))
... )

&gt;&gt;&gt; MyInd.run(price).in_out
                a      b
2020-01-01  False   True
2020-01-02  False   True
2020-01-03  False  False
2020-01-04   True  False
2020-01-05   True  False
```

Another advantage of in-place outputs is that we can provide their initial state:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price, in_out1, in_out2):
...     in_out1[:] = in_out1 + price
...     in_out2[:] = in_out2 + price

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     in_output_names=[&#39;in_out1&#39;, &#39;in_out2&#39;]
... ).from_apply_func(
...     apply_func_nb,
...     in_out1=100,
...     in_out2=&#39;price&#39;
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.in_out1
              a    b
2020-01-01  101  105
2020-01-02  102  104
2020-01-03  103  103
2020-01-04  104  102
2020-01-05  105  101
&gt;&gt;&gt; myind.in_out2
               a     b
2020-01-01   2.0  10.0
2020-01-02   4.0   8.0
2020-01-03   6.0   6.0
2020-01-04   8.0   4.0
2020-01-05  10.0   2.0
```

## Without Numba

It&#39;s also possible to supply a function that is not Numba-compiled. This is handy when working with
third-party libraries (see the implementation of `IndicatorFactory.from_talib`). Additionally,
we can set `keep_pd` to True to pass all inputs as pandas objects instead of raw NumPy arrays.

!!! note
    Already broadcasted pandas meta will be provided; that is, each input array will have the
    same index and columns.

Let&#39;s demonstrate this by wrapping a basic composed [pandas_ta](https://github.com/twopirllc/pandas-ta) strategy:

```python-repl
&gt;&gt;&gt; import pandas_ta

&gt;&gt;&gt; def apply_func(open, high, low, close, volume, ema_len, linreg_len):
...     df = pd.DataFrame(dict(open=open, high=high, low=low, close=close, volume=volume))
...     df.ta.strategy(pandas_ta.Strategy(&#34;MyStrategy&#34;, [
...         dict(kind=&#39;ema&#39;, length=ema_len),
...         dict(kind=&#39;linreg&#39;, close=&#39;EMA_&#39; + str(ema_len), length=linreg_len)
...     ]))
...     return tuple([df.iloc[:, i] for i in range(5, len(df.columns))])

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;open&#39;, &#39;high&#39;, &#39;low&#39;, &#39;close&#39;, &#39;volume&#39;],
...     param_names=[&#39;ema_len&#39;, &#39;linreg_len&#39;],
...     output_names=[&#39;ema&#39;, &#39;ema_linreg&#39;]
... ).from_apply_func(
...     apply_func,
...     keep_pd=True,
...     to_2d=False
... )

&gt;&gt;&gt; my_ind = MyInd.run(
...     ohlcv[&#39;Open&#39;],
...     ohlcv[&#39;High&#39;],
...     ohlcv[&#39;Low&#39;],
...     ohlcv[&#39;Close&#39;],
...     ohlcv[&#39;Volume&#39;],
...     ema_len=5,
...     linreg_len=[8, 9, 10]
... )

&gt;&gt;&gt; my_ind.ema_linreg
custom_ema_len                                            5
custom_linreg_len            8             9             10
date
2021-02-02                  NaN           NaN           NaN
2021-02-03                  NaN           NaN           NaN
2021-02-04                  NaN           NaN           NaN
2021-02-05                  NaN           NaN           NaN
2021-02-06                  NaN           NaN           NaN
...                         ...           ...           ...
2021-02-25         52309.302811  52602.005326  52899.576568
2021-02-26         50797.264793  51224.188381  51590.825690
2021-02-28         49217.904905  49589.546052  50066.206828
2021-03-01         48316.305403  48553.540713  48911.701664
2021-03-02         47984.395969  47956.885953  48150.929668
```

In the example above, only one Series per open, high, low, close, and volume can be passed.
To enable the indicator to process two-dimensional data, set `to_2d` to True and create a loop
over each column in the `apply_func`.

!!! hint
    Writing a native Numba-compiled code may provide a performance that is magnitudes higher
    than that offered by libraries that work on pandas.

## Raw outputs and caching

`IndicatorFactory` re-uses calculation artifacts whenever possible. Since it was originally designed
for hyperparameter optimization and there are times when parameter values gets repeated,
prevention of processing the same parameter over and over again is inevitable for good performance.
For instance, when the `run_combs` method is being used and `run_unique` is set to True, it first calculates
the raw outputs of all unique parameter combinations and then uses them to build outputs for
the whole parameter grid.

Let&#39;s first take a look at a typical raw output by setting `return_raw` to True:

```python-repl
&gt;&gt;&gt; raw = vbt.MA.run(price, 2, [False, True], return_raw=True)
&gt;&gt;&gt; raw
([array([[       nan,        nan,        nan,        nan],
         [1.5       , 4.5       , 1.66666667, 4.33333333],
         [2.5       , 3.5       , 2.55555556, 3.44444444],
         [3.5       , 2.5       , 3.51851852, 2.48148148],
         [4.5       , 1.5       , 4.50617284, 1.49382716]])],
 [(2, False), (2, True)],
 2,
 [])
```

It consists of a list of the returned output arrays, a list of the zipped parameter combinations,
the number of input columns, and other objects returned along with output arrays but not listed
in `output_names`. The next time we decide to run the indicator on a subset of the parameters above,
we can simply pass this tuple as the `use_raw` argument. This won&#39;t call the calculation function and
will throw an error if some of the requested parameter combinations cannot be found in `raw`.

```python-repl
&gt;&gt;&gt; vbt.MA.run(price, 2, True, use_raw=raw).ma
ma_window                    2
ma_ewm                    True
                   a         b
2020-01-01       NaN       NaN
2020-01-02  1.666667  4.333333
2020-01-03  2.555556  3.444444
2020-01-04  3.518519  2.481481
2020-01-05  4.506173  1.493827
```

Here is how the performance compares when repeatedly running the same parameter combination
with and without `run_unique`:

```python-repl
&gt;&gt;&gt; a = np.random.uniform(size=(1000,))

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=False)
73.4 ms Â± 4.76 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)

&gt;&gt;&gt; %timeit vbt.MA.run(a, np.full(1000, 2), run_unique=True)
8.99 ms Â± 114 Âµs per loop (mean Â± std. dev. of 7 runs, 100 loops each)
```

!!! note
    `run_unique` is disabled by default.

Enable `run_unique` if input arrays have few columns and there are tons of repeated parameter combinations.
Disable `run_unique` if input arrays are very wide, if two identical parameter combinations can lead to
different results, or when requesting raw output, cache, or additional outputs outside of `output_names`.

Another performance enhancement can be introduced by caching, which has to be implemented by the user.
The class method `IndicatorFactory.from_apply_func` has an argument `cache_func`, which is called
prior to the main calculation.

Consider the following scenario: we want to compute the relative distance between two expensive
rolling windows. We have already decided on the value for the first window, and want to test
thousands of values for the second window. Without caching, and even with `run_unique` enabled,
the first rolling window will be re-calculated over and over again and waste our resources:

```python-repl
&gt;&gt;&gt; @njit
... def roll_mean_expensive_nb(price, w):
...     for i in range(100):
...         out = vbt.nb.rolling_mean_nb(price, w)
...     return out

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2):
...     roll_mean1 = roll_mean_expensive_nb(price, w1)
...     roll_mean2 = roll_mean_expensive_nb(price, w2)
...     return (roll_mean2 - roll_mean1) / roll_mean1

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
264 ms Â± 3.22 ms per loop (mean Â± std. dev. of 7 runs, 1 loop each)
```

To avoid this, let&#39;s cache all unique rolling windows:

```python-repl
&gt;&gt;&gt; @njit
... def cache_func_nb(price, ws1, ws2):
...     cache_dict = dict()
...     ws = ws1.copy()
...     ws.extend(ws2)
...     for i in range(len(ws)):
...         h = hash((ws[i]))
...         if h not in cache_dict:
...             cache_dict[h] = roll_mean_expensive_nb(price, ws[i])
...     return cache_dict

&gt;&gt;&gt; @njit
... def apply_func_nb(price, w1, w2, cache_dict):
...     return (cache_dict[hash(w2)] - cache_dict[hash(w1)]) / cache_dict[hash(w1)]

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;w1&#39;, &#39;w2&#39;],
...     output_names=[&#39;output&#39;],
... ).from_apply_func(apply_func_nb, cache_func=cache_func_nb)

&gt;&gt;&gt; MyInd.run(price, 2, 3).output
custom_w1                    2
custom_w2                    3
                   a         b
2020-01-01       NaN       NaN
2020-01-02       NaN       NaN
2020-01-03 -0.200000  0.142857
2020-01-04 -0.142857  0.200000
2020-01-05 -0.111111  0.333333

&gt;&gt;&gt; %timeit MyInd.run(price, 2, np.arange(2, 1000))
145 ms Â± 4.55 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

We have cut down the processing time almost in half.

Similar to raw outputs, we can force `IndicatorFactory` to return the cache, so it can be used
in other calculations or even indicators. The clear advantage of this approach is that we don&#39;t
rely on some fixed set of parameter combinations any more, but on the values of each parameter,
which gives us more granularity in managing performance.

```python-repl
&gt;&gt;&gt; cache = MyInd.run(price, 2, np.arange(2, 1000), return_cache=True)

&gt;&gt;&gt; %timeit MyInd.run(price, np.arange(2, 1000), np.arange(2, 1000), use_cache=cache)
30.1 ms Â± 2 ms per loop (mean Â± std. dev. of 7 runs, 10 loops each)
```

## Custom properties and methods

Use `custom_output_props` argument when constructing an indicator to define lazy outputs -
outputs that are processed only when explicitly called. They will become cached properties
and, in contrast to regular outputs, they can have an arbitrary shape. For example, let&#39;s
attach a property that will calculate the distance between the moving average and the price.

```python-repl
&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     param_names=[&#39;window&#39;],
...     output_names=[&#39;ma&#39;],
...     custom_output_props=dict(distance=lambda self: (self.price - self.ma) / self.ma)
... ).from_apply_func(vbt.nb.rolling_mean_nb)

&gt;&gt;&gt; MyInd.run(price, [2, 3]).distance
custom_window                   2                   3
                      a         b         a         b
2020-01-01          NaN       NaN       NaN       NaN
2020-01-02     0.333333 -0.111111       NaN       NaN
2020-01-03     0.200000 -0.142857  0.500000 -0.250000
2020-01-04     0.142857 -0.200000  0.333333 -0.333333
2020-01-05     0.111111 -0.333333  0.250000 -0.500000
```

Another way of defining own properties and methods is subclassing:

```python-repl
&gt;&gt;&gt; class MyIndExtended(MyInd):
...     def plot(self, column=None, **kwargs):
...         self_col = self.select_one(column=column, group_by=False)
...         return self.ma.vbt.plot(**kwargs)

&gt;&gt;&gt; MyIndExtended.run(price, [2, 3])[(2, &#39;a&#39;)].plot()
```

![](/docs/img/MyInd_plot.svg)

## Helper properties and methods

For all in `input_names`, `in_output_names`, `output_names`, and `custom_output_props`,
`IndicatorFactory` will create a bunch of comparison and combination methods, such as for generating signals.
What kind of methods are created can be regulated using `dtype` in the `attr_settings` dictionary.

```python-repl
&gt;&gt;&gt; from collections import namedtuple

&gt;&gt;&gt; MyEnum = namedtuple(&#39;MyEnum&#39;, [&#39;one&#39;, &#39;two&#39;])(0, 1)

&gt;&gt;&gt; def apply_func_nb(price):
...     out_float = np.empty(price.shape, dtype=np.float_)
...     out_bool = np.empty(price.shape, dtype=np.bool_)
...     out_enum = np.empty(price.shape, dtype=np.int_)
...     return out_float, out_bool, out_enum

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out_float&#39;, &#39;out_bool&#39;, &#39;out_enum&#39;],
...     attr_settings=dict(
...         out_float=dict(dtype=np.float_),
...         out_bool=dict(dtype=np.bool_),
...         out_enum=dict(dtype=MyEnum)
... )).from_apply_func(apply_func_nb)

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; dir(myind)
[
    ...
    &#39;out_bool&#39;,
    &#39;out_bool_and&#39;,
    &#39;out_bool_or&#39;,
    &#39;out_bool_stats&#39;,
    &#39;out_bool_xor&#39;,
    &#39;out_enum&#39;,
    &#39;out_enum_readable&#39;,
    &#39;out_enum_stats&#39;,
    &#39;out_float&#39;,
    &#39;out_float_above&#39;,
    &#39;out_float_below&#39;,
    &#39;out_float_equal&#39;,
    &#39;out_float_stats&#39;,
    ...
    &#39;price&#39;,
    &#39;price_above&#39;,
    &#39;price_below&#39;,
    &#39;price_equal&#39;,
    &#39;price_stats&#39;,
    ...
]
```

Each of these methods and properties are created for sheer convenience: to easily combine
boolean arrays using logical rules and to compare numeric arrays. All operations are done
strictly using NumPy. Another advantage is utilization of vectorbt&#39;s own broadcasting, such
that one can combine inputs and outputs with an arbitrary array-like object, given their
shapes can broadcast together.

We can also do comparison with multiple objects at once by passing them as a tuple/list:

```python-repl
&gt;&gt;&gt; myind.price_above([1.5, 2.5])
custom_price_above           1.5           2.5
                        a      b      a      b
2020-01-01          False   True  False   True
2020-01-02           True   True  False   True
2020-01-03           True   True   True   True
2020-01-04           True   True   True  False
2020-01-05           True  False   True  False
```

## Indexing

`IndicatorFactory` attaches pandas indexing to the indicator class thanks to
`vectorbt.base.array_wrapper.ArrayWrapper`. Supported are `iloc`, `loc`,
`*param_name*_loc`, `xs`, and `__getitem__`.

This makes possible accessing rows and columns by labels, integer positions, and parameters.

```python-repl
&gt;&gt;&gt; ma = vbt.MA.run(price, [2, 3])

&gt;&gt;&gt; ma[(2, &#39;b&#39;)]
&lt;vectorbt.indicators.basic.MA at 0x7fe4d10ddcc0&gt;

&gt;&gt;&gt; ma[(2, &#39;b&#39;)].ma
2020-01-01    NaN
2020-01-02    4.5
2020-01-03    3.5
2020-01-04    2.5
2020-01-05    1.5
Name: (2, b), dtype: float64

&gt;&gt;&gt; ma.window_loc[2].ma
              a    b
2020-01-01  NaN  NaN
2020-01-02  1.5  4.5
2020-01-03  2.5  3.5
2020-01-04  3.5  2.5
2020-01-05  4.5  1.5
```

## TA-Lib

Indicator factory also provides a class method `IndicatorFactory.from_talib`
that can be used to wrap any function from TA-Lib. It automatically fills all the
neccessary information, such as input, parameter and output names.

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats`.

We can attach metrics to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     metrics=dict(
...         sum_diff=dict(
...             calc_func=lambda self: self.out2.sum() - self.out1.sum()
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.stats(column=&#39;a&#39;)
sum_diff    170.0
Name: a, dtype: float64
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots`.

Similarly to stats, we can attach subplots to any new indicator class:

```python-repl
&gt;&gt;&gt; @njit
... def apply_func_nb(price):
...     return price ** 2, price ** 3

&gt;&gt;&gt; def plot_outputs(out1, out2, column=None, fig=None):
...     fig = out1[column].rename(&#39;out1&#39;).vbt.plot(fig=fig)
...     fig = out2[column].rename(&#39;out2&#39;).vbt.plot(fig=fig)

&gt;&gt;&gt; MyInd = vbt.IndicatorFactory(
...     input_names=[&#39;price&#39;],
...     output_names=[&#39;out1&#39;, &#39;out2&#39;],
...     subplots=dict(
...         plot_outputs=dict(
...             plot_func=plot_outputs,
...             resolve_out1=True,
...             resolve_out2=True
...         )
...     )
... ).from_apply_func(
...     apply_func_nb
... )

&gt;&gt;&gt; myind = MyInd.run(price)
&gt;&gt;&gt; myind.plots(column=&#39;a&#39;)
```

![](/docs/img/IndicatorFactory_plots.svg)
&#34;&#34;&#34;

import inspect
import itertools
import warnings
from collections import Counter
from collections import OrderedDict
from datetime import datetime, timedelta
from types import ModuleType

import numpy as np
import pandas as pd
from numba import njit
from numba.typed import List

from vectorbt import _typing as tp
from vectorbt.base import index_fns, reshape_fns, combine_fns
from vectorbt.base.array_wrapper import ArrayWrapper, Wrapping
from vectorbt.base.indexing import build_param_indexer
from vectorbt.generic import nb as generic_nb
from vectorbt.generic.accessors import BaseAccessor
from vectorbt.generic.plots_builder import PlotsBuilderMixin
from vectorbt.generic.stats_builder import StatsBuilderMixin
from vectorbt.utils import checks
from vectorbt.utils.config import merge_dicts, resolve_dict, Config, Default
from vectorbt.utils.decorators import classproperty, cached_property
from vectorbt.utils.docs import to_doc
from vectorbt.utils.enum_ import map_enum_fields
from vectorbt.utils.mapping import to_mapping, apply_mapping
from vectorbt.utils.params import to_typed_list, broadcast_params, create_param_product
from vectorbt.utils.random_ import set_seed

try:
    from ta.utils import IndicatorMixin as IndicatorMixinT
except ImportError:
    IndicatorMixinT = tp.Any


def params_to_list(params: tp.Params, is_tuple: bool, is_array_like: bool) -&gt; list:
    &#34;&#34;&#34;Cast parameters to a list.&#34;&#34;&#34;
    check_against = [list, List]
    if not is_tuple:
        check_against.append(tuple)
    if not is_array_like:
        check_against.append(np.ndarray)
    if isinstance(params, tuple(check_against)):
        new_params = list(params)
    else:
        new_params = [params]
    return new_params</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.labels.generators.TRENDLB.close"><code class="name">var <span class="ident child-name">close</span></code></dt>
<dd>
<div class="desc"><p>Input array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.labels"><code class="name">var <span class="ident child-name">labels</span></code></dt>
<dd>
<div class="desc"><p>Output array.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def output_prop(self, _output_name: str = output_name) -&gt; tp.SeriesFrame:
    return self.wrapper.wrap(getattr(self, &#39;_&#39; + _output_name))</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.mode_list"><code class="name">var <span class="ident child-name">mode_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>mode</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.neg_th_list"><code class="name">var <span class="ident child-name">neg_th_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>neg_th</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.pos_th_list"><code class="name">var <span class="ident child-name">pos_th_list</span></code></dt>
<dd>
<div class="desc"><p>List of <code>pos_th</code> values.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def param_list_prop(self, _param_name=param_name) -&gt; tp.List[tp.Param]:
    return getattr(self, f&#39;_{_param_name}_list&#39;)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.labels.generators.TRENDLB.apply_func"><code class="name flex">
<span>def <span class="ident child-name">apply_func</span></span>(<span class="params">close, pos_th, neg_th, mode, flex_2d=True)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Apply a trend labeling function based on <code>TrendMode</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@njit(cache=True)
def trend_labels_apply_nb(close: tp.Array2d,
                          pos_th: tp.MaybeArray[float],
                          neg_th: tp.MaybeArray[float],
                          mode: int,
                          flex_2d: bool = True) -&gt; tp.Array2d:
    &#34;&#34;&#34;Apply a trend labeling function based on `TrendMode`.&#34;&#34;&#34;
    local_extrema = local_extrema_apply_nb(close, pos_th, neg_th, flex_2d)
    if mode == TrendMode.Binary:
        return bn_trend_labels_nb(close, local_extrema)
    if mode == TrendMode.BinaryCont:
        return bn_cont_trend_labels_nb(close, local_extrema)
    if mode == TrendMode.BinaryContSat:
        return bn_cont_sat_trend_labels_nb(close, local_extrema, pos_th, neg_th, flex_2d)
    if mode == TrendMode.PctChange:
        return pct_trend_labels_nb(close, local_extrema, False)
    if mode == TrendMode.PctChangeNorm:
        return pct_trend_labels_nb(close, local_extrema, True)
    raise ValueError(&#34;Trend mode is not recognized&#34;)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.close_above"><code class="name flex">
<span>def <span class="ident child-name">close_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.close_below"><code class="name flex">
<span>def <span class="ident child-name">close_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.close_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.close_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">close_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.close_equal"><code class="name flex">
<span>def <span class="ident child-name">close_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>close</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.close_stats"><code class="name flex">
<span>def <span class="ident child-name">close_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>close</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.custom_func"><code class="name flex">
<span>def <span class="ident child-name">custom_func</span></span>(<span class="params">input_list, in_output_list, param_list, *args, input_shape=None, col=None, flex_2d=None, return_cache=False, use_cache=None, use_ray=False, **_kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Custom function that forwards inputs and parameters to <code>apply_func</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def custom_func(input_list: tp.List[tp.AnyArray],
                in_output_list: tp.List[tp.List[tp.AnyArray]],
                param_list: tp.List[tp.List[tp.Param]],
                *args,
                input_shape: tp.Optional[tp.Shape] = None,
                col: tp.Optional[int] = None,
                flex_2d: tp.Optional[bool] = None,
                return_cache: bool = False,
                use_cache: tp.Optional[CacheOutputT] = None,
                use_ray: bool = False,
                **_kwargs) -&gt; tp.Union[None, CacheOutputT, tp.Array2d, tp.List[tp.Array2d]]:
    &#34;&#34;&#34;Custom function that forwards inputs and parameters to `apply_func`.&#34;&#34;&#34;

    if use_ray:
        if len(in_output_names) &gt; 0:
            raise ValueError(&#34;Ray doesn&#39;t support in-place outputs&#34;)
    if numba_loop:
        if use_ray:
            raise ValueError(&#34;Ray cannot be used within Numba&#34;)
        if num_ret_outputs &gt; 1:
            apply_and_concat_func = combine_fns.apply_and_concat_multiple_nb
        elif num_ret_outputs == 1:
            apply_and_concat_func = combine_fns.apply_and_concat_one_nb
        else:
            apply_and_concat_func = combine_fns.apply_and_concat_none_nb
    else:
        if num_ret_outputs &gt; 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_multiple
        elif num_ret_outputs == 1:
            if use_ray:
                apply_and_concat_func = combine_fns.apply_and_concat_one_ray
            else:
                apply_and_concat_func = combine_fns.apply_and_concat_one
        else:
            if use_ray:
                raise ValueError(&#34;Ray requires regular outputs&#34;)
            apply_and_concat_func = combine_fns.apply_and_concat_none

    n_params = len(param_list[0]) if len(param_list) &gt; 0 else 1
    input_tuple = tuple(input_list)
    in_output_tuples = list(zip(*in_output_list))
    param_tuples = list(zip(*param_list))
    args_before = ()
    if input_shape is not None and &#39;input_shape&#39; not in kwargs_to_args:
        args_before += (input_shape,)
    if col is not None and &#39;col&#39; not in kwargs_to_args:
        args_before += (col,)

    # Pass some keyword arguments as positional (required by numba)
    more_args = ()
    for key in kwargs_to_args:
        value = _kwargs.pop(key)  # important: remove from kwargs
        more_args += (value,)
    if flex_2d is not None and &#39;flex_2d&#39; not in kwargs_to_args:
        more_args += (flex_2d,)

    # Caching
    cache = use_cache
    if cache is None and cache_func is not None:
        _in_output_list = in_output_list
        _param_list = param_list
        if checks.is_numba_func(cache_func):
            if len(in_output_list) &gt; 0:
                _in_output_list = [to_typed_list(in_outputs) for in_outputs in in_output_list]
            if len(param_list) &gt; 0:
                _param_list = [to_typed_list(params) for params in param_list]
        cache = cache_func(
            *args_before,
            *input_tuple,
            *_in_output_list,
            *_param_list,
            *args,
            *more_args,
            **_kwargs
        )
    if return_cache:
        return cache
    if cache is None:
        cache = ()
    if not isinstance(cache, tuple):
        cache = (cache,)

    if len(in_output_names) &gt; 0:
        _in_output_tuples = in_output_tuples
        if numba_loop:
            _in_output_tuples = to_typed_list(_in_output_tuples)
        _in_output_tuples = (_in_output_tuples,)
    else:
        _in_output_tuples = ()
    if len(param_names) &gt; 0:
        _param_tuples = param_tuples
        if numba_loop:
            _param_tuples = to_typed_list(_param_tuples)
        _param_tuples = (_param_tuples,)
    else:
        _param_tuples = ()

    return apply_and_concat_func(
        n_params,
        select_params_func,
        args_before,
        input_tuple,
        *_in_output_tuples,
        *_param_tuples,
        *args,
        *more_args,
        *cache,
        **_kwargs
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.labels_above"><code class="name flex">
<span>def <span class="ident child-name">labels_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.labels_below"><code class="name flex">
<span>def <span class="ident child-name">labels_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.labels_crossed_above"><code class="name flex">
<span>def <span class="ident child-name">labels_crossed_above</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is crossed_above <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.labels_crossed_below"><code class="name flex">
<span>def <span class="ident child-name">labels_crossed_below</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is crossed_below <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.labels_equal"><code class="name flex">
<span>def <span class="ident child-name">labels_equal</span></span>(<span class="params">self, other, level_name=None, allow_multiple=True, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Return True for each element where <code>labels</code> is equal <code>other</code>. </p>
<p>See <code><a title="vectorbt.indicators.factory.combine_objs" href="../indicators/factory.html#vectorbt.indicators.factory.combine_objs">combine_objs()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def combine_method(self: IndicatorBaseT,
                   other: tp.MaybeTupleList[tp.Union[IndicatorBaseT, tp.ArrayLike, BaseAccessor]],
                   level_name: tp.Optional[str] = None,
                   allow_multiple: bool = True,
                   _prepend_name: bool = prepend_name,
                   **kwargs) -&gt; tp.SeriesFrame:
    if allow_multiple and isinstance(other, (tuple, list)):
        other = list(other)
        for i in range(len(other)):
            if isinstance(other[i], IndicatorBase):
                other[i] = getattr(other[i], attr_name)
    else:
        if isinstance(other, IndicatorBase):
            other = getattr(other, attr_name)
    if level_name is None:
        if _prepend_name:
            if attr_name == self.short_name:
                level_name = f&#39;{self.short_name}_{func_name}&#39;
            else:
                level_name = f&#39;{self.short_name}_{attr_name}_{func_name}&#39;
        else:
            level_name = f&#39;{attr_name}_{func_name}&#39;
    out = combine_objs(
        getattr(self, attr_name),
        other,
        combine_func=combine_func,
        level_name=level_name,
        allow_multiple=allow_multiple,
        **merge_dicts(def_kwargs, kwargs)
    )
    return out</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.labels_stats"><code class="name flex">
<span>def <span class="ident child-name">labels_stats</span></span>(<span class="params">self, *args, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Stats of <code>labels</code> as generic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def attr_stats(self, *args, _attr_name: str = attr_name, **kwargs) -&gt; tp.SeriesFrame:
    return getattr(self, _attr_name).vbt.stats(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.labels.generators.TRENDLB.plot"><code class="name flex">
<span>def <span class="ident child-name">plot</span></span>(<span class="params">self, column=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Plot <code>close</code> and overlay it with the heatmap of <code>labels</code>.</p>
<p><code>**kwargs</code> are passed to <code><a title="vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap" href="../generic/accessors.html#vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap">GenericSRAccessor.overlay_with_heatmap()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def _plot(self, column: tp.Optional[tp.Label] = None, **kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    &#34;&#34;&#34;Plot `close` and overlay it with the heatmap of `labels`.

    `**kwargs` are passed to `vectorbt.generic.accessors.GenericSRAccessor.overlay_with_heatmap`.&#34;&#34;&#34;
    self_col = self.select_one(column=column, group_by=False)

    return self_col.close.rename(&#39;close&#39;).vbt.overlay_with_heatmap(self_col.labels.rename(&#39;labels&#39;), **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.build_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.deep_getattr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.in_output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.in_output_names">in_output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_func" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.input_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.input_names">input_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.level_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.level_names">level_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_flags" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_flags">output_flags</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.output_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.output_names">output_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_metrics_doc" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.override_subplots_doc" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.param_names" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.param_names">param_names</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.plots_defaults" href="../generic/plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.post_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.pre_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.replace" href="../utils/config.html#vectorbt.utils.config.Configured.replace">replace</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.resolve_self" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.self_aliases" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.short_name" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase.short_name">short_name</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.stats_defaults" href="../generic/stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.indicators.factory.IndicatorBase.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRUYwMDAwO30KCS5zdDF7ZmlsbDojRkY5MDAwO30KCS5zdDJ7ZmlsbDojRkZERjAwO30KCS5zdDN7ZmlsbDojMjgyQzM0O30KPC9zdHlsZT4KPGc+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNTUuMywzMDAuMSAyODMuMSwwIDIwOCwwIDExMC44LDAgMzUuOCwwIDEuMiw0NTAuMiA3Ni4zLDQ1MC4yIAkJCSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjIzMC40LDMwMC4xIDM1OC4xLDAgMjgzLjEsMCAxODUuOCwwIDExMC44LDAgNzYuMyw0NTAuMiAxNTEuMyw0NTAuMiAJCQkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIzMDUuNCwzMDAuMSA0MzMuMSwwIDM1OC4xLDAgMzMxLjYsNjIuMyAyNjAuOCwwIDE4NS44LDAgMTUxLjMsNDUwLjIgMjI2LjQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iNTEwLjgsMCA0MzMuMSwwIDMwNS40LDMwMC4xIDMzOC40LDAgMjYwLjgsMCAyMjYuNCw0NTAuMiAzMDQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="/>
vectorbt <span class="version">0.23.0</span></a>
</header>
<div class="search-container" id="docsearch"></div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.labels" href="index.html">vectorbt.labels</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.labels.generators.BOLB" href="#vectorbt.labels.generators.BOLB">BOLB</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.labels.generators.BOLB.apply_func" href="#vectorbt.labels.generators.BOLB.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.close" href="#vectorbt.labels.generators.BOLB.close">close</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.close_above" href="#vectorbt.labels.generators.BOLB.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.close_below" href="#vectorbt.labels.generators.BOLB.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.close_crossed_above" href="#vectorbt.labels.generators.BOLB.close_crossed_above">close_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.close_crossed_below" href="#vectorbt.labels.generators.BOLB.close_crossed_below">close_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.close_equal" href="#vectorbt.labels.generators.BOLB.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.close_stats" href="#vectorbt.labels.generators.BOLB.close_stats">close_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.custom_func" href="#vectorbt.labels.generators.BOLB.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.labels" href="#vectorbt.labels.generators.BOLB.labels">labels</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.labels_above" href="#vectorbt.labels.generators.BOLB.labels_above">labels_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.labels_below" href="#vectorbt.labels.generators.BOLB.labels_below">labels_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.labels_crossed_above" href="#vectorbt.labels.generators.BOLB.labels_crossed_above">labels_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.labels_crossed_below" href="#vectorbt.labels.generators.BOLB.labels_crossed_below">labels_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.labels_equal" href="#vectorbt.labels.generators.BOLB.labels_equal">labels_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.labels_stats" href="#vectorbt.labels.generators.BOLB.labels_stats">labels_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.neg_th_list" href="#vectorbt.labels.generators.BOLB.neg_th_list">neg_th_list</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.plot" href="#vectorbt.labels.generators.BOLB.plot">plot</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.pos_th_list" href="#vectorbt.labels.generators.BOLB.pos_th_list">pos_th_list</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.run" href="#vectorbt.labels.generators.BOLB.run">run</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.run_combs" href="#vectorbt.labels.generators.BOLB.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.labels.generators.BOLB.window_list" href="#vectorbt.labels.generators.BOLB.window_list">window_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.labels.generators.FIXLB" href="#vectorbt.labels.generators.FIXLB">FIXLB</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.labels.generators.FIXLB.apply_func" href="#vectorbt.labels.generators.FIXLB.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.close" href="#vectorbt.labels.generators.FIXLB.close">close</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.close_above" href="#vectorbt.labels.generators.FIXLB.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.close_below" href="#vectorbt.labels.generators.FIXLB.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.close_crossed_above" href="#vectorbt.labels.generators.FIXLB.close_crossed_above">close_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.close_crossed_below" href="#vectorbt.labels.generators.FIXLB.close_crossed_below">close_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.close_equal" href="#vectorbt.labels.generators.FIXLB.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.close_stats" href="#vectorbt.labels.generators.FIXLB.close_stats">close_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.custom_func" href="#vectorbt.labels.generators.FIXLB.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.labels" href="#vectorbt.labels.generators.FIXLB.labels">labels</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.labels_above" href="#vectorbt.labels.generators.FIXLB.labels_above">labels_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.labels_below" href="#vectorbt.labels.generators.FIXLB.labels_below">labels_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.labels_crossed_above" href="#vectorbt.labels.generators.FIXLB.labels_crossed_above">labels_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.labels_crossed_below" href="#vectorbt.labels.generators.FIXLB.labels_crossed_below">labels_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.labels_equal" href="#vectorbt.labels.generators.FIXLB.labels_equal">labels_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.labels_stats" href="#vectorbt.labels.generators.FIXLB.labels_stats">labels_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.n_list" href="#vectorbt.labels.generators.FIXLB.n_list">n_list</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.plot" href="#vectorbt.labels.generators.FIXLB.plot">plot</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.run" href="#vectorbt.labels.generators.FIXLB.run">run</a></code></li>
<li><code><a title="vectorbt.labels.generators.FIXLB.run_combs" href="#vectorbt.labels.generators.FIXLB.run_combs">run_combs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.labels.generators.FMAX" href="#vectorbt.labels.generators.FMAX">FMAX</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.labels.generators.FMAX.apply_func" href="#vectorbt.labels.generators.FMAX.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.close" href="#vectorbt.labels.generators.FMAX.close">close</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.close_above" href="#vectorbt.labels.generators.FMAX.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.close_below" href="#vectorbt.labels.generators.FMAX.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.close_crossed_above" href="#vectorbt.labels.generators.FMAX.close_crossed_above">close_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.close_crossed_below" href="#vectorbt.labels.generators.FMAX.close_crossed_below">close_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.close_equal" href="#vectorbt.labels.generators.FMAX.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.close_stats" href="#vectorbt.labels.generators.FMAX.close_stats">close_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.custom_func" href="#vectorbt.labels.generators.FMAX.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.fmax" href="#vectorbt.labels.generators.FMAX.fmax">fmax</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.fmax_above" href="#vectorbt.labels.generators.FMAX.fmax_above">fmax_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.fmax_below" href="#vectorbt.labels.generators.FMAX.fmax_below">fmax_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.fmax_crossed_above" href="#vectorbt.labels.generators.FMAX.fmax_crossed_above">fmax_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.fmax_crossed_below" href="#vectorbt.labels.generators.FMAX.fmax_crossed_below">fmax_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.fmax_equal" href="#vectorbt.labels.generators.FMAX.fmax_equal">fmax_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.fmax_stats" href="#vectorbt.labels.generators.FMAX.fmax_stats">fmax_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.run" href="#vectorbt.labels.generators.FMAX.run">run</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.run_combs" href="#vectorbt.labels.generators.FMAX.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMAX.window_list" href="#vectorbt.labels.generators.FMAX.window_list">window_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.labels.generators.FMEAN" href="#vectorbt.labels.generators.FMEAN">FMEAN</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.labels.generators.FMEAN.apply_func" href="#vectorbt.labels.generators.FMEAN.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.close" href="#vectorbt.labels.generators.FMEAN.close">close</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.close_above" href="#vectorbt.labels.generators.FMEAN.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.close_below" href="#vectorbt.labels.generators.FMEAN.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.close_crossed_above" href="#vectorbt.labels.generators.FMEAN.close_crossed_above">close_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.close_crossed_below" href="#vectorbt.labels.generators.FMEAN.close_crossed_below">close_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.close_equal" href="#vectorbt.labels.generators.FMEAN.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.close_stats" href="#vectorbt.labels.generators.FMEAN.close_stats">close_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.custom_func" href="#vectorbt.labels.generators.FMEAN.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.ewm_list" href="#vectorbt.labels.generators.FMEAN.ewm_list">ewm_list</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.fmean" href="#vectorbt.labels.generators.FMEAN.fmean">fmean</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.fmean_above" href="#vectorbt.labels.generators.FMEAN.fmean_above">fmean_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.fmean_below" href="#vectorbt.labels.generators.FMEAN.fmean_below">fmean_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.fmean_crossed_above" href="#vectorbt.labels.generators.FMEAN.fmean_crossed_above">fmean_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.fmean_crossed_below" href="#vectorbt.labels.generators.FMEAN.fmean_crossed_below">fmean_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.fmean_equal" href="#vectorbt.labels.generators.FMEAN.fmean_equal">fmean_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.fmean_stats" href="#vectorbt.labels.generators.FMEAN.fmean_stats">fmean_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.run" href="#vectorbt.labels.generators.FMEAN.run">run</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.run_combs" href="#vectorbt.labels.generators.FMEAN.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMEAN.window_list" href="#vectorbt.labels.generators.FMEAN.window_list">window_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.labels.generators.FMIN" href="#vectorbt.labels.generators.FMIN">FMIN</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.labels.generators.FMIN.apply_func" href="#vectorbt.labels.generators.FMIN.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.close" href="#vectorbt.labels.generators.FMIN.close">close</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.close_above" href="#vectorbt.labels.generators.FMIN.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.close_below" href="#vectorbt.labels.generators.FMIN.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.close_crossed_above" href="#vectorbt.labels.generators.FMIN.close_crossed_above">close_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.close_crossed_below" href="#vectorbt.labels.generators.FMIN.close_crossed_below">close_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.close_equal" href="#vectorbt.labels.generators.FMIN.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.close_stats" href="#vectorbt.labels.generators.FMIN.close_stats">close_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.custom_func" href="#vectorbt.labels.generators.FMIN.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.fmin" href="#vectorbt.labels.generators.FMIN.fmin">fmin</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.fmin_above" href="#vectorbt.labels.generators.FMIN.fmin_above">fmin_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.fmin_below" href="#vectorbt.labels.generators.FMIN.fmin_below">fmin_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.fmin_crossed_above" href="#vectorbt.labels.generators.FMIN.fmin_crossed_above">fmin_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.fmin_crossed_below" href="#vectorbt.labels.generators.FMIN.fmin_crossed_below">fmin_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.fmin_equal" href="#vectorbt.labels.generators.FMIN.fmin_equal">fmin_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.fmin_stats" href="#vectorbt.labels.generators.FMIN.fmin_stats">fmin_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.run" href="#vectorbt.labels.generators.FMIN.run">run</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.run_combs" href="#vectorbt.labels.generators.FMIN.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.labels.generators.FMIN.window_list" href="#vectorbt.labels.generators.FMIN.window_list">window_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.labels.generators.FSTD" href="#vectorbt.labels.generators.FSTD">FSTD</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.labels.generators.FSTD.apply_func" href="#vectorbt.labels.generators.FSTD.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.close" href="#vectorbt.labels.generators.FSTD.close">close</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.close_above" href="#vectorbt.labels.generators.FSTD.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.close_below" href="#vectorbt.labels.generators.FSTD.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.close_crossed_above" href="#vectorbt.labels.generators.FSTD.close_crossed_above">close_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.close_crossed_below" href="#vectorbt.labels.generators.FSTD.close_crossed_below">close_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.close_equal" href="#vectorbt.labels.generators.FSTD.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.close_stats" href="#vectorbt.labels.generators.FSTD.close_stats">close_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.custom_func" href="#vectorbt.labels.generators.FSTD.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.ewm_list" href="#vectorbt.labels.generators.FSTD.ewm_list">ewm_list</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.fstd" href="#vectorbt.labels.generators.FSTD.fstd">fstd</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.fstd_above" href="#vectorbt.labels.generators.FSTD.fstd_above">fstd_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.fstd_below" href="#vectorbt.labels.generators.FSTD.fstd_below">fstd_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.fstd_crossed_above" href="#vectorbt.labels.generators.FSTD.fstd_crossed_above">fstd_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.fstd_crossed_below" href="#vectorbt.labels.generators.FSTD.fstd_crossed_below">fstd_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.fstd_equal" href="#vectorbt.labels.generators.FSTD.fstd_equal">fstd_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.fstd_stats" href="#vectorbt.labels.generators.FSTD.fstd_stats">fstd_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.run" href="#vectorbt.labels.generators.FSTD.run">run</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.run_combs" href="#vectorbt.labels.generators.FSTD.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.labels.generators.FSTD.window_list" href="#vectorbt.labels.generators.FSTD.window_list">window_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.labels.generators.LEXLB" href="#vectorbt.labels.generators.LEXLB">LEXLB</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.labels.generators.LEXLB.apply_func" href="#vectorbt.labels.generators.LEXLB.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.close" href="#vectorbt.labels.generators.LEXLB.close">close</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.close_above" href="#vectorbt.labels.generators.LEXLB.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.close_below" href="#vectorbt.labels.generators.LEXLB.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.close_crossed_above" href="#vectorbt.labels.generators.LEXLB.close_crossed_above">close_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.close_crossed_below" href="#vectorbt.labels.generators.LEXLB.close_crossed_below">close_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.close_equal" href="#vectorbt.labels.generators.LEXLB.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.close_stats" href="#vectorbt.labels.generators.LEXLB.close_stats">close_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.custom_func" href="#vectorbt.labels.generators.LEXLB.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.labels" href="#vectorbt.labels.generators.LEXLB.labels">labels</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.labels_above" href="#vectorbt.labels.generators.LEXLB.labels_above">labels_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.labels_below" href="#vectorbt.labels.generators.LEXLB.labels_below">labels_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.labels_crossed_above" href="#vectorbt.labels.generators.LEXLB.labels_crossed_above">labels_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.labels_crossed_below" href="#vectorbt.labels.generators.LEXLB.labels_crossed_below">labels_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.labels_equal" href="#vectorbt.labels.generators.LEXLB.labels_equal">labels_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.labels_stats" href="#vectorbt.labels.generators.LEXLB.labels_stats">labels_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.neg_th_list" href="#vectorbt.labels.generators.LEXLB.neg_th_list">neg_th_list</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.plot" href="#vectorbt.labels.generators.LEXLB.plot">plot</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.pos_th_list" href="#vectorbt.labels.generators.LEXLB.pos_th_list">pos_th_list</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.run" href="#vectorbt.labels.generators.LEXLB.run">run</a></code></li>
<li><code><a title="vectorbt.labels.generators.LEXLB.run_combs" href="#vectorbt.labels.generators.LEXLB.run_combs">run_combs</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.labels.generators.MEANLB" href="#vectorbt.labels.generators.MEANLB">MEANLB</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.labels.generators.MEANLB.apply_func" href="#vectorbt.labels.generators.MEANLB.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.close" href="#vectorbt.labels.generators.MEANLB.close">close</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.close_above" href="#vectorbt.labels.generators.MEANLB.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.close_below" href="#vectorbt.labels.generators.MEANLB.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.close_crossed_above" href="#vectorbt.labels.generators.MEANLB.close_crossed_above">close_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.close_crossed_below" href="#vectorbt.labels.generators.MEANLB.close_crossed_below">close_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.close_equal" href="#vectorbt.labels.generators.MEANLB.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.close_stats" href="#vectorbt.labels.generators.MEANLB.close_stats">close_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.custom_func" href="#vectorbt.labels.generators.MEANLB.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.ewm_list" href="#vectorbt.labels.generators.MEANLB.ewm_list">ewm_list</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.labels" href="#vectorbt.labels.generators.MEANLB.labels">labels</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.labels_above" href="#vectorbt.labels.generators.MEANLB.labels_above">labels_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.labels_below" href="#vectorbt.labels.generators.MEANLB.labels_below">labels_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.labels_crossed_above" href="#vectorbt.labels.generators.MEANLB.labels_crossed_above">labels_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.labels_crossed_below" href="#vectorbt.labels.generators.MEANLB.labels_crossed_below">labels_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.labels_equal" href="#vectorbt.labels.generators.MEANLB.labels_equal">labels_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.labels_stats" href="#vectorbt.labels.generators.MEANLB.labels_stats">labels_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.plot" href="#vectorbt.labels.generators.MEANLB.plot">plot</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.run" href="#vectorbt.labels.generators.MEANLB.run">run</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.run_combs" href="#vectorbt.labels.generators.MEANLB.run_combs">run_combs</a></code></li>
<li><code><a title="vectorbt.labels.generators.MEANLB.window_list" href="#vectorbt.labels.generators.MEANLB.window_list">window_list</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.labels.generators.TRENDLB" href="#vectorbt.labels.generators.TRENDLB">TRENDLB</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.labels.generators.TRENDLB.apply_func" href="#vectorbt.labels.generators.TRENDLB.apply_func">apply_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.close" href="#vectorbt.labels.generators.TRENDLB.close">close</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.close_above" href="#vectorbt.labels.generators.TRENDLB.close_above">close_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.close_below" href="#vectorbt.labels.generators.TRENDLB.close_below">close_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.close_crossed_above" href="#vectorbt.labels.generators.TRENDLB.close_crossed_above">close_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.close_crossed_below" href="#vectorbt.labels.generators.TRENDLB.close_crossed_below">close_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.close_equal" href="#vectorbt.labels.generators.TRENDLB.close_equal">close_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.close_stats" href="#vectorbt.labels.generators.TRENDLB.close_stats">close_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.custom_func" href="#vectorbt.labels.generators.TRENDLB.custom_func">custom_func</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.labels" href="#vectorbt.labels.generators.TRENDLB.labels">labels</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.labels_above" href="#vectorbt.labels.generators.TRENDLB.labels_above">labels_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.labels_below" href="#vectorbt.labels.generators.TRENDLB.labels_below">labels_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.labels_crossed_above" href="#vectorbt.labels.generators.TRENDLB.labels_crossed_above">labels_crossed_above</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.labels_crossed_below" href="#vectorbt.labels.generators.TRENDLB.labels_crossed_below">labels_crossed_below</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.labels_equal" href="#vectorbt.labels.generators.TRENDLB.labels_equal">labels_equal</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.labels_stats" href="#vectorbt.labels.generators.TRENDLB.labels_stats">labels_stats</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.mode_list" href="#vectorbt.labels.generators.TRENDLB.mode_list">mode_list</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.neg_th_list" href="#vectorbt.labels.generators.TRENDLB.neg_th_list">neg_th_list</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.plot" href="#vectorbt.labels.generators.TRENDLB.plot">plot</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.pos_th_list" href="#vectorbt.labels.generators.TRENDLB.pos_th_list">pos_th_list</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.run" href="#vectorbt.labels.generators.TRENDLB.run">run</a></code></li>
<li><code><a title="vectorbt.labels.generators.TRENDLB.run_combs" href="#vectorbt.labels.generators.TRENDLB.run_combs">run_combs</a></code></li>
</ul>
</li>
</ul>
</li>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script src="https://cdn.jsdelivr.net/npm/@docsearch/js@alpha"></script>
<script type="text/javascript">
docsearch({
container: '#docsearch',
appId: 'KNQTBBHKVB',
indexName: 'vectorbt',
apiKey: 'a945e6e8f1cb2fdc30e936936aa3307b',
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous"></script>
<script>
$(document).ready(function() {
$("article dt[id], #section-intro [id]").each(function() {
const thisId = $(this).attr('id');
$(this).wrap('<a class="headerlink" href="#' + thisId + '">');
});
});
</script>
</body>
</html>