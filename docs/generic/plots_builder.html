<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>vectorbt.generic.plots_builder API documentation</title>
<meta name="description" content="Mixin for building plots out of subplots." />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@alpha" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#e82;--docsearch-primary-color:#e82;--docsearch-searchbox-focus-background:#ebedf0}body{line-height:1.5em}.version{font-weight:normal;font-style:italic;font-size:.75em;color:#8b949e}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}h2[id^="header-"]{margin-top:2em}.ident{color:#900}.headerlink{color:inherit}.headerlink:hover{color:inherit}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important;word-break:normal}.hljs-keyword{color:#ff7b72 !important}.hljs-comment{color:#8b949e !important}.hljs-meta{color:#8b949e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 1.5em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:1em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-weight:400;font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}.DocSearch-Button{width:100%;margin:0px;height:38px}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{min-width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}.hljs{margin-left:-15px;margin-right:-15px}.source pre code{margin-left:0px;margin-right:0px}dd{margin:0 0 1em 3em}dd dd{margin-left:2em}.flex{display:flex !important}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4QLCS0J048"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4QLCS0J048');
</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:100px;max-height:100px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.generic.plots_builder</code></h1>
</header>
<section id="section-intro">
<p>Mixin for building plots out of subplots.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;Mixin for building plots out of subplots.&#34;&#34;&#34;

import inspect
import string
import warnings
from collections import Counter

from vectorbt import _typing as tp
from vectorbt.base.array_wrapper import Wrapping
from vectorbt.utils import checks
from vectorbt.utils.attr_ import get_dict_attr
from vectorbt.utils.config import Config, merge_dicts, get_func_arg_names
from vectorbt.utils.figure import make_subplots, get_domain
from vectorbt.utils.tags import match_tags
from vectorbt.utils.template import deep_substitute


class MetaPlotsBuilderMixin(type):
    &#34;&#34;&#34;Meta class that exposes a read-only class property `PlotsBuilderMixin.subplots`.&#34;&#34;&#34;

    @property
    def subplots(cls) -&gt; Config:
        &#34;&#34;&#34;Subplots supported by `PlotsBuilderMixin.plots`.&#34;&#34;&#34;
        return cls._subplots


class PlotsBuilderMixin(metaclass=MetaPlotsBuilderMixin):
    &#34;&#34;&#34;Mixin that implements `PlotsBuilderMixin.plots`.

    Required to be a subclass of `vectorbt.base.array_wrapper.Wrapping`.&#34;&#34;&#34;

    def __init__(self):
        checks.assert_instance_of(self, Wrapping)

        # Copy writeable attrs
        self._subplots = self.__class__._subplots.copy()

    @property
    def writeable_attrs(self) -&gt; tp.Set[str]:
        &#34;&#34;&#34;Set of writeable attributes that will be saved/copied along with the config.&#34;&#34;&#34;
        return {&#39;_subplots&#39;}

    @property
    def plots_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `PlotsBuilderMixin.plots`.

        See `plots_builder` in `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        plots_builder_cfg = settings[&#39;plots_builder&#39;]

        return merge_dicts(
            plots_builder_cfg,
            dict(settings=dict(freq=self.wrapper.freq))
        )

    _subplots: tp.ClassVar[Config] = Config(
        dict(),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def subplots(self) -&gt; Config:
        &#34;&#34;&#34;Subplots supported by `${cls_name}`.

        ```json
        ${subplots}
        ```

        Returns `${cls_name}._subplots`, which gets (deep) copied upon creation of each instance.
        Thus, changing this config won&#39;t affect the class.

        To change subplots, you can either change the config in-place, override this property,
        or overwrite the instance variable `${cls_name}._subplots`.&#34;&#34;&#34;
        return self._subplots

    def plots(self,
              subplots: tp.Optional[tp.MaybeIterable[tp.Union[str, tp.Tuple[str, tp.Kwargs]]]] = None,
              tags: tp.Optional[tp.MaybeIterable[str]] = None,
              column: tp.Optional[tp.Label] = None,
              group_by: tp.GroupByLike = None,
              silence_warnings: tp.Optional[bool] = None,
              template_mapping: tp.Optional[tp.Mapping] = None,
              settings: tp.KwargsLike = None,
              filters: tp.KwargsLike = None,
              subplot_settings: tp.KwargsLike = None,
              show_titles: bool = None,
              hide_id_labels: bool = None,
              group_id_labels: bool = None,
              make_subplots_kwargs: tp.KwargsLike = None,
              **layout_kwargs) -&gt; tp.Optional[tp.BaseFigure]:
        &#34;&#34;&#34;Plot various parts of this object.

        Args:
            subplots (str, tuple, iterable, or dict): Subplots to plot.

                Each element can be either:

                * a subplot name (see keys in `PlotsBuilderMixin.subplots`)
                * a tuple of a subplot name and a settings dict as in `PlotsBuilderMixin.subplots`.

                The settings dict can contain the following keys:

                * `title`: Title of the subplot. Defaults to the name.
                * `plot_func` (required): Plotting function for custom subplots.
                    Should write the supplied figure `fig` in-place and can return anything (it won&#39;t be used).
                * `xaxis_kwargs`: Layout keyword arguments for the x-axis. Defaults to `dict(title=&#39;Index&#39;)`.
                * `yaxis_kwargs`: Layout keyword arguments for the y-axis. Defaults to empty dict.
                * `tags`, `check_{filter}`, `inv_check_{filter}`, `resolve_plot_func`, `pass_{arg}`,
                    `resolve_path_{arg}`, `resolve_{arg}` and `template_mapping`:
                    The same as in `vectorbt.generic.stats_builder.StatsBuilderMixin` for `calc_func`.
                * Any other keyword argument that overrides the settings or is passed directly to `plot_func`.

                If `resolve_plot_func` is True, the plotting function may &#34;request&#34; any of the
                following arguments by accepting them or if `pass_{arg}` was found in the settings dict:

                * Each of `vectorbt.utils.attr_.AttrResolver.self_aliases`: original object
                    (ungrouped, with no column selected)
                * `group_by`: won&#39;t be passed if it was used in resolving the first attribute of `plot_func`
                    specified as a path, use `pass_group_by=True` to pass anyway
                * `column`
                * `subplot_name`
                * `trace_names`: list with the subplot name, can&#39;t be used in templates
                * `add_trace_kwargs`: dict with subplot row and column index
                * `xref`
                * `yref`
                * `xaxis`
                * `yaxis`
                * `x_domain`
                * `y_domain`
                * `fig`
                * `silence_warnings`
                * Any argument from `settings`
                * Any attribute of this object if it meant to be resolved
                    (see `vectorbt.utils.attr_.AttrResolver.resolve_attr`)

                !!! note
                    Layout-related resolution arguments such as `add_trace_kwargs` are unavailable
                    before filtering and thus cannot be used in any templates but can still be overridden.

                Pass `subplots=&#39;all&#39;` to plot all supported subplots.
            tags (str or iterable): See `tags` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
            column (str): See `column` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
            group_by (any): See `group_by` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
            silence_warnings (bool): See `silence_warnings` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
            template_mapping (mapping): See `template_mapping` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.

                Applied on `settings`, `make_subplots_kwargs`, and `layout_kwargs`, and then on each subplot settings.
            filters (dict): See `filters` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
            settings (dict): See `settings` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
            subplot_settings (dict): See `metric_settings` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
            show_titles (bool): Whether to show the title of each subplot.
            hide_id_labels (bool): Whether to hide identical legend labels.

                Two labels are identical if their name, marker style and line style match.
            group_id_labels (bool): Whether to group identical legend labels.
            make_subplots_kwargs (dict): Keyword arguments passed to `plotly.subplots.make_subplots`.
            **layout_kwargs: Keyword arguments used to update the layout of the figure.

        !!! note
            `PlotsBuilderMixin` and `vectorbt.generic.stats_builder.StatsBuilderMixin` are very similar.
            Some artifacts follow the same concept, just named differently:

            * `plots_defaults` vs `stats_defaults`
            * `subplots` vs `metrics`
            * `subplot_settings` vs `metric_settings`

            See further notes under `vectorbt.generic.stats_builder.StatsBuilderMixin`.

        ## Example

        See `vectorbt.portfolio.base` for examples.
        &#34;&#34;&#34;
        from vectorbt._settings import settings as _settings
        plotting_cfg = _settings[&#39;plotting&#39;]

        # Resolve defaults
        if silence_warnings is None:
            silence_warnings = self.plots_defaults[&#39;silence_warnings&#39;]
        if show_titles is None:
            show_titles = self.plots_defaults[&#39;show_titles&#39;]
        if hide_id_labels is None:
            hide_id_labels = self.plots_defaults[&#39;hide_id_labels&#39;]
        if group_id_labels is None:
            group_id_labels = self.plots_defaults[&#39;group_id_labels&#39;]
        template_mapping = merge_dicts(self.plots_defaults[&#39;template_mapping&#39;], template_mapping)
        filters = merge_dicts(self.plots_defaults[&#39;filters&#39;], filters)
        settings = merge_dicts(self.plots_defaults[&#39;settings&#39;], settings)
        subplot_settings = merge_dicts(self.plots_defaults[&#39;subplot_settings&#39;], subplot_settings)
        make_subplots_kwargs = merge_dicts(self.plots_defaults[&#39;make_subplots_kwargs&#39;], make_subplots_kwargs)
        layout_kwargs = merge_dicts(self.plots_defaults[&#39;layout_kwargs&#39;], layout_kwargs)

        # Replace templates globally (not used at subplot level)
        if len(template_mapping) &gt; 0:
            sub_settings = deep_substitute(settings, mapping=template_mapping)
            sub_make_subplots_kwargs = deep_substitute(make_subplots_kwargs, mapping=template_mapping)
            sub_layout_kwargs = deep_substitute(layout_kwargs, mapping=template_mapping)
        else:
            sub_settings = settings
            sub_make_subplots_kwargs = make_subplots_kwargs
            sub_layout_kwargs = layout_kwargs

        # Resolve self
        reself = self.resolve_self(
            cond_kwargs=sub_settings,
            impacts_caching=False,
            silence_warnings=silence_warnings
        )

        # Prepare subplots
        if subplots is None:
            subplots = reself.plots_defaults[&#39;subplots&#39;]
        if subplots == &#39;all&#39;:
            subplots = reself.subplots
        if isinstance(subplots, dict):
            subplots = list(subplots.items())
        if isinstance(subplots, (str, tuple)):
            subplots = [subplots]

        # Prepare tags
        if tags is None:
            tags = reself.plots_defaults[&#39;tags&#39;]
        if isinstance(tags, str) and tags == &#39;all&#39;:
            tags = None
        if isinstance(tags, (str, tuple)):
            tags = [tags]

        # Bring to the same shape
        new_subplots = []
        for i, subplot in enumerate(subplots):
            if isinstance(subplot, str):
                subplot = (subplot, reself.subplots[subplot])
            if not isinstance(subplot, tuple):
                raise TypeError(f&#34;Subplot at index {i} must be either a string or a tuple&#34;)
            new_subplots.append(subplot)
        subplots = new_subplots

        # Handle duplicate names
        subplot_counts = Counter(list(map(lambda x: x[0], subplots)))
        subplot_i = {k: -1 for k in subplot_counts.keys()}
        subplots_dct = {}
        for i, (subplot_name, _subplot_settings) in enumerate(subplots):
            if subplot_counts[subplot_name] &gt; 1:
                subplot_i[subplot_name] += 1
                subplot_name = subplot_name + &#39;_&#39; + str(subplot_i[subplot_name])
            subplots_dct[subplot_name] = _subplot_settings

        # Check subplot_settings
        missed_keys = set(subplot_settings.keys()).difference(set(subplots_dct.keys()))
        if len(missed_keys) &gt; 0:
            raise ValueError(f&#34;Keys {missed_keys} in subplot_settings could not be matched with any subplot&#34;)

        # Merge settings
        opt_arg_names_dct = {}
        custom_arg_names_dct = {}
        resolved_self_dct = {}
        mapping_dct = {}
        for subplot_name, _subplot_settings in list(subplots_dct.items()):
            opt_settings = merge_dicts(
                {name: reself for name in reself.self_aliases},
                dict(
                    column=column,
                    group_by=group_by,
                    subplot_name=subplot_name,
                    trace_names=[subplot_name],
                    silence_warnings=silence_warnings
                ),
                settings
            )
            _subplot_settings = _subplot_settings.copy()
            passed_subplot_settings = subplot_settings.get(subplot_name, {})
            merged_settings = merge_dicts(
                opt_settings,
                _subplot_settings,
                passed_subplot_settings
            )
            subplot_template_mapping = merged_settings.pop(&#39;template_mapping&#39;, {})
            template_mapping_merged = merge_dicts(template_mapping, subplot_template_mapping)
            template_mapping_merged = deep_substitute(template_mapping_merged, mapping=merged_settings)
            mapping = merge_dicts(template_mapping_merged, merged_settings)
            # safe because we will use deep_substitute again once layout params are known
            merged_settings = deep_substitute(merged_settings, mapping=mapping, safe=True)

            # Filter by tag
            if tags is not None:
                in_tags = merged_settings.get(&#39;tags&#39;, None)
                if in_tags is None or not match_tags(tags, in_tags):
                    subplots_dct.pop(subplot_name, None)
                    continue

            custom_arg_names = set(_subplot_settings.keys()).union(set(passed_subplot_settings.keys()))
            opt_arg_names = set(opt_settings.keys())
            custom_reself = reself.resolve_self(
                cond_kwargs=merged_settings,
                custom_arg_names=custom_arg_names,
                impacts_caching=True,
                silence_warnings=merged_settings[&#39;silence_warnings&#39;]
            )

            subplots_dct[subplot_name] = merged_settings
            custom_arg_names_dct[subplot_name] = custom_arg_names
            opt_arg_names_dct[subplot_name] = opt_arg_names
            resolved_self_dct[subplot_name] = custom_reself
            mapping_dct[subplot_name] = mapping

        # Filter subplots
        for subplot_name, _subplot_settings in list(subplots_dct.items()):
            custom_reself = resolved_self_dct[subplot_name]
            mapping = mapping_dct[subplot_name]
            _silence_warnings = _subplot_settings.get(&#39;silence_warnings&#39;)

            subplot_filters = set()
            for k in _subplot_settings.keys():
                filter_name = None
                if k.startswith(&#39;check_&#39;):
                    filter_name = k[len(&#39;check_&#39;):]
                elif k.startswith(&#39;inv_check_&#39;):
                    filter_name = k[len(&#39;inv_check_&#39;):]
                if filter_name is not None:
                    if filter_name not in filters:
                        raise ValueError(f&#34;Metric &#39;{subplot_name}&#39; requires filter &#39;{filter_name}&#39;&#34;)
                    subplot_filters.add(filter_name)

            for filter_name in subplot_filters:
                filter_settings = filters[filter_name]
                _filter_settings = deep_substitute(filter_settings, mapping=mapping)
                filter_func = _filter_settings[&#39;filter_func&#39;]
                warning_message = _filter_settings.get(&#39;warning_message&#39;, None)
                inv_warning_message = _filter_settings.get(&#39;inv_warning_message&#39;, None)
                to_check = _subplot_settings.get(&#39;check_&#39; + filter_name, False)
                inv_to_check = _subplot_settings.get(&#39;inv_check_&#39; + filter_name, False)

                if to_check or inv_to_check:
                    whether_true = filter_func(custom_reself, _subplot_settings)
                    to_remove = (to_check and not whether_true) or (inv_to_check and whether_true)
                    if to_remove:
                        if to_check and warning_message is not None and not _silence_warnings:
                            warnings.warn(warning_message)
                        if inv_to_check and inv_warning_message is not None and not _silence_warnings:
                            warnings.warn(inv_warning_message)

                        subplots_dct.pop(subplot_name, None)
                        custom_arg_names_dct.pop(subplot_name, None)
                        opt_arg_names_dct.pop(subplot_name, None)
                        resolved_self_dct.pop(subplot_name, None)
                        mapping_dct.pop(subplot_name, None)
                        break

        # Any subplots left?
        if len(subplots_dct) == 0:
            if not silence_warnings:
                warnings.warn(&#34;No subplots to plot&#34;, stacklevel=2)
            return None

        # Set up figure
        rows = sub_make_subplots_kwargs.pop(&#39;rows&#39;, len(subplots_dct))
        cols = sub_make_subplots_kwargs.pop(&#39;cols&#39;, 1)
        specs = sub_make_subplots_kwargs.pop(&#39;specs&#39;, [[{} for _ in range(cols)] for _ in range(rows)])
        row_col_tuples = []
        for row, row_spec in enumerate(specs):
            for col, col_spec in enumerate(row_spec):
                if col_spec is not None:
                    row_col_tuples.append((row + 1, col + 1))
        shared_xaxes = sub_make_subplots_kwargs.pop(&#39;shared_xaxes&#39;, True)
        shared_yaxes = sub_make_subplots_kwargs.pop(&#39;shared_yaxes&#39;, False)
        default_height = plotting_cfg[&#39;layout&#39;][&#39;height&#39;]
        default_width = plotting_cfg[&#39;layout&#39;][&#39;width&#39;] + 50
        min_space = 10  # space between subplots with no axis sharing
        max_title_spacing = 30
        max_xaxis_spacing = 50
        max_yaxis_spacing = 100
        legend_height = 50
        if show_titles:
            title_spacing = max_title_spacing
        else:
            title_spacing = 0
        if not shared_xaxes and rows &gt; 1:
            xaxis_spacing = max_xaxis_spacing
        else:
            xaxis_spacing = 0
        if not shared_yaxes and cols &gt; 1:
            yaxis_spacing = max_yaxis_spacing
        else:
            yaxis_spacing = 0
        if &#39;height&#39; in sub_layout_kwargs:
            height = sub_layout_kwargs.pop(&#39;height&#39;)
        else:
            height = default_height + title_spacing
            if rows &gt; 1:
                height *= rows
                height += min_space * rows - min_space
                height += legend_height - legend_height * rows
                if shared_xaxes:
                    height += max_xaxis_spacing - max_xaxis_spacing * rows
        if &#39;width&#39; in sub_layout_kwargs:
            width = sub_layout_kwargs.pop(&#39;width&#39;)
        else:
            width = default_width
            if cols &gt; 1:
                width *= cols
                width += min_space * cols - min_space
                if shared_yaxes:
                    width += max_yaxis_spacing - max_yaxis_spacing * cols
        if height is not None:
            if &#39;vertical_spacing&#39; in sub_make_subplots_kwargs:
                vertical_spacing = sub_make_subplots_kwargs.pop(&#39;vertical_spacing&#39;)
            else:
                vertical_spacing = min_space + title_spacing + xaxis_spacing
            if vertical_spacing is not None and vertical_spacing &gt; 1:
                vertical_spacing /= height
            legend_y = 1 + (min_space + title_spacing) / height
        else:
            vertical_spacing = sub_make_subplots_kwargs.pop(&#39;vertical_spacing&#39;, None)
            legend_y = 1.02
        if width is not None:
            if &#39;horizontal_spacing&#39; in sub_make_subplots_kwargs:
                horizontal_spacing = sub_make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;)
            else:
                horizontal_spacing = min_space + yaxis_spacing
            if horizontal_spacing is not None and horizontal_spacing &gt; 1:
                horizontal_spacing /= width
        else:
            horizontal_spacing = sub_make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;, None)
        if show_titles:
            _subplot_titles = []
            for i in range(len(subplots_dct)):
                _subplot_titles.append(&#39;$title_&#39; + str(i))
        else:
            _subplot_titles = None
        fig = make_subplots(
            rows=rows,
            cols=cols,
            specs=specs,
            shared_xaxes=shared_xaxes,
            shared_yaxes=shared_yaxes,
            subplot_titles=_subplot_titles,
            vertical_spacing=vertical_spacing,
            horizontal_spacing=horizontal_spacing,
            **sub_make_subplots_kwargs
        )
        sub_layout_kwargs = merge_dicts(dict(
            showlegend=True,
            width=width,
            height=height,
            legend=dict(
                orientation=&#34;h&#34;,
                yanchor=&#34;bottom&#34;,
                y=legend_y,
                xanchor=&#34;right&#34;,
                x=1,
                traceorder=&#39;normal&#39;
            )
        ), sub_layout_kwargs)
        fig.update_layout(**sub_layout_kwargs)  # final destination for sub_layout_kwargs

        # Plot subplots
        arg_cache_dct = {}
        for i, (subplot_name, _subplot_settings) in enumerate(subplots_dct.items()):
            try:
                final_kwargs = _subplot_settings.copy()
                opt_arg_names = opt_arg_names_dct[subplot_name]
                custom_arg_names = custom_arg_names_dct[subplot_name]
                custom_reself = resolved_self_dct[subplot_name]
                mapping = mapping_dct[subplot_name]

                # Compute figure artifacts
                row, col = row_col_tuples[i]
                xref = &#39;x&#39; if i == 0 else &#39;x&#39; + str(i + 1)
                yref = &#39;y&#39; if i == 0 else &#39;y&#39; + str(i + 1)
                xaxis = &#39;xaxis&#39; + xref[1:]
                yaxis = &#39;yaxis&#39; + yref[1:]
                x_domain = get_domain(xref, fig)
                y_domain = get_domain(yref, fig)
                subplot_layout_kwargs = dict(
                    add_trace_kwargs=dict(row=row, col=col),
                    xref=xref,
                    yref=yref,
                    xaxis=xaxis,
                    yaxis=yaxis,
                    x_domain=x_domain,
                    y_domain=y_domain,
                    fig=fig,
                    pass_fig=True  # force passing fig
                )
                for k in subplot_layout_kwargs:
                    opt_arg_names.add(k)
                    if k in final_kwargs:
                        custom_arg_names.add(k)
                final_kwargs = merge_dicts(subplot_layout_kwargs, final_kwargs)
                mapping = merge_dicts(subplot_layout_kwargs, mapping)
                final_kwargs = deep_substitute(final_kwargs, mapping=mapping)

                # Clean up keys
                for k, v in list(final_kwargs.items()):
                    if k.startswith(&#39;check_&#39;) or k.startswith(&#39;inv_check_&#39;) or k in (&#39;tags&#39;,):
                        final_kwargs.pop(k, None)

                # Get subplot-specific values
                _column = final_kwargs.get(&#39;column&#39;)
                _group_by = final_kwargs.get(&#39;group_by&#39;)
                _silence_warnings = final_kwargs.get(&#39;silence_warnings&#39;)
                title = final_kwargs.pop(&#39;title&#39;, subplot_name)
                plot_func = final_kwargs.pop(&#39;plot_func&#39;, None)
                xaxis_kwargs = final_kwargs.pop(&#39;xaxis_kwargs&#39;, None)
                yaxis_kwargs = final_kwargs.pop(&#39;yaxis_kwargs&#39;, None)
                resolve_plot_func = final_kwargs.pop(&#39;resolve_plot_func&#39;, True)
                use_caching = final_kwargs.pop(&#39;use_caching&#39;, True)

                if plot_func is not None:
                    # Resolve plot_func
                    if resolve_plot_func:
                        if not callable(plot_func):
                            passed_kwargs_out = {}

                            def _getattr_func(obj: tp.Any,
                                              attr: str,
                                              args: tp.ArgsLike = None,
                                              kwargs: tp.KwargsLike = None,
                                              call_attr: bool = True,
                                              _final_kwargs: tp.Kwargs = final_kwargs,
                                              _opt_arg_names: tp.Set[str] = opt_arg_names,
                                              _custom_arg_names: tp.Set[str] = custom_arg_names,
                                              _arg_cache_dct: tp.Kwargs = arg_cache_dct) -&gt; tp.Any:
                                if attr in final_kwargs:
                                    return final_kwargs[attr]
                                if args is None:
                                    args = ()
                                if kwargs is None:
                                    kwargs = {}
                                if obj is custom_reself and _final_kwargs.pop(&#39;resolve_path_&#39; + attr, True):
                                    if call_attr:
                                        return custom_reself.resolve_attr(
                                            attr,
                                            args=args,
                                            cond_kwargs={k: v for k, v in _final_kwargs.items() if k in _opt_arg_names},
                                            kwargs=kwargs,
                                            custom_arg_names=_custom_arg_names,
                                            cache_dct=_arg_cache_dct,
                                            use_caching=use_caching,
                                            passed_kwargs_out=passed_kwargs_out
                                        )
                                    return getattr(obj, attr)
                                out = getattr(obj, attr)
                                if callable(out) and call_attr:
                                    return out(*args, **kwargs)
                                return out

                            plot_func = custom_reself.deep_getattr(
                                plot_func,
                                getattr_func=_getattr_func,
                                call_last_attr=False
                            )

                            if &#39;group_by&#39; in passed_kwargs_out:
                                if &#39;pass_group_by&#39; not in final_kwargs:
                                    final_kwargs.pop(&#39;group_by&#39;, None)
                        if not callable(plot_func):
                            raise TypeError(&#34;plot_func must be callable&#34;)

                        # Resolve arguments
                        func_arg_names = get_func_arg_names(plot_func)
                        for k in func_arg_names:
                            if k not in final_kwargs:
                                if final_kwargs.pop(&#39;resolve_&#39; + k, False):
                                    try:
                                        arg_out = custom_reself.resolve_attr(
                                            k,
                                            cond_kwargs=final_kwargs,
                                            custom_arg_names=custom_arg_names,
                                            cache_dct=arg_cache_dct,
                                            use_caching=use_caching
                                        )
                                    except AttributeError:
                                        continue
                                    final_kwargs[k] = arg_out
                        for k in list(final_kwargs.keys()):
                            if k in opt_arg_names:
                                if &#39;pass_&#39; + k in final_kwargs:
                                    if not final_kwargs.get(&#39;pass_&#39; + k):  # first priority
                                        final_kwargs.pop(k, None)
                                elif k not in func_arg_names:  # second priority
                                    final_kwargs.pop(k, None)
                        for k in list(final_kwargs.keys()):
                            if k.startswith(&#39;pass_&#39;) or k.startswith(&#39;resolve_&#39;):
                                final_kwargs.pop(k, None)  # cleanup

                        # Call plot_func
                        plot_func(**final_kwargs)
                    else:
                        # Do not resolve plot_func
                        plot_func(custom_reself, _subplot_settings)

                # Update global layout
                for annotation in fig.layout.annotations:
                    if &#39;text&#39; in annotation and annotation[&#39;text&#39;] == &#39;$title_&#39; + str(i):
                        annotation[&#39;text&#39;] = title
                subplot_layout = dict()
                subplot_layout[xaxis] = merge_dicts(dict(title=&#39;Index&#39;), xaxis_kwargs)
                subplot_layout[yaxis] = merge_dicts(dict(), yaxis_kwargs)
                fig.update_layout(**subplot_layout)
            except Exception as e:
                warnings.warn(f&#34;Subplot &#39;{subplot_name}&#39; raised an exception&#34;, stacklevel=2)
                raise e

        # Remove duplicate legend labels
        found_ids = dict()
        unique_idx = 0
        for trace in fig.data:
            if &#39;name&#39; in trace:
                name = trace[&#39;name&#39;]
            else:
                name = None
            if &#39;marker&#39; in trace:
                marker = trace[&#39;marker&#39;]
            else:
                marker = {}
            if &#39;symbol&#39; in marker:
                marker_symbol = marker[&#39;symbol&#39;]
            else:
                marker_symbol = None
            if &#39;color&#39; in marker:
                marker_color = marker[&#39;color&#39;]
            else:
                marker_color = None
            if &#39;line&#39; in trace:
                line = trace[&#39;line&#39;]
            else:
                line = {}
            if &#39;dash&#39; in line:
                line_dash = line[&#39;dash&#39;]
            else:
                line_dash = None
            if &#39;color&#39; in line:
                line_color = line[&#39;color&#39;]
            else:
                line_color = None

            id = (name, marker_symbol, marker_color, line_dash, line_color)
            if id in found_ids:
                if hide_id_labels:
                    trace[&#39;showlegend&#39;] = False
                if group_id_labels:
                    trace[&#39;legendgroup&#39;] = found_ids[id]
            else:
                if group_id_labels:
                    trace[&#39;legendgroup&#39;] = unique_idx
                found_ids[id] = unique_idx
                unique_idx += 1

        # Remove all except the last title if sharing the same axis
        if shared_xaxes:
            i = 0
            for row in range(rows):
                for col in range(cols):
                    if specs[row][col] is not None:
                        xaxis = &#39;xaxis&#39; if i == 0 else &#39;xaxis&#39; + str(i + 1)
                        if row &lt; rows - 1:
                            fig.layout[xaxis][&#39;title&#39;] = None
                        i += 1
        if shared_yaxes:
            i = 0
            for row in range(rows):
                for col in range(cols):
                    if specs[row][col] is not None:
                        yaxis = &#39;yaxis&#39; if i == 0 else &#39;yaxis&#39; + str(i + 1)
                        if col &gt; 0:
                            fig.layout[yaxis][&#39;title&#39;] = None
                        i += 1

        # Return the figure
        return fig

    # ############# Docs ############# #

    @classmethod
    def build_subplots_doc(cls, source_cls: tp.Optional[type] = None) -&gt; str:
        &#34;&#34;&#34;Build subplots documentation.&#34;&#34;&#34;
        if source_cls is None:
            source_cls = PlotsBuilderMixin
        return string.Template(
            inspect.cleandoc(get_dict_attr(source_cls, &#39;subplots&#39;).__doc__)
        ).substitute(
            {&#39;subplots&#39;: cls.subplots.to_doc(), &#39;cls_name&#39;: cls.__name__}
        )

    @classmethod
    def override_subplots_doc(cls, __pdoc__: dict, source_cls: tp.Optional[type] = None) -&gt; None:
        &#34;&#34;&#34;Call this method on each subclass that overrides `subplots`.&#34;&#34;&#34;
        __pdoc__[cls.__name__ + &#39;.subplots&#39;] = cls.build_subplots_doc(source_cls=source_cls)


__pdoc__ = dict()
PlotsBuilderMixin.override_subplots_doc(__pdoc__)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.generic.plots_builder.MetaPlotsBuilderMixin"><code class="flex name class">
<span>class <span class="ident parent-name">MetaPlotsBuilderMixin</span></span>
(<span class="params">*args, **kwargs</span>)
</code></dt>
<dd>
<div class="desc"><p>Meta class that exposes a read-only class property <code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.subplots" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin.subplots">PlotsBuilderMixin.subplots</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaPlotsBuilderMixin(type):
    &#34;&#34;&#34;Meta class that exposes a read-only class property `PlotsBuilderMixin.subplots`.&#34;&#34;&#34;

    @property
    def subplots(cls) -&gt; Config:
        &#34;&#34;&#34;Subplots supported by `PlotsBuilderMixin.plots`.&#34;&#34;&#34;
        return cls._subplots</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.data.base.MetaData" href="../data/base.html#vectorbt.data.base.MetaData">MetaData</a></li>
<li><a title="vectorbt.generic.accessors.MetaGenericAccessor" href="accessors.html#vectorbt.generic.accessors.MetaGenericAccessor">MetaGenericAccessor</a></li>
<li><a title="vectorbt.indicators.factory.MetaIndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.MetaIndicatorBase">MetaIndicatorBase</a></li>
<li><a title="vectorbt.portfolio.base.MetaPortfolio" href="../portfolio/base.html#vectorbt.portfolio.base.MetaPortfolio">MetaPortfolio</a></li>
<li><a title="vectorbt.records.base.MetaRecords" href="../records/base.html#vectorbt.records.base.MetaRecords">MetaRecords</a></li>
<li><a title="vectorbt.records.mapped_array.MetaMappedArray" href="../records/mapped_array.html#vectorbt.records.mapped_array.MetaMappedArray">MetaMappedArray</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.generic.plots_builder.MetaPlotsBuilderMixin.subplots"><code class="name">var <span class="ident child-name">subplots</span></code></dt>
<dd>
<div class="desc"><p>Subplots supported by <code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">PlotsBuilderMixin.plots()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def subplots(cls) -&gt; Config:
    &#34;&#34;&#34;Subplots supported by `PlotsBuilderMixin.plots`.&#34;&#34;&#34;
    return cls._subplots</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.generic.plots_builder.PlotsBuilderMixin"><code class="flex name class">
<span>class <span class="ident parent-name">PlotsBuilderMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixin that implements <code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">PlotsBuilderMixin.plots()</a></code>.</p>
<p>Required to be a subclass of <code><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PlotsBuilderMixin(metaclass=MetaPlotsBuilderMixin):
    &#34;&#34;&#34;Mixin that implements `PlotsBuilderMixin.plots`.

    Required to be a subclass of `vectorbt.base.array_wrapper.Wrapping`.&#34;&#34;&#34;

    def __init__(self):
        checks.assert_instance_of(self, Wrapping)

        # Copy writeable attrs
        self._subplots = self.__class__._subplots.copy()

    @property
    def writeable_attrs(self) -&gt; tp.Set[str]:
        &#34;&#34;&#34;Set of writeable attributes that will be saved/copied along with the config.&#34;&#34;&#34;
        return {&#39;_subplots&#39;}

    @property
    def plots_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `PlotsBuilderMixin.plots`.

        See `plots_builder` in `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        plots_builder_cfg = settings[&#39;plots_builder&#39;]

        return merge_dicts(
            plots_builder_cfg,
            dict(settings=dict(freq=self.wrapper.freq))
        )

    _subplots: tp.ClassVar[Config] = Config(
        dict(),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def subplots(self) -&gt; Config:
        &#34;&#34;&#34;Subplots supported by `${cls_name}`.

        ```json
        ${subplots}
        ```

        Returns `${cls_name}._subplots`, which gets (deep) copied upon creation of each instance.
        Thus, changing this config won&#39;t affect the class.

        To change subplots, you can either change the config in-place, override this property,
        or overwrite the instance variable `${cls_name}._subplots`.&#34;&#34;&#34;
        return self._subplots

    def plots(self,
              subplots: tp.Optional[tp.MaybeIterable[tp.Union[str, tp.Tuple[str, tp.Kwargs]]]] = None,
              tags: tp.Optional[tp.MaybeIterable[str]] = None,
              column: tp.Optional[tp.Label] = None,
              group_by: tp.GroupByLike = None,
              silence_warnings: tp.Optional[bool] = None,
              template_mapping: tp.Optional[tp.Mapping] = None,
              settings: tp.KwargsLike = None,
              filters: tp.KwargsLike = None,
              subplot_settings: tp.KwargsLike = None,
              show_titles: bool = None,
              hide_id_labels: bool = None,
              group_id_labels: bool = None,
              make_subplots_kwargs: tp.KwargsLike = None,
              **layout_kwargs) -&gt; tp.Optional[tp.BaseFigure]:
        &#34;&#34;&#34;Plot various parts of this object.

        Args:
            subplots (str, tuple, iterable, or dict): Subplots to plot.

                Each element can be either:

                * a subplot name (see keys in `PlotsBuilderMixin.subplots`)
                * a tuple of a subplot name and a settings dict as in `PlotsBuilderMixin.subplots`.

                The settings dict can contain the following keys:

                * `title`: Title of the subplot. Defaults to the name.
                * `plot_func` (required): Plotting function for custom subplots.
                    Should write the supplied figure `fig` in-place and can return anything (it won&#39;t be used).
                * `xaxis_kwargs`: Layout keyword arguments for the x-axis. Defaults to `dict(title=&#39;Index&#39;)`.
                * `yaxis_kwargs`: Layout keyword arguments for the y-axis. Defaults to empty dict.
                * `tags`, `check_{filter}`, `inv_check_{filter}`, `resolve_plot_func`, `pass_{arg}`,
                    `resolve_path_{arg}`, `resolve_{arg}` and `template_mapping`:
                    The same as in `vectorbt.generic.stats_builder.StatsBuilderMixin` for `calc_func`.
                * Any other keyword argument that overrides the settings or is passed directly to `plot_func`.

                If `resolve_plot_func` is True, the plotting function may &#34;request&#34; any of the
                following arguments by accepting them or if `pass_{arg}` was found in the settings dict:

                * Each of `vectorbt.utils.attr_.AttrResolver.self_aliases`: original object
                    (ungrouped, with no column selected)
                * `group_by`: won&#39;t be passed if it was used in resolving the first attribute of `plot_func`
                    specified as a path, use `pass_group_by=True` to pass anyway
                * `column`
                * `subplot_name`
                * `trace_names`: list with the subplot name, can&#39;t be used in templates
                * `add_trace_kwargs`: dict with subplot row and column index
                * `xref`
                * `yref`
                * `xaxis`
                * `yaxis`
                * `x_domain`
                * `y_domain`
                * `fig`
                * `silence_warnings`
                * Any argument from `settings`
                * Any attribute of this object if it meant to be resolved
                    (see `vectorbt.utils.attr_.AttrResolver.resolve_attr`)

                !!! note
                    Layout-related resolution arguments such as `add_trace_kwargs` are unavailable
                    before filtering and thus cannot be used in any templates but can still be overridden.

                Pass `subplots=&#39;all&#39;` to plot all supported subplots.
            tags (str or iterable): See `tags` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
            column (str): See `column` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
            group_by (any): See `group_by` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
            silence_warnings (bool): See `silence_warnings` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
            template_mapping (mapping): See `template_mapping` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.

                Applied on `settings`, `make_subplots_kwargs`, and `layout_kwargs`, and then on each subplot settings.
            filters (dict): See `filters` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
            settings (dict): See `settings` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
            subplot_settings (dict): See `metric_settings` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
            show_titles (bool): Whether to show the title of each subplot.
            hide_id_labels (bool): Whether to hide identical legend labels.

                Two labels are identical if their name, marker style and line style match.
            group_id_labels (bool): Whether to group identical legend labels.
            make_subplots_kwargs (dict): Keyword arguments passed to `plotly.subplots.make_subplots`.
            **layout_kwargs: Keyword arguments used to update the layout of the figure.

        !!! note
            `PlotsBuilderMixin` and `vectorbt.generic.stats_builder.StatsBuilderMixin` are very similar.
            Some artifacts follow the same concept, just named differently:

            * `plots_defaults` vs `stats_defaults`
            * `subplots` vs `metrics`
            * `subplot_settings` vs `metric_settings`

            See further notes under `vectorbt.generic.stats_builder.StatsBuilderMixin`.

        ## Example

        See `vectorbt.portfolio.base` for examples.
        &#34;&#34;&#34;
        from vectorbt._settings import settings as _settings
        plotting_cfg = _settings[&#39;plotting&#39;]

        # Resolve defaults
        if silence_warnings is None:
            silence_warnings = self.plots_defaults[&#39;silence_warnings&#39;]
        if show_titles is None:
            show_titles = self.plots_defaults[&#39;show_titles&#39;]
        if hide_id_labels is None:
            hide_id_labels = self.plots_defaults[&#39;hide_id_labels&#39;]
        if group_id_labels is None:
            group_id_labels = self.plots_defaults[&#39;group_id_labels&#39;]
        template_mapping = merge_dicts(self.plots_defaults[&#39;template_mapping&#39;], template_mapping)
        filters = merge_dicts(self.plots_defaults[&#39;filters&#39;], filters)
        settings = merge_dicts(self.plots_defaults[&#39;settings&#39;], settings)
        subplot_settings = merge_dicts(self.plots_defaults[&#39;subplot_settings&#39;], subplot_settings)
        make_subplots_kwargs = merge_dicts(self.plots_defaults[&#39;make_subplots_kwargs&#39;], make_subplots_kwargs)
        layout_kwargs = merge_dicts(self.plots_defaults[&#39;layout_kwargs&#39;], layout_kwargs)

        # Replace templates globally (not used at subplot level)
        if len(template_mapping) &gt; 0:
            sub_settings = deep_substitute(settings, mapping=template_mapping)
            sub_make_subplots_kwargs = deep_substitute(make_subplots_kwargs, mapping=template_mapping)
            sub_layout_kwargs = deep_substitute(layout_kwargs, mapping=template_mapping)
        else:
            sub_settings = settings
            sub_make_subplots_kwargs = make_subplots_kwargs
            sub_layout_kwargs = layout_kwargs

        # Resolve self
        reself = self.resolve_self(
            cond_kwargs=sub_settings,
            impacts_caching=False,
            silence_warnings=silence_warnings
        )

        # Prepare subplots
        if subplots is None:
            subplots = reself.plots_defaults[&#39;subplots&#39;]
        if subplots == &#39;all&#39;:
            subplots = reself.subplots
        if isinstance(subplots, dict):
            subplots = list(subplots.items())
        if isinstance(subplots, (str, tuple)):
            subplots = [subplots]

        # Prepare tags
        if tags is None:
            tags = reself.plots_defaults[&#39;tags&#39;]
        if isinstance(tags, str) and tags == &#39;all&#39;:
            tags = None
        if isinstance(tags, (str, tuple)):
            tags = [tags]

        # Bring to the same shape
        new_subplots = []
        for i, subplot in enumerate(subplots):
            if isinstance(subplot, str):
                subplot = (subplot, reself.subplots[subplot])
            if not isinstance(subplot, tuple):
                raise TypeError(f&#34;Subplot at index {i} must be either a string or a tuple&#34;)
            new_subplots.append(subplot)
        subplots = new_subplots

        # Handle duplicate names
        subplot_counts = Counter(list(map(lambda x: x[0], subplots)))
        subplot_i = {k: -1 for k in subplot_counts.keys()}
        subplots_dct = {}
        for i, (subplot_name, _subplot_settings) in enumerate(subplots):
            if subplot_counts[subplot_name] &gt; 1:
                subplot_i[subplot_name] += 1
                subplot_name = subplot_name + &#39;_&#39; + str(subplot_i[subplot_name])
            subplots_dct[subplot_name] = _subplot_settings

        # Check subplot_settings
        missed_keys = set(subplot_settings.keys()).difference(set(subplots_dct.keys()))
        if len(missed_keys) &gt; 0:
            raise ValueError(f&#34;Keys {missed_keys} in subplot_settings could not be matched with any subplot&#34;)

        # Merge settings
        opt_arg_names_dct = {}
        custom_arg_names_dct = {}
        resolved_self_dct = {}
        mapping_dct = {}
        for subplot_name, _subplot_settings in list(subplots_dct.items()):
            opt_settings = merge_dicts(
                {name: reself for name in reself.self_aliases},
                dict(
                    column=column,
                    group_by=group_by,
                    subplot_name=subplot_name,
                    trace_names=[subplot_name],
                    silence_warnings=silence_warnings
                ),
                settings
            )
            _subplot_settings = _subplot_settings.copy()
            passed_subplot_settings = subplot_settings.get(subplot_name, {})
            merged_settings = merge_dicts(
                opt_settings,
                _subplot_settings,
                passed_subplot_settings
            )
            subplot_template_mapping = merged_settings.pop(&#39;template_mapping&#39;, {})
            template_mapping_merged = merge_dicts(template_mapping, subplot_template_mapping)
            template_mapping_merged = deep_substitute(template_mapping_merged, mapping=merged_settings)
            mapping = merge_dicts(template_mapping_merged, merged_settings)
            # safe because we will use deep_substitute again once layout params are known
            merged_settings = deep_substitute(merged_settings, mapping=mapping, safe=True)

            # Filter by tag
            if tags is not None:
                in_tags = merged_settings.get(&#39;tags&#39;, None)
                if in_tags is None or not match_tags(tags, in_tags):
                    subplots_dct.pop(subplot_name, None)
                    continue

            custom_arg_names = set(_subplot_settings.keys()).union(set(passed_subplot_settings.keys()))
            opt_arg_names = set(opt_settings.keys())
            custom_reself = reself.resolve_self(
                cond_kwargs=merged_settings,
                custom_arg_names=custom_arg_names,
                impacts_caching=True,
                silence_warnings=merged_settings[&#39;silence_warnings&#39;]
            )

            subplots_dct[subplot_name] = merged_settings
            custom_arg_names_dct[subplot_name] = custom_arg_names
            opt_arg_names_dct[subplot_name] = opt_arg_names
            resolved_self_dct[subplot_name] = custom_reself
            mapping_dct[subplot_name] = mapping

        # Filter subplots
        for subplot_name, _subplot_settings in list(subplots_dct.items()):
            custom_reself = resolved_self_dct[subplot_name]
            mapping = mapping_dct[subplot_name]
            _silence_warnings = _subplot_settings.get(&#39;silence_warnings&#39;)

            subplot_filters = set()
            for k in _subplot_settings.keys():
                filter_name = None
                if k.startswith(&#39;check_&#39;):
                    filter_name = k[len(&#39;check_&#39;):]
                elif k.startswith(&#39;inv_check_&#39;):
                    filter_name = k[len(&#39;inv_check_&#39;):]
                if filter_name is not None:
                    if filter_name not in filters:
                        raise ValueError(f&#34;Metric &#39;{subplot_name}&#39; requires filter &#39;{filter_name}&#39;&#34;)
                    subplot_filters.add(filter_name)

            for filter_name in subplot_filters:
                filter_settings = filters[filter_name]
                _filter_settings = deep_substitute(filter_settings, mapping=mapping)
                filter_func = _filter_settings[&#39;filter_func&#39;]
                warning_message = _filter_settings.get(&#39;warning_message&#39;, None)
                inv_warning_message = _filter_settings.get(&#39;inv_warning_message&#39;, None)
                to_check = _subplot_settings.get(&#39;check_&#39; + filter_name, False)
                inv_to_check = _subplot_settings.get(&#39;inv_check_&#39; + filter_name, False)

                if to_check or inv_to_check:
                    whether_true = filter_func(custom_reself, _subplot_settings)
                    to_remove = (to_check and not whether_true) or (inv_to_check and whether_true)
                    if to_remove:
                        if to_check and warning_message is not None and not _silence_warnings:
                            warnings.warn(warning_message)
                        if inv_to_check and inv_warning_message is not None and not _silence_warnings:
                            warnings.warn(inv_warning_message)

                        subplots_dct.pop(subplot_name, None)
                        custom_arg_names_dct.pop(subplot_name, None)
                        opt_arg_names_dct.pop(subplot_name, None)
                        resolved_self_dct.pop(subplot_name, None)
                        mapping_dct.pop(subplot_name, None)
                        break

        # Any subplots left?
        if len(subplots_dct) == 0:
            if not silence_warnings:
                warnings.warn(&#34;No subplots to plot&#34;, stacklevel=2)
            return None

        # Set up figure
        rows = sub_make_subplots_kwargs.pop(&#39;rows&#39;, len(subplots_dct))
        cols = sub_make_subplots_kwargs.pop(&#39;cols&#39;, 1)
        specs = sub_make_subplots_kwargs.pop(&#39;specs&#39;, [[{} for _ in range(cols)] for _ in range(rows)])
        row_col_tuples = []
        for row, row_spec in enumerate(specs):
            for col, col_spec in enumerate(row_spec):
                if col_spec is not None:
                    row_col_tuples.append((row + 1, col + 1))
        shared_xaxes = sub_make_subplots_kwargs.pop(&#39;shared_xaxes&#39;, True)
        shared_yaxes = sub_make_subplots_kwargs.pop(&#39;shared_yaxes&#39;, False)
        default_height = plotting_cfg[&#39;layout&#39;][&#39;height&#39;]
        default_width = plotting_cfg[&#39;layout&#39;][&#39;width&#39;] + 50
        min_space = 10  # space between subplots with no axis sharing
        max_title_spacing = 30
        max_xaxis_spacing = 50
        max_yaxis_spacing = 100
        legend_height = 50
        if show_titles:
            title_spacing = max_title_spacing
        else:
            title_spacing = 0
        if not shared_xaxes and rows &gt; 1:
            xaxis_spacing = max_xaxis_spacing
        else:
            xaxis_spacing = 0
        if not shared_yaxes and cols &gt; 1:
            yaxis_spacing = max_yaxis_spacing
        else:
            yaxis_spacing = 0
        if &#39;height&#39; in sub_layout_kwargs:
            height = sub_layout_kwargs.pop(&#39;height&#39;)
        else:
            height = default_height + title_spacing
            if rows &gt; 1:
                height *= rows
                height += min_space * rows - min_space
                height += legend_height - legend_height * rows
                if shared_xaxes:
                    height += max_xaxis_spacing - max_xaxis_spacing * rows
        if &#39;width&#39; in sub_layout_kwargs:
            width = sub_layout_kwargs.pop(&#39;width&#39;)
        else:
            width = default_width
            if cols &gt; 1:
                width *= cols
                width += min_space * cols - min_space
                if shared_yaxes:
                    width += max_yaxis_spacing - max_yaxis_spacing * cols
        if height is not None:
            if &#39;vertical_spacing&#39; in sub_make_subplots_kwargs:
                vertical_spacing = sub_make_subplots_kwargs.pop(&#39;vertical_spacing&#39;)
            else:
                vertical_spacing = min_space + title_spacing + xaxis_spacing
            if vertical_spacing is not None and vertical_spacing &gt; 1:
                vertical_spacing /= height
            legend_y = 1 + (min_space + title_spacing) / height
        else:
            vertical_spacing = sub_make_subplots_kwargs.pop(&#39;vertical_spacing&#39;, None)
            legend_y = 1.02
        if width is not None:
            if &#39;horizontal_spacing&#39; in sub_make_subplots_kwargs:
                horizontal_spacing = sub_make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;)
            else:
                horizontal_spacing = min_space + yaxis_spacing
            if horizontal_spacing is not None and horizontal_spacing &gt; 1:
                horizontal_spacing /= width
        else:
            horizontal_spacing = sub_make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;, None)
        if show_titles:
            _subplot_titles = []
            for i in range(len(subplots_dct)):
                _subplot_titles.append(&#39;$title_&#39; + str(i))
        else:
            _subplot_titles = None
        fig = make_subplots(
            rows=rows,
            cols=cols,
            specs=specs,
            shared_xaxes=shared_xaxes,
            shared_yaxes=shared_yaxes,
            subplot_titles=_subplot_titles,
            vertical_spacing=vertical_spacing,
            horizontal_spacing=horizontal_spacing,
            **sub_make_subplots_kwargs
        )
        sub_layout_kwargs = merge_dicts(dict(
            showlegend=True,
            width=width,
            height=height,
            legend=dict(
                orientation=&#34;h&#34;,
                yanchor=&#34;bottom&#34;,
                y=legend_y,
                xanchor=&#34;right&#34;,
                x=1,
                traceorder=&#39;normal&#39;
            )
        ), sub_layout_kwargs)
        fig.update_layout(**sub_layout_kwargs)  # final destination for sub_layout_kwargs

        # Plot subplots
        arg_cache_dct = {}
        for i, (subplot_name, _subplot_settings) in enumerate(subplots_dct.items()):
            try:
                final_kwargs = _subplot_settings.copy()
                opt_arg_names = opt_arg_names_dct[subplot_name]
                custom_arg_names = custom_arg_names_dct[subplot_name]
                custom_reself = resolved_self_dct[subplot_name]
                mapping = mapping_dct[subplot_name]

                # Compute figure artifacts
                row, col = row_col_tuples[i]
                xref = &#39;x&#39; if i == 0 else &#39;x&#39; + str(i + 1)
                yref = &#39;y&#39; if i == 0 else &#39;y&#39; + str(i + 1)
                xaxis = &#39;xaxis&#39; + xref[1:]
                yaxis = &#39;yaxis&#39; + yref[1:]
                x_domain = get_domain(xref, fig)
                y_domain = get_domain(yref, fig)
                subplot_layout_kwargs = dict(
                    add_trace_kwargs=dict(row=row, col=col),
                    xref=xref,
                    yref=yref,
                    xaxis=xaxis,
                    yaxis=yaxis,
                    x_domain=x_domain,
                    y_domain=y_domain,
                    fig=fig,
                    pass_fig=True  # force passing fig
                )
                for k in subplot_layout_kwargs:
                    opt_arg_names.add(k)
                    if k in final_kwargs:
                        custom_arg_names.add(k)
                final_kwargs = merge_dicts(subplot_layout_kwargs, final_kwargs)
                mapping = merge_dicts(subplot_layout_kwargs, mapping)
                final_kwargs = deep_substitute(final_kwargs, mapping=mapping)

                # Clean up keys
                for k, v in list(final_kwargs.items()):
                    if k.startswith(&#39;check_&#39;) or k.startswith(&#39;inv_check_&#39;) or k in (&#39;tags&#39;,):
                        final_kwargs.pop(k, None)

                # Get subplot-specific values
                _column = final_kwargs.get(&#39;column&#39;)
                _group_by = final_kwargs.get(&#39;group_by&#39;)
                _silence_warnings = final_kwargs.get(&#39;silence_warnings&#39;)
                title = final_kwargs.pop(&#39;title&#39;, subplot_name)
                plot_func = final_kwargs.pop(&#39;plot_func&#39;, None)
                xaxis_kwargs = final_kwargs.pop(&#39;xaxis_kwargs&#39;, None)
                yaxis_kwargs = final_kwargs.pop(&#39;yaxis_kwargs&#39;, None)
                resolve_plot_func = final_kwargs.pop(&#39;resolve_plot_func&#39;, True)
                use_caching = final_kwargs.pop(&#39;use_caching&#39;, True)

                if plot_func is not None:
                    # Resolve plot_func
                    if resolve_plot_func:
                        if not callable(plot_func):
                            passed_kwargs_out = {}

                            def _getattr_func(obj: tp.Any,
                                              attr: str,
                                              args: tp.ArgsLike = None,
                                              kwargs: tp.KwargsLike = None,
                                              call_attr: bool = True,
                                              _final_kwargs: tp.Kwargs = final_kwargs,
                                              _opt_arg_names: tp.Set[str] = opt_arg_names,
                                              _custom_arg_names: tp.Set[str] = custom_arg_names,
                                              _arg_cache_dct: tp.Kwargs = arg_cache_dct) -&gt; tp.Any:
                                if attr in final_kwargs:
                                    return final_kwargs[attr]
                                if args is None:
                                    args = ()
                                if kwargs is None:
                                    kwargs = {}
                                if obj is custom_reself and _final_kwargs.pop(&#39;resolve_path_&#39; + attr, True):
                                    if call_attr:
                                        return custom_reself.resolve_attr(
                                            attr,
                                            args=args,
                                            cond_kwargs={k: v for k, v in _final_kwargs.items() if k in _opt_arg_names},
                                            kwargs=kwargs,
                                            custom_arg_names=_custom_arg_names,
                                            cache_dct=_arg_cache_dct,
                                            use_caching=use_caching,
                                            passed_kwargs_out=passed_kwargs_out
                                        )
                                    return getattr(obj, attr)
                                out = getattr(obj, attr)
                                if callable(out) and call_attr:
                                    return out(*args, **kwargs)
                                return out

                            plot_func = custom_reself.deep_getattr(
                                plot_func,
                                getattr_func=_getattr_func,
                                call_last_attr=False
                            )

                            if &#39;group_by&#39; in passed_kwargs_out:
                                if &#39;pass_group_by&#39; not in final_kwargs:
                                    final_kwargs.pop(&#39;group_by&#39;, None)
                        if not callable(plot_func):
                            raise TypeError(&#34;plot_func must be callable&#34;)

                        # Resolve arguments
                        func_arg_names = get_func_arg_names(plot_func)
                        for k in func_arg_names:
                            if k not in final_kwargs:
                                if final_kwargs.pop(&#39;resolve_&#39; + k, False):
                                    try:
                                        arg_out = custom_reself.resolve_attr(
                                            k,
                                            cond_kwargs=final_kwargs,
                                            custom_arg_names=custom_arg_names,
                                            cache_dct=arg_cache_dct,
                                            use_caching=use_caching
                                        )
                                    except AttributeError:
                                        continue
                                    final_kwargs[k] = arg_out
                        for k in list(final_kwargs.keys()):
                            if k in opt_arg_names:
                                if &#39;pass_&#39; + k in final_kwargs:
                                    if not final_kwargs.get(&#39;pass_&#39; + k):  # first priority
                                        final_kwargs.pop(k, None)
                                elif k not in func_arg_names:  # second priority
                                    final_kwargs.pop(k, None)
                        for k in list(final_kwargs.keys()):
                            if k.startswith(&#39;pass_&#39;) or k.startswith(&#39;resolve_&#39;):
                                final_kwargs.pop(k, None)  # cleanup

                        # Call plot_func
                        plot_func(**final_kwargs)
                    else:
                        # Do not resolve plot_func
                        plot_func(custom_reself, _subplot_settings)

                # Update global layout
                for annotation in fig.layout.annotations:
                    if &#39;text&#39; in annotation and annotation[&#39;text&#39;] == &#39;$title_&#39; + str(i):
                        annotation[&#39;text&#39;] = title
                subplot_layout = dict()
                subplot_layout[xaxis] = merge_dicts(dict(title=&#39;Index&#39;), xaxis_kwargs)
                subplot_layout[yaxis] = merge_dicts(dict(), yaxis_kwargs)
                fig.update_layout(**subplot_layout)
            except Exception as e:
                warnings.warn(f&#34;Subplot &#39;{subplot_name}&#39; raised an exception&#34;, stacklevel=2)
                raise e

        # Remove duplicate legend labels
        found_ids = dict()
        unique_idx = 0
        for trace in fig.data:
            if &#39;name&#39; in trace:
                name = trace[&#39;name&#39;]
            else:
                name = None
            if &#39;marker&#39; in trace:
                marker = trace[&#39;marker&#39;]
            else:
                marker = {}
            if &#39;symbol&#39; in marker:
                marker_symbol = marker[&#39;symbol&#39;]
            else:
                marker_symbol = None
            if &#39;color&#39; in marker:
                marker_color = marker[&#39;color&#39;]
            else:
                marker_color = None
            if &#39;line&#39; in trace:
                line = trace[&#39;line&#39;]
            else:
                line = {}
            if &#39;dash&#39; in line:
                line_dash = line[&#39;dash&#39;]
            else:
                line_dash = None
            if &#39;color&#39; in line:
                line_color = line[&#39;color&#39;]
            else:
                line_color = None

            id = (name, marker_symbol, marker_color, line_dash, line_color)
            if id in found_ids:
                if hide_id_labels:
                    trace[&#39;showlegend&#39;] = False
                if group_id_labels:
                    trace[&#39;legendgroup&#39;] = found_ids[id]
            else:
                if group_id_labels:
                    trace[&#39;legendgroup&#39;] = unique_idx
                found_ids[id] = unique_idx
                unique_idx += 1

        # Remove all except the last title if sharing the same axis
        if shared_xaxes:
            i = 0
            for row in range(rows):
                for col in range(cols):
                    if specs[row][col] is not None:
                        xaxis = &#39;xaxis&#39; if i == 0 else &#39;xaxis&#39; + str(i + 1)
                        if row &lt; rows - 1:
                            fig.layout[xaxis][&#39;title&#39;] = None
                        i += 1
        if shared_yaxes:
            i = 0
            for row in range(rows):
                for col in range(cols):
                    if specs[row][col] is not None:
                        yaxis = &#39;yaxis&#39; if i == 0 else &#39;yaxis&#39; + str(i + 1)
                        if col &gt; 0:
                            fig.layout[yaxis][&#39;title&#39;] = None
                        i += 1

        # Return the figure
        return fig

    # ############# Docs ############# #

    @classmethod
    def build_subplots_doc(cls, source_cls: tp.Optional[type] = None) -&gt; str:
        &#34;&#34;&#34;Build subplots documentation.&#34;&#34;&#34;
        if source_cls is None:
            source_cls = PlotsBuilderMixin
        return string.Template(
            inspect.cleandoc(get_dict_attr(source_cls, &#39;subplots&#39;).__doc__)
        ).substitute(
            {&#39;subplots&#39;: cls.subplots.to_doc(), &#39;cls_name&#39;: cls.__name__}
        )

    @classmethod
    def override_subplots_doc(cls, __pdoc__: dict, source_cls: tp.Optional[type] = None) -&gt; None:
        &#34;&#34;&#34;Call this method on each subclass that overrides `subplots`.&#34;&#34;&#34;
        __pdoc__[cls.__name__ + &#39;.subplots&#39;] = cls.build_subplots_doc(source_cls=source_cls)</code></pre>
</details>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.data.base.Data" href="../data/base.html#vectorbt.data.base.Data">Data</a></li>
<li><a title="vectorbt.generic.accessors.GenericAccessor" href="accessors.html#vectorbt.generic.accessors.GenericAccessor">GenericAccessor</a></li>
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.portfolio.base.Portfolio" href="../portfolio/base.html#vectorbt.portfolio.base.Portfolio">Portfolio</a></li>
<li><a title="vectorbt.records.base.Records" href="../records/base.html#vectorbt.records.base.Records">Records</a></li>
<li><a title="vectorbt.records.mapped_array.MappedArray" href="../records/mapped_array.html#vectorbt.records.mapped_array.MappedArray">MappedArray</a></li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.generic.plots_builder.PlotsBuilderMixin.subplots"><code class="name">var <span class="ident child-name">subplots</span></code></dt>
<dd>
<div class="desc"><p>Subplots supported by <code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></code>.</p>
<pre><code class="language-json">Config({})
</code></pre>
<p>Returns <code>PlotsBuilderMixin._subplots</code>, which gets (deep) copied upon creation of each instance.
Thus, changing this config won't affect the class.</p>
<p>To change subplots, you can either change the config in-place, override this property,
or overwrite the instance variable <code>PlotsBuilderMixin._subplots</code>.</p></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc"><code class="name flex">
<span>def <span class="ident child-name">build_subplots_doc</span></span>(<span class="params">source_cls=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Build subplots documentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build_subplots_doc(cls, source_cls: tp.Optional[type] = None) -&gt; str:
    &#34;&#34;&#34;Build subplots documentation.&#34;&#34;&#34;
    if source_cls is None:
        source_cls = PlotsBuilderMixin
    return string.Template(
        inspect.cleandoc(get_dict_attr(source_cls, &#39;subplots&#39;).__doc__)
    ).substitute(
        {&#39;subplots&#39;: cls.subplots.to_doc(), &#39;cls_name&#39;: cls.__name__}
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc"><code class="name flex">
<span>def <span class="ident child-name">override_subplots_doc</span></span>(<span class="params">__pdoc__, source_cls=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Call this method on each subclass that overrides <code>subplots</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def override_subplots_doc(cls, __pdoc__: dict, source_cls: tp.Optional[type] = None) -&gt; None:
    &#34;&#34;&#34;Call this method on each subclass that overrides `subplots`.&#34;&#34;&#34;
    __pdoc__[cls.__name__ + &#39;.subplots&#39;] = cls.build_subplots_doc(source_cls=source_cls)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults"><code class="name">var <span class="ident child-name">plots_defaults</span></code></dt>
<dd>
<div class="desc"><p>Defaults for <code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">PlotsBuilderMixin.plots()</a></code>.</p>
<p>See <code>plots_builder</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plots_defaults(self) -&gt; tp.Kwargs:
    &#34;&#34;&#34;Defaults for `PlotsBuilderMixin.plots`.

    See `plots_builder` in `vectorbt._settings.settings`.&#34;&#34;&#34;
    from vectorbt._settings import settings
    plots_builder_cfg = settings[&#39;plots_builder&#39;]

    return merge_dicts(
        plots_builder_cfg,
        dict(settings=dict(freq=self.wrapper.freq))
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.plots_builder.PlotsBuilderMixin.writeable_attrs"><code class="name">var <span class="ident child-name">writeable_attrs</span></code></dt>
<dd>
<div class="desc"><p>Set of writeable attributes that will be saved/copied along with the config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def writeable_attrs(self) -&gt; tp.Set[str]:
    &#34;&#34;&#34;Set of writeable attributes that will be saved/copied along with the config.&#34;&#34;&#34;
    return {&#39;_subplots&#39;}</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots"><code class="name flex">
<span>def <span class="ident child-name">plots</span></span>(<span class="params">self, subplots=None, tags=None, column=None, group_by=None, silence_warnings=None, template_mapping=None, settings=None, filters=None, subplot_settings=None, show_titles=None, hide_id_labels=None, group_id_labels=None, make_subplots_kwargs=None, **layout_kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Plot various parts of this object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>subplots</code></strong> :&ensp;<code>str, tuple, iterable,</code> or <code>dict</code></dt>
<dd>
<p>Subplots to plot.</p>
<p>Each element can be either:</p>
<ul>
<li>a subplot name (see keys in <code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.subplots" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin.subplots">PlotsBuilderMixin.subplots</a></code>)</li>
<li>a tuple of a subplot name and a settings dict as in <code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.subplots" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin.subplots">PlotsBuilderMixin.subplots</a></code>.</li>
</ul>
<p>The settings dict can contain the following keys:</p>
<ul>
<li><code>title</code>: Title of the subplot. Defaults to the name.</li>
<li><code>plot_func</code> (required): Plotting function for custom subplots.
Should write the supplied figure <code>fig</code> in-place and can return anything (it won't be used).</li>
<li><code>xaxis_kwargs</code>: Layout keyword arguments for the x-axis. Defaults to <code>dict(title='Index')</code>.</li>
<li><code>yaxis_kwargs</code>: Layout keyword arguments for the y-axis. Defaults to empty dict.</li>
<li><code>tags</code>, <code>check_{filter}</code>, <code>inv_check_{filter}</code>, <code>resolve_plot_func</code>, <code>pass_{arg}</code>,
<code>resolve_path_{arg}</code>, <code>resolve_{arg}</code> and <code>template_mapping</code>:
The same as in <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></code> for <code>calc_func</code>.</li>
<li>Any other keyword argument that overrides the settings or is passed directly to <code>plot_func</code>.</li>
</ul>
<p>If <code>resolve_plot_func</code> is True, the plotting function may "request" any of the
following arguments by accepting them or if <code>pass_{arg}</code> was found in the settings dict:</p>
<ul>
<li>Each of <code><a title="vectorbt.utils.attr_.AttrResolver.self_aliases" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.self_aliases">AttrResolver.self_aliases</a></code>: original object
(ungrouped, with no column selected)</li>
<li><code>group_by</code>: won't be passed if it was used in resolving the first attribute of <code>plot_func</code>
specified as a path, use <code>pass_group_by=True</code> to pass anyway</li>
<li><code>column</code></li>
<li><code>subplot_name</code></li>
<li><code>trace_names</code>: list with the subplot name, can't be used in templates</li>
<li><code>add_trace_kwargs</code>: dict with subplot row and column index</li>
<li><code>xref</code></li>
<li><code>yref</code></li>
<li><code>xaxis</code></li>
<li><code>yaxis</code></li>
<li><code>x_domain</code></li>
<li><code>y_domain</code></li>
<li><code>fig</code></li>
<li><code>silence_warnings</code></li>
<li>Any argument from <code>settings</code></li>
<li>Any attribute of this object if it meant to be resolved
(see <code><a title="vectorbt.utils.attr_.AttrResolver.resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.resolve_attr">AttrResolver.resolve_attr()</a></code>)</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Layout-related resolution arguments such as <code>add_trace_kwargs</code> are unavailable
before filtering and thus cannot be used in any templates but can still be overridden.</p>
</div>
<p>Pass <code>subplots='all'</code> to plot all supported subplots.</p>
</dd>
<dt><strong><code>tags</code></strong> :&ensp;<code>str</code> or <code>iterable</code></dt>
<dd>See <code>tags</code> in <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></code>.</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>See <code>column</code> in <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></code>.</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>See <code>group_by</code> in <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></code>.</dd>
<dt><strong><code>silence_warnings</code></strong> :&ensp;<code>bool</code></dt>
<dd>See <code>silence_warnings</code> in <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></code>.</dd>
<dt><strong><code>template_mapping</code></strong> :&ensp;<code>mapping</code></dt>
<dd>
<p>See <code>template_mapping</code> in <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></code>.</p>
<p>Applied on <code>settings</code>, <code>make_subplots_kwargs</code>, and <code>layout_kwargs</code>, and then on each subplot settings.</p>
</dd>
<dt><strong><code>filters</code></strong> :&ensp;<code>dict</code></dt>
<dd>See <code>filters</code> in <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></code>.</dd>
<dt><strong><code>settings</code></strong> :&ensp;<code>dict</code></dt>
<dd>See <code>settings</code> in <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></code>.</dd>
<dt><strong><code>subplot_settings</code></strong> :&ensp;<code>dict</code></dt>
<dd>See <code>metric_settings</code> in <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></code>.</dd>
<dt><strong><code>show_titles</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to show the title of each subplot.</dd>
<dt><strong><code>hide_id_labels</code></strong> :&ensp;<code>bool</code></dt>
<dd>
<p>Whether to hide identical legend labels.</p>
<p>Two labels are identical if their name, marker style and line style match.</p>
</dd>
<dt><strong><code>group_id_labels</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to group identical legend labels.</dd>
<dt><strong><code>make_subplots_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.subplots.make_subplots</code>.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments used to update the layout of the figure.</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></code> and <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></code> are very similar.
Some artifacts follow the same concept, just named differently:</p>
<ul>
<li><code>plots_defaults</code> vs <code>stats_defaults</code></li>
<li><code>subplots</code> vs <code>metrics</code></li>
<li><code>subplot_settings</code> vs <code>metric_settings</code></li>
</ul>
<p>See further notes under <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></code>.</p>
</div>
<h2 id="example">Example</h2>
<p>See <code><a title="vectorbt.portfolio.base" href="../portfolio/base.html">vectorbt.portfolio.base</a></code> for examples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plots(self,
          subplots: tp.Optional[tp.MaybeIterable[tp.Union[str, tp.Tuple[str, tp.Kwargs]]]] = None,
          tags: tp.Optional[tp.MaybeIterable[str]] = None,
          column: tp.Optional[tp.Label] = None,
          group_by: tp.GroupByLike = None,
          silence_warnings: tp.Optional[bool] = None,
          template_mapping: tp.Optional[tp.Mapping] = None,
          settings: tp.KwargsLike = None,
          filters: tp.KwargsLike = None,
          subplot_settings: tp.KwargsLike = None,
          show_titles: bool = None,
          hide_id_labels: bool = None,
          group_id_labels: bool = None,
          make_subplots_kwargs: tp.KwargsLike = None,
          **layout_kwargs) -&gt; tp.Optional[tp.BaseFigure]:
    &#34;&#34;&#34;Plot various parts of this object.

    Args:
        subplots (str, tuple, iterable, or dict): Subplots to plot.

            Each element can be either:

            * a subplot name (see keys in `PlotsBuilderMixin.subplots`)
            * a tuple of a subplot name and a settings dict as in `PlotsBuilderMixin.subplots`.

            The settings dict can contain the following keys:

            * `title`: Title of the subplot. Defaults to the name.
            * `plot_func` (required): Plotting function for custom subplots.
                Should write the supplied figure `fig` in-place and can return anything (it won&#39;t be used).
            * `xaxis_kwargs`: Layout keyword arguments for the x-axis. Defaults to `dict(title=&#39;Index&#39;)`.
            * `yaxis_kwargs`: Layout keyword arguments for the y-axis. Defaults to empty dict.
            * `tags`, `check_{filter}`, `inv_check_{filter}`, `resolve_plot_func`, `pass_{arg}`,
                `resolve_path_{arg}`, `resolve_{arg}` and `template_mapping`:
                The same as in `vectorbt.generic.stats_builder.StatsBuilderMixin` for `calc_func`.
            * Any other keyword argument that overrides the settings or is passed directly to `plot_func`.

            If `resolve_plot_func` is True, the plotting function may &#34;request&#34; any of the
            following arguments by accepting them or if `pass_{arg}` was found in the settings dict:

            * Each of `vectorbt.utils.attr_.AttrResolver.self_aliases`: original object
                (ungrouped, with no column selected)
            * `group_by`: won&#39;t be passed if it was used in resolving the first attribute of `plot_func`
                specified as a path, use `pass_group_by=True` to pass anyway
            * `column`
            * `subplot_name`
            * `trace_names`: list with the subplot name, can&#39;t be used in templates
            * `add_trace_kwargs`: dict with subplot row and column index
            * `xref`
            * `yref`
            * `xaxis`
            * `yaxis`
            * `x_domain`
            * `y_domain`
            * `fig`
            * `silence_warnings`
            * Any argument from `settings`
            * Any attribute of this object if it meant to be resolved
                (see `vectorbt.utils.attr_.AttrResolver.resolve_attr`)

            !!! note
                Layout-related resolution arguments such as `add_trace_kwargs` are unavailable
                before filtering and thus cannot be used in any templates but can still be overridden.

            Pass `subplots=&#39;all&#39;` to plot all supported subplots.
        tags (str or iterable): See `tags` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
        column (str): See `column` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
        group_by (any): See `group_by` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
        silence_warnings (bool): See `silence_warnings` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
        template_mapping (mapping): See `template_mapping` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.

            Applied on `settings`, `make_subplots_kwargs`, and `layout_kwargs`, and then on each subplot settings.
        filters (dict): See `filters` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
        settings (dict): See `settings` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
        subplot_settings (dict): See `metric_settings` in `vectorbt.generic.stats_builder.StatsBuilderMixin`.
        show_titles (bool): Whether to show the title of each subplot.
        hide_id_labels (bool): Whether to hide identical legend labels.

            Two labels are identical if their name, marker style and line style match.
        group_id_labels (bool): Whether to group identical legend labels.
        make_subplots_kwargs (dict): Keyword arguments passed to `plotly.subplots.make_subplots`.
        **layout_kwargs: Keyword arguments used to update the layout of the figure.

    !!! note
        `PlotsBuilderMixin` and `vectorbt.generic.stats_builder.StatsBuilderMixin` are very similar.
        Some artifacts follow the same concept, just named differently:

        * `plots_defaults` vs `stats_defaults`
        * `subplots` vs `metrics`
        * `subplot_settings` vs `metric_settings`

        See further notes under `vectorbt.generic.stats_builder.StatsBuilderMixin`.

    ## Example

    See `vectorbt.portfolio.base` for examples.
    &#34;&#34;&#34;
    from vectorbt._settings import settings as _settings
    plotting_cfg = _settings[&#39;plotting&#39;]

    # Resolve defaults
    if silence_warnings is None:
        silence_warnings = self.plots_defaults[&#39;silence_warnings&#39;]
    if show_titles is None:
        show_titles = self.plots_defaults[&#39;show_titles&#39;]
    if hide_id_labels is None:
        hide_id_labels = self.plots_defaults[&#39;hide_id_labels&#39;]
    if group_id_labels is None:
        group_id_labels = self.plots_defaults[&#39;group_id_labels&#39;]
    template_mapping = merge_dicts(self.plots_defaults[&#39;template_mapping&#39;], template_mapping)
    filters = merge_dicts(self.plots_defaults[&#39;filters&#39;], filters)
    settings = merge_dicts(self.plots_defaults[&#39;settings&#39;], settings)
    subplot_settings = merge_dicts(self.plots_defaults[&#39;subplot_settings&#39;], subplot_settings)
    make_subplots_kwargs = merge_dicts(self.plots_defaults[&#39;make_subplots_kwargs&#39;], make_subplots_kwargs)
    layout_kwargs = merge_dicts(self.plots_defaults[&#39;layout_kwargs&#39;], layout_kwargs)

    # Replace templates globally (not used at subplot level)
    if len(template_mapping) &gt; 0:
        sub_settings = deep_substitute(settings, mapping=template_mapping)
        sub_make_subplots_kwargs = deep_substitute(make_subplots_kwargs, mapping=template_mapping)
        sub_layout_kwargs = deep_substitute(layout_kwargs, mapping=template_mapping)
    else:
        sub_settings = settings
        sub_make_subplots_kwargs = make_subplots_kwargs
        sub_layout_kwargs = layout_kwargs

    # Resolve self
    reself = self.resolve_self(
        cond_kwargs=sub_settings,
        impacts_caching=False,
        silence_warnings=silence_warnings
    )

    # Prepare subplots
    if subplots is None:
        subplots = reself.plots_defaults[&#39;subplots&#39;]
    if subplots == &#39;all&#39;:
        subplots = reself.subplots
    if isinstance(subplots, dict):
        subplots = list(subplots.items())
    if isinstance(subplots, (str, tuple)):
        subplots = [subplots]

    # Prepare tags
    if tags is None:
        tags = reself.plots_defaults[&#39;tags&#39;]
    if isinstance(tags, str) and tags == &#39;all&#39;:
        tags = None
    if isinstance(tags, (str, tuple)):
        tags = [tags]

    # Bring to the same shape
    new_subplots = []
    for i, subplot in enumerate(subplots):
        if isinstance(subplot, str):
            subplot = (subplot, reself.subplots[subplot])
        if not isinstance(subplot, tuple):
            raise TypeError(f&#34;Subplot at index {i} must be either a string or a tuple&#34;)
        new_subplots.append(subplot)
    subplots = new_subplots

    # Handle duplicate names
    subplot_counts = Counter(list(map(lambda x: x[0], subplots)))
    subplot_i = {k: -1 for k in subplot_counts.keys()}
    subplots_dct = {}
    for i, (subplot_name, _subplot_settings) in enumerate(subplots):
        if subplot_counts[subplot_name] &gt; 1:
            subplot_i[subplot_name] += 1
            subplot_name = subplot_name + &#39;_&#39; + str(subplot_i[subplot_name])
        subplots_dct[subplot_name] = _subplot_settings

    # Check subplot_settings
    missed_keys = set(subplot_settings.keys()).difference(set(subplots_dct.keys()))
    if len(missed_keys) &gt; 0:
        raise ValueError(f&#34;Keys {missed_keys} in subplot_settings could not be matched with any subplot&#34;)

    # Merge settings
    opt_arg_names_dct = {}
    custom_arg_names_dct = {}
    resolved_self_dct = {}
    mapping_dct = {}
    for subplot_name, _subplot_settings in list(subplots_dct.items()):
        opt_settings = merge_dicts(
            {name: reself for name in reself.self_aliases},
            dict(
                column=column,
                group_by=group_by,
                subplot_name=subplot_name,
                trace_names=[subplot_name],
                silence_warnings=silence_warnings
            ),
            settings
        )
        _subplot_settings = _subplot_settings.copy()
        passed_subplot_settings = subplot_settings.get(subplot_name, {})
        merged_settings = merge_dicts(
            opt_settings,
            _subplot_settings,
            passed_subplot_settings
        )
        subplot_template_mapping = merged_settings.pop(&#39;template_mapping&#39;, {})
        template_mapping_merged = merge_dicts(template_mapping, subplot_template_mapping)
        template_mapping_merged = deep_substitute(template_mapping_merged, mapping=merged_settings)
        mapping = merge_dicts(template_mapping_merged, merged_settings)
        # safe because we will use deep_substitute again once layout params are known
        merged_settings = deep_substitute(merged_settings, mapping=mapping, safe=True)

        # Filter by tag
        if tags is not None:
            in_tags = merged_settings.get(&#39;tags&#39;, None)
            if in_tags is None or not match_tags(tags, in_tags):
                subplots_dct.pop(subplot_name, None)
                continue

        custom_arg_names = set(_subplot_settings.keys()).union(set(passed_subplot_settings.keys()))
        opt_arg_names = set(opt_settings.keys())
        custom_reself = reself.resolve_self(
            cond_kwargs=merged_settings,
            custom_arg_names=custom_arg_names,
            impacts_caching=True,
            silence_warnings=merged_settings[&#39;silence_warnings&#39;]
        )

        subplots_dct[subplot_name] = merged_settings
        custom_arg_names_dct[subplot_name] = custom_arg_names
        opt_arg_names_dct[subplot_name] = opt_arg_names
        resolved_self_dct[subplot_name] = custom_reself
        mapping_dct[subplot_name] = mapping

    # Filter subplots
    for subplot_name, _subplot_settings in list(subplots_dct.items()):
        custom_reself = resolved_self_dct[subplot_name]
        mapping = mapping_dct[subplot_name]
        _silence_warnings = _subplot_settings.get(&#39;silence_warnings&#39;)

        subplot_filters = set()
        for k in _subplot_settings.keys():
            filter_name = None
            if k.startswith(&#39;check_&#39;):
                filter_name = k[len(&#39;check_&#39;):]
            elif k.startswith(&#39;inv_check_&#39;):
                filter_name = k[len(&#39;inv_check_&#39;):]
            if filter_name is not None:
                if filter_name not in filters:
                    raise ValueError(f&#34;Metric &#39;{subplot_name}&#39; requires filter &#39;{filter_name}&#39;&#34;)
                subplot_filters.add(filter_name)

        for filter_name in subplot_filters:
            filter_settings = filters[filter_name]
            _filter_settings = deep_substitute(filter_settings, mapping=mapping)
            filter_func = _filter_settings[&#39;filter_func&#39;]
            warning_message = _filter_settings.get(&#39;warning_message&#39;, None)
            inv_warning_message = _filter_settings.get(&#39;inv_warning_message&#39;, None)
            to_check = _subplot_settings.get(&#39;check_&#39; + filter_name, False)
            inv_to_check = _subplot_settings.get(&#39;inv_check_&#39; + filter_name, False)

            if to_check or inv_to_check:
                whether_true = filter_func(custom_reself, _subplot_settings)
                to_remove = (to_check and not whether_true) or (inv_to_check and whether_true)
                if to_remove:
                    if to_check and warning_message is not None and not _silence_warnings:
                        warnings.warn(warning_message)
                    if inv_to_check and inv_warning_message is not None and not _silence_warnings:
                        warnings.warn(inv_warning_message)

                    subplots_dct.pop(subplot_name, None)
                    custom_arg_names_dct.pop(subplot_name, None)
                    opt_arg_names_dct.pop(subplot_name, None)
                    resolved_self_dct.pop(subplot_name, None)
                    mapping_dct.pop(subplot_name, None)
                    break

    # Any subplots left?
    if len(subplots_dct) == 0:
        if not silence_warnings:
            warnings.warn(&#34;No subplots to plot&#34;, stacklevel=2)
        return None

    # Set up figure
    rows = sub_make_subplots_kwargs.pop(&#39;rows&#39;, len(subplots_dct))
    cols = sub_make_subplots_kwargs.pop(&#39;cols&#39;, 1)
    specs = sub_make_subplots_kwargs.pop(&#39;specs&#39;, [[{} for _ in range(cols)] for _ in range(rows)])
    row_col_tuples = []
    for row, row_spec in enumerate(specs):
        for col, col_spec in enumerate(row_spec):
            if col_spec is not None:
                row_col_tuples.append((row + 1, col + 1))
    shared_xaxes = sub_make_subplots_kwargs.pop(&#39;shared_xaxes&#39;, True)
    shared_yaxes = sub_make_subplots_kwargs.pop(&#39;shared_yaxes&#39;, False)
    default_height = plotting_cfg[&#39;layout&#39;][&#39;height&#39;]
    default_width = plotting_cfg[&#39;layout&#39;][&#39;width&#39;] + 50
    min_space = 10  # space between subplots with no axis sharing
    max_title_spacing = 30
    max_xaxis_spacing = 50
    max_yaxis_spacing = 100
    legend_height = 50
    if show_titles:
        title_spacing = max_title_spacing
    else:
        title_spacing = 0
    if not shared_xaxes and rows &gt; 1:
        xaxis_spacing = max_xaxis_spacing
    else:
        xaxis_spacing = 0
    if not shared_yaxes and cols &gt; 1:
        yaxis_spacing = max_yaxis_spacing
    else:
        yaxis_spacing = 0
    if &#39;height&#39; in sub_layout_kwargs:
        height = sub_layout_kwargs.pop(&#39;height&#39;)
    else:
        height = default_height + title_spacing
        if rows &gt; 1:
            height *= rows
            height += min_space * rows - min_space
            height += legend_height - legend_height * rows
            if shared_xaxes:
                height += max_xaxis_spacing - max_xaxis_spacing * rows
    if &#39;width&#39; in sub_layout_kwargs:
        width = sub_layout_kwargs.pop(&#39;width&#39;)
    else:
        width = default_width
        if cols &gt; 1:
            width *= cols
            width += min_space * cols - min_space
            if shared_yaxes:
                width += max_yaxis_spacing - max_yaxis_spacing * cols
    if height is not None:
        if &#39;vertical_spacing&#39; in sub_make_subplots_kwargs:
            vertical_spacing = sub_make_subplots_kwargs.pop(&#39;vertical_spacing&#39;)
        else:
            vertical_spacing = min_space + title_spacing + xaxis_spacing
        if vertical_spacing is not None and vertical_spacing &gt; 1:
            vertical_spacing /= height
        legend_y = 1 + (min_space + title_spacing) / height
    else:
        vertical_spacing = sub_make_subplots_kwargs.pop(&#39;vertical_spacing&#39;, None)
        legend_y = 1.02
    if width is not None:
        if &#39;horizontal_spacing&#39; in sub_make_subplots_kwargs:
            horizontal_spacing = sub_make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;)
        else:
            horizontal_spacing = min_space + yaxis_spacing
        if horizontal_spacing is not None and horizontal_spacing &gt; 1:
            horizontal_spacing /= width
    else:
        horizontal_spacing = sub_make_subplots_kwargs.pop(&#39;horizontal_spacing&#39;, None)
    if show_titles:
        _subplot_titles = []
        for i in range(len(subplots_dct)):
            _subplot_titles.append(&#39;$title_&#39; + str(i))
    else:
        _subplot_titles = None
    fig = make_subplots(
        rows=rows,
        cols=cols,
        specs=specs,
        shared_xaxes=shared_xaxes,
        shared_yaxes=shared_yaxes,
        subplot_titles=_subplot_titles,
        vertical_spacing=vertical_spacing,
        horizontal_spacing=horizontal_spacing,
        **sub_make_subplots_kwargs
    )
    sub_layout_kwargs = merge_dicts(dict(
        showlegend=True,
        width=width,
        height=height,
        legend=dict(
            orientation=&#34;h&#34;,
            yanchor=&#34;bottom&#34;,
            y=legend_y,
            xanchor=&#34;right&#34;,
            x=1,
            traceorder=&#39;normal&#39;
        )
    ), sub_layout_kwargs)
    fig.update_layout(**sub_layout_kwargs)  # final destination for sub_layout_kwargs

    # Plot subplots
    arg_cache_dct = {}
    for i, (subplot_name, _subplot_settings) in enumerate(subplots_dct.items()):
        try:
            final_kwargs = _subplot_settings.copy()
            opt_arg_names = opt_arg_names_dct[subplot_name]
            custom_arg_names = custom_arg_names_dct[subplot_name]
            custom_reself = resolved_self_dct[subplot_name]
            mapping = mapping_dct[subplot_name]

            # Compute figure artifacts
            row, col = row_col_tuples[i]
            xref = &#39;x&#39; if i == 0 else &#39;x&#39; + str(i + 1)
            yref = &#39;y&#39; if i == 0 else &#39;y&#39; + str(i + 1)
            xaxis = &#39;xaxis&#39; + xref[1:]
            yaxis = &#39;yaxis&#39; + yref[1:]
            x_domain = get_domain(xref, fig)
            y_domain = get_domain(yref, fig)
            subplot_layout_kwargs = dict(
                add_trace_kwargs=dict(row=row, col=col),
                xref=xref,
                yref=yref,
                xaxis=xaxis,
                yaxis=yaxis,
                x_domain=x_domain,
                y_domain=y_domain,
                fig=fig,
                pass_fig=True  # force passing fig
            )
            for k in subplot_layout_kwargs:
                opt_arg_names.add(k)
                if k in final_kwargs:
                    custom_arg_names.add(k)
            final_kwargs = merge_dicts(subplot_layout_kwargs, final_kwargs)
            mapping = merge_dicts(subplot_layout_kwargs, mapping)
            final_kwargs = deep_substitute(final_kwargs, mapping=mapping)

            # Clean up keys
            for k, v in list(final_kwargs.items()):
                if k.startswith(&#39;check_&#39;) or k.startswith(&#39;inv_check_&#39;) or k in (&#39;tags&#39;,):
                    final_kwargs.pop(k, None)

            # Get subplot-specific values
            _column = final_kwargs.get(&#39;column&#39;)
            _group_by = final_kwargs.get(&#39;group_by&#39;)
            _silence_warnings = final_kwargs.get(&#39;silence_warnings&#39;)
            title = final_kwargs.pop(&#39;title&#39;, subplot_name)
            plot_func = final_kwargs.pop(&#39;plot_func&#39;, None)
            xaxis_kwargs = final_kwargs.pop(&#39;xaxis_kwargs&#39;, None)
            yaxis_kwargs = final_kwargs.pop(&#39;yaxis_kwargs&#39;, None)
            resolve_plot_func = final_kwargs.pop(&#39;resolve_plot_func&#39;, True)
            use_caching = final_kwargs.pop(&#39;use_caching&#39;, True)

            if plot_func is not None:
                # Resolve plot_func
                if resolve_plot_func:
                    if not callable(plot_func):
                        passed_kwargs_out = {}

                        def _getattr_func(obj: tp.Any,
                                          attr: str,
                                          args: tp.ArgsLike = None,
                                          kwargs: tp.KwargsLike = None,
                                          call_attr: bool = True,
                                          _final_kwargs: tp.Kwargs = final_kwargs,
                                          _opt_arg_names: tp.Set[str] = opt_arg_names,
                                          _custom_arg_names: tp.Set[str] = custom_arg_names,
                                          _arg_cache_dct: tp.Kwargs = arg_cache_dct) -&gt; tp.Any:
                            if attr in final_kwargs:
                                return final_kwargs[attr]
                            if args is None:
                                args = ()
                            if kwargs is None:
                                kwargs = {}
                            if obj is custom_reself and _final_kwargs.pop(&#39;resolve_path_&#39; + attr, True):
                                if call_attr:
                                    return custom_reself.resolve_attr(
                                        attr,
                                        args=args,
                                        cond_kwargs={k: v for k, v in _final_kwargs.items() if k in _opt_arg_names},
                                        kwargs=kwargs,
                                        custom_arg_names=_custom_arg_names,
                                        cache_dct=_arg_cache_dct,
                                        use_caching=use_caching,
                                        passed_kwargs_out=passed_kwargs_out
                                    )
                                return getattr(obj, attr)
                            out = getattr(obj, attr)
                            if callable(out) and call_attr:
                                return out(*args, **kwargs)
                            return out

                        plot_func = custom_reself.deep_getattr(
                            plot_func,
                            getattr_func=_getattr_func,
                            call_last_attr=False
                        )

                        if &#39;group_by&#39; in passed_kwargs_out:
                            if &#39;pass_group_by&#39; not in final_kwargs:
                                final_kwargs.pop(&#39;group_by&#39;, None)
                    if not callable(plot_func):
                        raise TypeError(&#34;plot_func must be callable&#34;)

                    # Resolve arguments
                    func_arg_names = get_func_arg_names(plot_func)
                    for k in func_arg_names:
                        if k not in final_kwargs:
                            if final_kwargs.pop(&#39;resolve_&#39; + k, False):
                                try:
                                    arg_out = custom_reself.resolve_attr(
                                        k,
                                        cond_kwargs=final_kwargs,
                                        custom_arg_names=custom_arg_names,
                                        cache_dct=arg_cache_dct,
                                        use_caching=use_caching
                                    )
                                except AttributeError:
                                    continue
                                final_kwargs[k] = arg_out
                    for k in list(final_kwargs.keys()):
                        if k in opt_arg_names:
                            if &#39;pass_&#39; + k in final_kwargs:
                                if not final_kwargs.get(&#39;pass_&#39; + k):  # first priority
                                    final_kwargs.pop(k, None)
                            elif k not in func_arg_names:  # second priority
                                final_kwargs.pop(k, None)
                    for k in list(final_kwargs.keys()):
                        if k.startswith(&#39;pass_&#39;) or k.startswith(&#39;resolve_&#39;):
                            final_kwargs.pop(k, None)  # cleanup

                    # Call plot_func
                    plot_func(**final_kwargs)
                else:
                    # Do not resolve plot_func
                    plot_func(custom_reself, _subplot_settings)

            # Update global layout
            for annotation in fig.layout.annotations:
                if &#39;text&#39; in annotation and annotation[&#39;text&#39;] == &#39;$title_&#39; + str(i):
                    annotation[&#39;text&#39;] = title
            subplot_layout = dict()
            subplot_layout[xaxis] = merge_dicts(dict(title=&#39;Index&#39;), xaxis_kwargs)
            subplot_layout[yaxis] = merge_dicts(dict(), yaxis_kwargs)
            fig.update_layout(**subplot_layout)
        except Exception as e:
            warnings.warn(f&#34;Subplot &#39;{subplot_name}&#39; raised an exception&#34;, stacklevel=2)
            raise e

    # Remove duplicate legend labels
    found_ids = dict()
    unique_idx = 0
    for trace in fig.data:
        if &#39;name&#39; in trace:
            name = trace[&#39;name&#39;]
        else:
            name = None
        if &#39;marker&#39; in trace:
            marker = trace[&#39;marker&#39;]
        else:
            marker = {}
        if &#39;symbol&#39; in marker:
            marker_symbol = marker[&#39;symbol&#39;]
        else:
            marker_symbol = None
        if &#39;color&#39; in marker:
            marker_color = marker[&#39;color&#39;]
        else:
            marker_color = None
        if &#39;line&#39; in trace:
            line = trace[&#39;line&#39;]
        else:
            line = {}
        if &#39;dash&#39; in line:
            line_dash = line[&#39;dash&#39;]
        else:
            line_dash = None
        if &#39;color&#39; in line:
            line_color = line[&#39;color&#39;]
        else:
            line_color = None

        id = (name, marker_symbol, marker_color, line_dash, line_color)
        if id in found_ids:
            if hide_id_labels:
                trace[&#39;showlegend&#39;] = False
            if group_id_labels:
                trace[&#39;legendgroup&#39;] = found_ids[id]
        else:
            if group_id_labels:
                trace[&#39;legendgroup&#39;] = unique_idx
            found_ids[id] = unique_idx
            unique_idx += 1

    # Remove all except the last title if sharing the same axis
    if shared_xaxes:
        i = 0
        for row in range(rows):
            for col in range(cols):
                if specs[row][col] is not None:
                    xaxis = &#39;xaxis&#39; if i == 0 else &#39;xaxis&#39; + str(i + 1)
                    if row &lt; rows - 1:
                        fig.layout[xaxis][&#39;title&#39;] = None
                    i += 1
    if shared_yaxes:
        i = 0
        for row in range(rows):
            for col in range(cols):
                if specs[row][col] is not None:
                    yaxis = &#39;yaxis&#39; if i == 0 else &#39;yaxis&#39; + str(i + 1)
                    if col &gt; 0:
                        fig.layout[yaxis][&#39;title&#39;] = None
                    i += 1

    # Return the figure
    return fig</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRUYwMDAwO30KCS5zdDF7ZmlsbDojRkY5MDAwO30KCS5zdDJ7ZmlsbDojRkZERjAwO30KCS5zdDN7ZmlsbDojMjgyQzM0O30KPC9zdHlsZT4KPGc+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNTUuMywzMDAuMSAyODMuMSwwIDIwOCwwIDExMC44LDAgMzUuOCwwIDEuMiw0NTAuMiA3Ni4zLDQ1MC4yIAkJCSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjIzMC40LDMwMC4xIDM1OC4xLDAgMjgzLjEsMCAxODUuOCwwIDExMC44LDAgNzYuMyw0NTAuMiAxNTEuMyw0NTAuMiAJCQkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIzMDUuNCwzMDAuMSA0MzMuMSwwIDM1OC4xLDAgMzMxLjYsNjIuMyAyNjAuOCwwIDE4NS44LDAgMTUxLjMsNDUwLjIgMjI2LjQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iNTEwLjgsMCA0MzMuMSwwIDMwNS40LDMwMC4xIDMzOC40LDAgMjYwLjgsMCAyMjYuNCw0NTAuMiAzMDQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="/>
vectorbt <span class="version">0.22.0</span></a>
</header>
<div class="search-container" id="docsearch"></div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.generic" href="index.html">vectorbt.generic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.generic.plots_builder.MetaPlotsBuilderMixin" href="#vectorbt.generic.plots_builder.MetaPlotsBuilderMixin">MetaPlotsBuilderMixin</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.generic.plots_builder.MetaPlotsBuilderMixin.subplots" href="#vectorbt.generic.plots_builder.MetaPlotsBuilderMixin.subplots">subplots</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
<li><code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.subplots" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin.subplots">subplots</a></code></li>
<li><code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.writeable_attrs" href="#vectorbt.generic.plots_builder.PlotsBuilderMixin.writeable_attrs">writeable_attrs</a></code></li>
</ul>
</li>
</ul>
</li>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script src="https://cdn.jsdelivr.net/npm/@docsearch/js@alpha"></script>
<script type="text/javascript">
docsearch({
container: '#docsearch',
appId: 'KNQTBBHKVB',
indexName: 'vectorbt',
apiKey: 'a945e6e8f1cb2fdc30e936936aa3307b',
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous"></script>
<script>
$(document).ready(function() {
$("article dt[id], #section-intro [id]").each(function() {
const thisId = $(this).attr('id');
$(this).wrap('<a class="headerlink" href="#' + thisId + '">');
});
});
</script>
</body>
</html>