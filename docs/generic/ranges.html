<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>vectorbt.generic.ranges API documentation</title>
<meta name="description" content="Base class for working with range records â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css@alpha" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#e82;--docsearch-primary-color:#e82;--docsearch-searchbox-focus-background:#ebedf0}body{line-height:1.5em}.version{font-weight:normal;font-style:italic;font-size:.75em;color:#8b949e}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}h2[id^="header-"]{margin-top:2em}.ident{color:#900}.headerlink{color:inherit}.headerlink:hover{color:inherit}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important;word-break:normal}.hljs-keyword{color:#ff7b72 !important}.hljs-comment{color:#8b949e !important}.hljs-meta{color:#8b949e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 1.5em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:1em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-weight:400;font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}.DocSearch-Button{width:100%;margin:0px;height:38px}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{min-width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}.hljs{margin-left:-15px;margin-right:-15px}.source pre code{margin-left:0px;margin-right:0px}dd{margin:0 0 1em 3em}dd dd{margin-left:2em}.flex{display:flex !important}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4QLCS0J048"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4QLCS0J048');
</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:100px;max-height:100px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.generic.ranges</code></h1>
</header>
<section id="section-intro">
<p>Base class for working with range records.</p>
<p>Range records capture information on ranges. They are useful for analyzing duration of processes,
such as drawdowns, trades, and positions. They also come in handy when analyzing distance between events,
such as entry and exit signals.</p>
<p>Each range has a starting point and an ending point. For example, the points for <code>range(20)</code>
are 0 and 20 (not 19!) respectively.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Be aware that if a range hasn't ended in a column, its <code>end_idx</code> will point at the latest index.
Make sure to account for this when computing custom metrics involving duration.</p>
</div>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd

&gt;&gt;&gt; start = '2019-01-01 UTC'  # crypto is in UTC
&gt;&gt;&gt; end = '2020-01-01 UTC'
&gt;&gt;&gt; price = vbt.YFData.download('BTC-USD', start=start, end=end).get('Close')
&gt;&gt;&gt; fast_ma = vbt.MA.run(price, 10)
&gt;&gt;&gt; slow_ma = vbt.MA.run(price, 50)
&gt;&gt;&gt; fast_below_slow = fast_ma.ma_above(slow_ma)

&gt;&gt;&gt; ranges = vbt.Ranges.from_ts(fast_below_slow, wrapper_kwargs=dict(freq='d'))

&gt;&gt;&gt; ranges.records_readable
   Range Id  Column           Start Timestamp             End Timestamp  \
0         0       0 2019-02-19 00:00:00+00:00 2019-07-25 00:00:00+00:00
1         1       0 2019-08-08 00:00:00+00:00 2019-08-19 00:00:00+00:00
2         2       0 2019-11-01 00:00:00+00:00 2019-11-20 00:00:00+00:00

   Status
0  Closed
1  Closed
2  Closed

&gt;&gt;&gt; ranges.duration.max(wrap_kwargs=dict(to_timedelta=True))
Timedelta('74 days 00:00:00')
</code></pre>
<h2 id="from-accessors">From accessors</h2>
<p>Moreover, all generic accessors have a property <code>ranges</code> and a method <code>get_ranges</code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; # vectorbt.generic.accessors.GenericAccessor.ranges.coverage
&gt;&gt;&gt; fast_below_slow.vbt.ranges.coverage()
0.35792349726775957
</code></pre>
<h2 id="stats">Stats</h2>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>See <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code> and <code><a title="vectorbt.generic.ranges.Ranges.metrics" href="#vectorbt.generic.ranges.Ranges.metrics">Ranges.metrics</a></code>.</p>
</div>
<pre><code class="language-python-repl">&gt;&gt;&gt; df = pd.DataFrame({
...     'a': [1, 2, np.nan, np.nan, 5, 6],
...     'b': [np.nan, 2, np.nan, 4, np.nan, 6]
... })
&gt;&gt;&gt; ranges = df.vbt(freq='d').ranges

&gt;&gt;&gt; ranges['a'].stats()
Start                             0
End                               5
Period              6 days 00:00:00
Total Records                     2
Coverage            4 days 00:00:00
Overlap Coverage    0 days 00:00:00
Duration: Min       2 days 00:00:00
Duration: Median    2 days 00:00:00
Duration: Max       2 days 00:00:00
Duration: Mean      2 days 00:00:00
Duration: Std       0 days 00:00:00
Name: a, dtype: object
</code></pre>
<p><code><a title="vectorbt.generic.ranges.Ranges.stats" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code> also supports (re-)grouping:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ranges.stats(group_by=True)
Start                                       0
End                                         5
Period                        6 days 00:00:00
Total Records                               5
Coverage                      5 days 00:00:00
Overlap Coverage              2 days 00:00:00
Duration: Min                 1 days 00:00:00
Duration: Median              1 days 00:00:00
Duration: Max                 2 days 00:00:00
Duration: Mean                1 days 09:36:00
Duration: Std       0 days 13:08:43.228968446
Name: group, dtype: object
</code></pre>
<h2 id="plots">Plots</h2>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>See <code><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin.plots" href="plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">PlotsBuilderMixin.plots()</a></code> and <code><a title="vectorbt.generic.ranges.Ranges.subplots" href="#vectorbt.generic.ranges.Ranges.subplots">Ranges.subplots</a></code>.</p>
</div>
<p><code><a title="vectorbt.generic.ranges.Ranges" href="#vectorbt.generic.ranges.Ranges">Ranges</a></code> class has a single subplot based on <code><a title="vectorbt.generic.ranges.Ranges.plot" href="#vectorbt.generic.ranges.Ranges.plot">Ranges.plot()</a></code>:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; ranges['a'].plots()
</code></pre>
<p><img alt="" src="/docs/img/ranges_plots.svg"></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;Base class for working with range records.

Range records capture information on ranges. They are useful for analyzing duration of processes,
such as drawdowns, trades, and positions. They also come in handy when analyzing distance between events,
such as entry and exit signals.

Each range has a starting point and an ending point. For example, the points for `range(20)`
are 0 and 20 (not 19!) respectively.

!!! note
    Be aware that if a range hasn&#39;t ended in a column, its `end_idx` will point at the latest index.
    Make sure to account for this when computing custom metrics involving duration.

```python-repl
&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; import pandas as pd

&gt;&gt;&gt; start = &#39;2019-01-01 UTC&#39;  # crypto is in UTC
&gt;&gt;&gt; end = &#39;2020-01-01 UTC&#39;
&gt;&gt;&gt; price = vbt.YFData.download(&#39;BTC-USD&#39;, start=start, end=end).get(&#39;Close&#39;)
&gt;&gt;&gt; fast_ma = vbt.MA.run(price, 10)
&gt;&gt;&gt; slow_ma = vbt.MA.run(price, 50)
&gt;&gt;&gt; fast_below_slow = fast_ma.ma_above(slow_ma)

&gt;&gt;&gt; ranges = vbt.Ranges.from_ts(fast_below_slow, wrapper_kwargs=dict(freq=&#39;d&#39;))

&gt;&gt;&gt; ranges.records_readable
   Range Id  Column           Start Timestamp             End Timestamp  \\
0         0       0 2019-02-19 00:00:00+00:00 2019-07-25 00:00:00+00:00
1         1       0 2019-08-08 00:00:00+00:00 2019-08-19 00:00:00+00:00
2         2       0 2019-11-01 00:00:00+00:00 2019-11-20 00:00:00+00:00

   Status
0  Closed
1  Closed
2  Closed

&gt;&gt;&gt; ranges.duration.max(wrap_kwargs=dict(to_timedelta=True))
Timedelta(&#39;74 days 00:00:00&#39;)
```

## From accessors

Moreover, all generic accessors have a property `ranges` and a method `get_ranges`:

```python-repl
&gt;&gt;&gt; # vectorbt.generic.accessors.GenericAccessor.ranges.coverage
&gt;&gt;&gt; fast_below_slow.vbt.ranges.coverage()
0.35792349726775957
```

## Stats

!!! hint
    See `vectorbt.generic.stats_builder.StatsBuilderMixin.stats` and `Ranges.metrics`.

```python-repl
&gt;&gt;&gt; df = pd.DataFrame({
...     &#39;a&#39;: [1, 2, np.nan, np.nan, 5, 6],
...     &#39;b&#39;: [np.nan, 2, np.nan, 4, np.nan, 6]
... })
&gt;&gt;&gt; ranges = df.vbt(freq=&#39;d&#39;).ranges

&gt;&gt;&gt; ranges[&#39;a&#39;].stats()
Start                             0
End                               5
Period              6 days 00:00:00
Total Records                     2
Coverage            4 days 00:00:00
Overlap Coverage    0 days 00:00:00
Duration: Min       2 days 00:00:00
Duration: Median    2 days 00:00:00
Duration: Max       2 days 00:00:00
Duration: Mean      2 days 00:00:00
Duration: Std       0 days 00:00:00
Name: a, dtype: object
```

`Ranges.stats` also supports (re-)grouping:

```python-repl
&gt;&gt;&gt; ranges.stats(group_by=True)
Start                                       0
End                                         5
Period                        6 days 00:00:00
Total Records                               5
Coverage                      5 days 00:00:00
Overlap Coverage              2 days 00:00:00
Duration: Min                 1 days 00:00:00
Duration: Median              1 days 00:00:00
Duration: Max                 2 days 00:00:00
Duration: Mean                1 days 09:36:00
Duration: Std       0 days 13:08:43.228968446
Name: group, dtype: object
```

## Plots

!!! hint
    See `vectorbt.generic.plots_builder.PlotsBuilderMixin.plots` and `Ranges.subplots`.

`Ranges` class has a single subplot based on `Ranges.plot`:

```python-repl
&gt;&gt;&gt; ranges[&#39;a&#39;].plots()
```

![](/docs/img/ranges_plots.svg)
&#34;&#34;&#34;

import numpy as np
import plotly.graph_objects as go

from vectorbt import _typing as tp
from vectorbt.base.array_wrapper import ArrayWrapper
from vectorbt.base.reshape_fns import to_pd_array, to_2d_array
from vectorbt.generic import nb
from vectorbt.generic.enums import RangeStatus, range_dt
from vectorbt.records.base import Records
from vectorbt.records.decorators import override_field_config, attach_fields
from vectorbt.records.mapped_array import MappedArray
from vectorbt.utils.colors import adjust_lightness
from vectorbt.utils.config import merge_dicts, Config
from vectorbt.utils.decorators import cached_property, cached_method
from vectorbt.utils.figure import make_figure, get_domain

__pdoc__ = {}

ranges_field_config = Config(
    dict(
        dtype=range_dt,
        settings=dict(
            id=dict(
                title=&#39;Range Id&#39;
            ),
            idx=dict(
                name=&#39;end_idx&#39;  # remap field of Records
            ),
            start_idx=dict(
                title=&#39;Start Timestamp&#39;,
                mapping=&#39;index&#39;
            ),
            end_idx=dict(
                title=&#39;End Timestamp&#39;,
                mapping=&#39;index&#39;
            ),
            status=dict(
                title=&#39;Status&#39;,
                mapping=RangeStatus
            )
        )
    ),
    readonly=True,
    as_attrs=False
)
&#34;&#34;&#34;_&#34;&#34;&#34;

__pdoc__[&#39;ranges_field_config&#39;] = f&#34;&#34;&#34;Field config for `Ranges`.

```json
{ranges_field_config.to_doc()}
```
&#34;&#34;&#34;

ranges_attach_field_config = Config(
    dict(
        status=dict(
            attach_filters=True
        )
    ),
    readonly=True,
    as_attrs=False
)
&#34;&#34;&#34;_&#34;&#34;&#34;

__pdoc__[&#39;ranges_attach_field_config&#39;] = f&#34;&#34;&#34;Config of fields to be attached to `Ranges`.

```json
{ranges_attach_field_config.to_doc()}
```
&#34;&#34;&#34;

RangesT = tp.TypeVar(&#34;RangesT&#34;, bound=&#34;Ranges&#34;)


@attach_fields(ranges_attach_field_config)
@override_field_config(ranges_field_config)
class Ranges(Records):
    &#34;&#34;&#34;Extends `Records` for working with range records.

    Requires `records_arr` to have all fields defined in `vectorbt.generic.enums.range_dt`.&#34;&#34;&#34;

    @property
    def field_config(self) -&gt; Config:
        return self._field_config

    def __init__(self,
                 wrapper: ArrayWrapper,
                 records_arr: tp.RecordArray,
                 ts: tp.Optional[tp.ArrayLike] = None,
                 **kwargs) -&gt; None:
        Records.__init__(
            self,
            wrapper,
            records_arr,
            ts=ts,
            **kwargs
        )
        self._ts = ts

    def indexing_func(self: RangesT, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; RangesT:
        &#34;&#34;&#34;Perform indexing on `Ranges`.&#34;&#34;&#34;
        new_wrapper, new_records_arr, _, col_idxs = \
            Records.indexing_func_meta(self, pd_indexing_func, **kwargs)
        if self.ts is not None:
            new_ts = new_wrapper.wrap(self.ts.values[:, col_idxs], group_by=False)
        else:
            new_ts = None
        return self.replace(
            wrapper=new_wrapper,
            records_arr=new_records_arr,
            ts=new_ts
        )

    @classmethod
    def from_ts(cls: tp.Type[RangesT],
                ts: tp.ArrayLike,
                gap_value: tp.Optional[tp.Scalar] = None,
                attach_ts: bool = True,
                wrapper_kwargs: tp.KwargsLike = None,
                **kwargs) -&gt; RangesT:
        &#34;&#34;&#34;Build `Ranges` from time series `ts`.

        Searches for sequences of

        * True values in boolean data (False acts as a gap),
        * positive values in integer data (-1 acts as a gap), and
        * non-NaN values in any other data (NaN acts as a gap).

        `**kwargs` will be passed to `Ranges.__init__`.&#34;&#34;&#34;
        if wrapper_kwargs is None:
            wrapper_kwargs = {}

        ts_pd = to_pd_array(ts)
        ts_arr = to_2d_array(ts_pd)
        if gap_value is None:
            if np.issubdtype(ts_arr.dtype, np.bool_):
                gap_value = False
            elif np.issubdtype(ts_arr.dtype, np.integer):
                gap_value = -1
            else:
                gap_value = np.nan
        records_arr = nb.find_ranges_nb(ts_arr, gap_value)
        wrapper = ArrayWrapper.from_obj(ts_pd, **wrapper_kwargs)
        return cls(wrapper, records_arr, ts=ts_pd if attach_ts else None, **kwargs)

    @property
    def ts(self) -&gt; tp.Optional[tp.SeriesFrame]:
        &#34;&#34;&#34;Original time series that records are built from (optional).&#34;&#34;&#34;
        return self._ts

    def to_mask(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Convert ranges to a mask.

        See `vectorbt.generic.nb.ranges_to_mask_nb`.&#34;&#34;&#34;
        col_map = self.col_mapper.get_col_map(group_by=group_by)
        mask = nb.ranges_to_mask_nb(
            self.get_field_arr(&#39;start_idx&#39;),
            self.get_field_arr(&#39;end_idx&#39;),
            self.get_field_arr(&#39;status&#39;),
            col_map,
            len(self.wrapper.index)
        )
        return self.wrapper.wrap(mask, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_property
    def duration(self) -&gt; MappedArray:
        &#34;&#34;&#34;Duration of each range (in raw format).&#34;&#34;&#34;
        duration = nb.range_duration_nb(
            self.get_field_arr(&#39;start_idx&#39;),
            self.get_field_arr(&#39;end_idx&#39;),
            self.get_field_arr(&#39;status&#39;)
        )
        return self.map_array(duration)

    @cached_method
    def avg_duration(self, group_by: tp.GroupByLike = None,
                     wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Average range duration (as timedelta).&#34;&#34;&#34;
        wrap_kwargs = merge_dicts(dict(to_timedelta=True, name_or_index=&#39;avg_duration&#39;), wrap_kwargs)
        return self.duration.mean(group_by=group_by, wrap_kwargs=wrap_kwargs, **kwargs)

    @cached_method
    def max_duration(self, group_by: tp.GroupByLike = None,
                     wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Maximum range duration (as timedelta).&#34;&#34;&#34;
        wrap_kwargs = merge_dicts(dict(to_timedelta=True, name_or_index=&#39;max_duration&#39;), wrap_kwargs)
        return self.duration.max(group_by=group_by, wrap_kwargs=wrap_kwargs, **kwargs)

    @cached_method
    def coverage(self,
                 overlapping: bool = False,
                 normalize: bool = True,
                 group_by: tp.GroupByLike = None,
                 wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Coverage, that is, the number of steps that are covered by all ranges.

        See `vectorbt.generic.nb.range_coverage_nb`.&#34;&#34;&#34;
        col_map = self.col_mapper.get_col_map(group_by=group_by)
        index_lens = self.wrapper.grouper.get_group_lens(group_by=group_by) * self.wrapper.shape[0]
        coverage = nb.range_coverage_nb(
            self.get_field_arr(&#39;start_idx&#39;),
            self.get_field_arr(&#39;end_idx&#39;),
            self.get_field_arr(&#39;status&#39;),
            col_map,
            index_lens,
            overlapping=overlapping,
            normalize=normalize
        )
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;coverage&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(coverage, group_by=group_by, **wrap_kwargs)

    # ############# Stats ############# #

    @property
    def stats_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `Ranges.stats`.

        Merges `vectorbt.records.base.Records.stats_defaults` and
        `ranges.stats` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        ranges_stats_cfg = settings[&#39;ranges&#39;][&#39;stats&#39;]

        return merge_dicts(
            Records.stats_defaults.__get__(self),
            ranges_stats_cfg
        )

    _metrics: tp.ClassVar[Config] = Config(
        dict(
            start=dict(
                title=&#39;Start&#39;,
                calc_func=lambda self: self.wrapper.index[0],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            end=dict(
                title=&#39;End&#39;,
                calc_func=lambda self: self.wrapper.index[-1],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            period=dict(
                title=&#39;Period&#39;,
                calc_func=lambda self: len(self.wrapper.index),
                apply_to_timedelta=True,
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            coverage=dict(
                title=&#39;Coverage&#39;,
                calc_func=&#39;coverage&#39;,
                overlapping=False,
                normalize=False,
                apply_to_timedelta=True,
                tags=[&#39;ranges&#39;, &#39;coverage&#39;]
            ),
            overlap_coverage=dict(
                title=&#39;Overlap Coverage&#39;,
                calc_func=&#39;coverage&#39;,
                overlapping=True,
                normalize=False,
                apply_to_timedelta=True,
                tags=[&#39;ranges&#39;, &#39;coverage&#39;]
            ),
            total_records=dict(
                title=&#39;Total Records&#39;,
                calc_func=&#39;count&#39;,
                tags=&#39;records&#39;
            ),
            duration=dict(
                title=&#39;Duration&#39;,
                calc_func=&#39;duration.describe&#39;,
                post_calc_func=lambda self, out, settings: {
                    &#39;Min&#39;: out.loc[&#39;min&#39;],
                    &#39;Median&#39;: out.loc[&#39;50%&#39;],
                    &#39;Max&#39;: out.loc[&#39;max&#39;],
                    &#39;Mean&#39;: out.loc[&#39;mean&#39;],
                    &#39;Std&#39;: out.loc[&#39;std&#39;]
                },
                apply_to_timedelta=True,
                tags=[&#39;ranges&#39;, &#39;duration&#39;]
            ),
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def metrics(self) -&gt; Config:
        return self._metrics

    # ############# Plotting ############# #

    def plot(self,
             column: tp.Optional[tp.Label] = None,
             top_n: int = 5,
             plot_zones: bool = True,
             ts_trace_kwargs: tp.KwargsLike = None,
             start_trace_kwargs: tp.KwargsLike = None,
             end_trace_kwargs: tp.KwargsLike = None,
             open_shape_kwargs: tp.KwargsLike = None,
             closed_shape_kwargs: tp.KwargsLike = None,
             add_trace_kwargs: tp.KwargsLike = None,
             xref: str = &#39;x&#39;,
             yref: str = &#39;y&#39;,
             fig: tp.Optional[tp.BaseFigure] = None,
             **layout_kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
        &#34;&#34;&#34;Plot ranges.

        Args:
            column (str): Name of the column to plot.
            top_n (int): Filter top N range records by maximum duration.
            plot_zones (bool): Whether to plot zones.
            ts_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `Ranges.ts`.
            start_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for start values.
            end_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for end values.
            open_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for open zones.
            closed_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for closed zones.
            add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            fig (Figure or FigureWidget): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.

        ## Example

        ```python-repl
        &gt;&gt;&gt; import vectorbt as vbt
        &gt;&gt;&gt; from datetime import datetime, timedelta
        &gt;&gt;&gt; import pandas as pd

        &gt;&gt;&gt; price = pd.Series([1, 2, 1, 2, 3, 2, 1, 2], name=&#39;Price&#39;)
        &gt;&gt;&gt; price.index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(len(price))]
        &gt;&gt;&gt; vbt.Ranges.from_ts(price &gt;= 2, wrapper_kwargs=dict(freq=&#39;1 day&#39;)).plot()
        ```

        ![](/docs/img/ranges_plot.svg)
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        self_col = self.select_one(column=column, group_by=False)
        if top_n is not None:
            self_col = self_col.apply_mask(self_col.duration.top_n_mask(top_n))

        if ts_trace_kwargs is None:
            ts_trace_kwargs = {}
        ts_trace_kwargs = merge_dicts(dict(
            line=dict(
                color=plotting_cfg[&#39;color_schema&#39;][&#39;blue&#39;]
            )
        ), ts_trace_kwargs)
        if start_trace_kwargs is None:
            start_trace_kwargs = {}
        if end_trace_kwargs is None:
            end_trace_kwargs = {}
        if open_shape_kwargs is None:
            open_shape_kwargs = {}
        if closed_shape_kwargs is None:
            closed_shape_kwargs = {}
        if add_trace_kwargs is None:
            add_trace_kwargs = {}

        if fig is None:
            fig = make_figure()
        fig.update_layout(**layout_kwargs)
        y_domain = get_domain(yref, fig)

        if self_col.ts is not None:
            fig = self_col.ts.vbt.plot(trace_kwargs=ts_trace_kwargs, add_trace_kwargs=add_trace_kwargs, fig=fig)

        if self_col.count() &gt; 0:
            # Extract information
            id_ = self_col.get_field_arr(&#39;id&#39;)
            id_title = self_col.get_field_title(&#39;id&#39;)

            start_idx = self_col.get_map_field_to_index(&#39;start_idx&#39;)
            start_idx_title = self_col.get_field_title(&#39;start_idx&#39;)
            if self_col.ts is not None:
                start_val = self_col.ts.loc[start_idx]
            else:
                start_val = np.full(len(start_idx), 0)

            end_idx = self_col.get_map_field_to_index(&#39;end_idx&#39;)
            end_idx_title = self_col.get_field_title(&#39;end_idx&#39;)
            if self_col.ts is not None:
                end_val = self_col.ts.loc[end_idx]
            else:
                end_val = np.full(len(end_idx), 0)

            duration = np.vectorize(str)(self_col.wrapper.to_timedelta(
                self_col.duration.values, to_pd=True, silence_warnings=True))

            status = self_col.get_field_arr(&#39;status&#39;)

            # Plot start markers
            start_customdata = id_[:, None]
            start_scatter = go.Scatter(
                x=start_idx,
                y=start_val,
                mode=&#39;markers&#39;,
                marker=dict(
                    symbol=&#39;diamond&#39;,
                    color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;blue&#39;],
                    size=7,
                    line=dict(
                        width=1,
                        color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;blue&#39;])
                    )
                ),
                name=&#39;Start&#39;,
                customdata=start_customdata,
                hovertemplate=f&#34;{id_title}: %{{customdata[0]}}&#34;
                              f&#34;&lt;br&gt;{start_idx_title}: %{{x}}&#34;
            )
            start_scatter.update(**start_trace_kwargs)
            fig.add_trace(start_scatter, **add_trace_kwargs)

            closed_mask = status == RangeStatus.Closed
            if closed_mask.any():
                # Plot end markers
                closed_end_customdata = np.stack((
                    id_[closed_mask],
                    duration[closed_mask]
                ), axis=1)
                closed_end_scatter = go.Scatter(
                    x=end_idx[closed_mask],
                    y=end_val[closed_mask],
                    mode=&#39;markers&#39;,
                    marker=dict(
                        symbol=&#39;diamond&#39;,
                        color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;green&#39;],
                        size=7,
                        line=dict(
                            width=1,
                            color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;green&#39;])
                        )
                    ),
                    name=&#39;Closed&#39;,
                    customdata=closed_end_customdata,
                    hovertemplate=f&#34;{id_title}: %{{customdata[0]}}&#34;
                                  f&#34;&lt;br&gt;{end_idx_title}: %{{x}}&#34;
                                  f&#34;&lt;br&gt;Duration: %{{customdata[1]}}&#34;
                )
                closed_end_scatter.update(**end_trace_kwargs)
                fig.add_trace(closed_end_scatter, **add_trace_kwargs)

                if plot_zones:
                    # Plot closed range zones
                    for i in range(len(id_[closed_mask])):
                        fig.add_shape(**merge_dicts(dict(
                            type=&#34;rect&#34;,
                            xref=xref,
                            yref=&#34;paper&#34;,
                            x0=start_idx[closed_mask][i],
                            y0=y_domain[0],
                            x1=end_idx[closed_mask][i],
                            y1=y_domain[1],
                            fillcolor=&#39;teal&#39;,
                            opacity=0.2,
                            layer=&#34;below&#34;,
                            line_width=0,
                        ), closed_shape_kwargs))

            open_mask = status == RangeStatus.Open
            if open_mask.any():
                # Plot end markers
                open_end_customdata = np.stack((
                    id_[open_mask],
                    duration[open_mask]
                ), axis=1)
                open_end_scatter = go.Scatter(
                    x=end_idx[open_mask],
                    y=end_val[open_mask],
                    mode=&#39;markers&#39;,
                    marker=dict(
                        symbol=&#39;diamond&#39;,
                        color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;orange&#39;],
                        size=7,
                        line=dict(
                            width=1,
                            color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;orange&#39;])
                        )
                    ),
                    name=&#39;Open&#39;,
                    customdata=open_end_customdata,
                    hovertemplate=f&#34;{id_title}: %{{customdata[0]}}&#34;
                                  f&#34;&lt;br&gt;{end_idx_title}: %{{x}}&#34;
                                  f&#34;&lt;br&gt;Duration: %{{customdata[1]}}&#34;
                )
                open_end_scatter.update(**end_trace_kwargs)
                fig.add_trace(open_end_scatter, **add_trace_kwargs)

                if plot_zones:
                    # Plot open range zones
                    for i in range(len(id_[open_mask])):
                        fig.add_shape(**merge_dicts(dict(
                            type=&#34;rect&#34;,
                            xref=xref,
                            yref=&#34;paper&#34;,
                            x0=start_idx[open_mask][i],
                            y0=y_domain[0],
                            x1=end_idx[open_mask][i],
                            y1=y_domain[1],
                            fillcolor=&#39;orange&#39;,
                            opacity=0.2,
                            layer=&#34;below&#34;,
                            line_width=0,
                        ), open_shape_kwargs))

        return fig

    @property
    def plots_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `Ranges.plots`.

        Merges `vectorbt.records.base.Records.plots_defaults` and
        `ranges.plots` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        ranges_plots_cfg = settings[&#39;ranges&#39;][&#39;plots&#39;]

        return merge_dicts(
            Records.plots_defaults.__get__(self),
            ranges_plots_cfg
        )

    _subplots: tp.ClassVar[Config] = Config(
        dict(
            plot=dict(
                title=&#34;Ranges&#34;,
                check_is_not_grouped=True,
                plot_func=&#39;plot&#39;,
                tags=&#39;ranges&#39;
            )
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def subplots(self) -&gt; Config:
        return self._subplots


Ranges.override_field_config_doc(__pdoc__)
Ranges.override_metrics_doc(__pdoc__)
Ranges.override_subplots_doc(__pdoc__)</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="vectorbt.generic.ranges.ranges_attach_field_config"><code class="name">var <span class="ident parent-name">ranges_attach_field_config</span></code></dt>
<dd>
<div class="desc"><p>Config of fields to be attached to <code><a title="vectorbt.generic.ranges.Ranges" href="#vectorbt.generic.ranges.Ranges">Ranges</a></code>.</p>
<pre><code class="language-json">Config({
    &quot;status&quot;: {
        &quot;attach_filters&quot;: true
    }
})
</code></pre></div>
</dd>
<dt id="vectorbt.generic.ranges.ranges_field_config"><code class="name">var <span class="ident parent-name">ranges_field_config</span></code></dt>
<dd>
<div class="desc"><p>Field config for <code><a title="vectorbt.generic.ranges.Ranges" href="#vectorbt.generic.ranges.Ranges">Ranges</a></code>.</p>
<pre><code class="language-json">Config({
    &quot;dtype&quot;: {
        &quot;id&quot;: &quot;int64&quot;,
        &quot;col&quot;: &quot;int64&quot;,
        &quot;start_idx&quot;: &quot;int64&quot;,
        &quot;end_idx&quot;: &quot;int64&quot;,
        &quot;status&quot;: &quot;int64&quot;
    },
    &quot;settings&quot;: {
        &quot;id&quot;: {
            &quot;title&quot;: &quot;Range Id&quot;
        },
        &quot;idx&quot;: {
            &quot;name&quot;: &quot;end_idx&quot;
        },
        &quot;start_idx&quot;: {
            &quot;title&quot;: &quot;Start Timestamp&quot;,
            &quot;mapping&quot;: &quot;index&quot;
        },
        &quot;end_idx&quot;: {
            &quot;title&quot;: &quot;End Timestamp&quot;,
            &quot;mapping&quot;: &quot;index&quot;
        },
        &quot;status&quot;: {
            &quot;title&quot;: &quot;Status&quot;,
            &quot;mapping&quot;: {
                &quot;Open&quot;: 0,
                &quot;Closed&quot;: 1
            }
        }
    }
})
</code></pre></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.generic.ranges.Ranges"><code class="flex name class">
<span>class <span class="ident parent-name">Ranges</span></span>
(<span class="params">wrapper, records_arr, ts=None, **kwargs</span>)
</code></dt>
<dd>
<div class="desc"><p>Extends <code>Records</code> for working with range records.</p>
<p>Requires <code>records_arr</code> to have all fields defined in <code><a title="vectorbt.generic.enums.range_dt" href="enums.html#vectorbt.generic.enums.range_dt">range_dt</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Ranges(Records):
    &#34;&#34;&#34;Extends `Records` for working with range records.

    Requires `records_arr` to have all fields defined in `vectorbt.generic.enums.range_dt`.&#34;&#34;&#34;

    @property
    def field_config(self) -&gt; Config:
        return self._field_config

    def __init__(self,
                 wrapper: ArrayWrapper,
                 records_arr: tp.RecordArray,
                 ts: tp.Optional[tp.ArrayLike] = None,
                 **kwargs) -&gt; None:
        Records.__init__(
            self,
            wrapper,
            records_arr,
            ts=ts,
            **kwargs
        )
        self._ts = ts

    def indexing_func(self: RangesT, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; RangesT:
        &#34;&#34;&#34;Perform indexing on `Ranges`.&#34;&#34;&#34;
        new_wrapper, new_records_arr, _, col_idxs = \
            Records.indexing_func_meta(self, pd_indexing_func, **kwargs)
        if self.ts is not None:
            new_ts = new_wrapper.wrap(self.ts.values[:, col_idxs], group_by=False)
        else:
            new_ts = None
        return self.replace(
            wrapper=new_wrapper,
            records_arr=new_records_arr,
            ts=new_ts
        )

    @classmethod
    def from_ts(cls: tp.Type[RangesT],
                ts: tp.ArrayLike,
                gap_value: tp.Optional[tp.Scalar] = None,
                attach_ts: bool = True,
                wrapper_kwargs: tp.KwargsLike = None,
                **kwargs) -&gt; RangesT:
        &#34;&#34;&#34;Build `Ranges` from time series `ts`.

        Searches for sequences of

        * True values in boolean data (False acts as a gap),
        * positive values in integer data (-1 acts as a gap), and
        * non-NaN values in any other data (NaN acts as a gap).

        `**kwargs` will be passed to `Ranges.__init__`.&#34;&#34;&#34;
        if wrapper_kwargs is None:
            wrapper_kwargs = {}

        ts_pd = to_pd_array(ts)
        ts_arr = to_2d_array(ts_pd)
        if gap_value is None:
            if np.issubdtype(ts_arr.dtype, np.bool_):
                gap_value = False
            elif np.issubdtype(ts_arr.dtype, np.integer):
                gap_value = -1
            else:
                gap_value = np.nan
        records_arr = nb.find_ranges_nb(ts_arr, gap_value)
        wrapper = ArrayWrapper.from_obj(ts_pd, **wrapper_kwargs)
        return cls(wrapper, records_arr, ts=ts_pd if attach_ts else None, **kwargs)

    @property
    def ts(self) -&gt; tp.Optional[tp.SeriesFrame]:
        &#34;&#34;&#34;Original time series that records are built from (optional).&#34;&#34;&#34;
        return self._ts

    def to_mask(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
        &#34;&#34;&#34;Convert ranges to a mask.

        See `vectorbt.generic.nb.ranges_to_mask_nb`.&#34;&#34;&#34;
        col_map = self.col_mapper.get_col_map(group_by=group_by)
        mask = nb.ranges_to_mask_nb(
            self.get_field_arr(&#39;start_idx&#39;),
            self.get_field_arr(&#39;end_idx&#39;),
            self.get_field_arr(&#39;status&#39;),
            col_map,
            len(self.wrapper.index)
        )
        return self.wrapper.wrap(mask, group_by=group_by, **merge_dicts({}, wrap_kwargs))

    @cached_property
    def duration(self) -&gt; MappedArray:
        &#34;&#34;&#34;Duration of each range (in raw format).&#34;&#34;&#34;
        duration = nb.range_duration_nb(
            self.get_field_arr(&#39;start_idx&#39;),
            self.get_field_arr(&#39;end_idx&#39;),
            self.get_field_arr(&#39;status&#39;)
        )
        return self.map_array(duration)

    @cached_method
    def avg_duration(self, group_by: tp.GroupByLike = None,
                     wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Average range duration (as timedelta).&#34;&#34;&#34;
        wrap_kwargs = merge_dicts(dict(to_timedelta=True, name_or_index=&#39;avg_duration&#39;), wrap_kwargs)
        return self.duration.mean(group_by=group_by, wrap_kwargs=wrap_kwargs, **kwargs)

    @cached_method
    def max_duration(self, group_by: tp.GroupByLike = None,
                     wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Maximum range duration (as timedelta).&#34;&#34;&#34;
        wrap_kwargs = merge_dicts(dict(to_timedelta=True, name_or_index=&#39;max_duration&#39;), wrap_kwargs)
        return self.duration.max(group_by=group_by, wrap_kwargs=wrap_kwargs, **kwargs)

    @cached_method
    def coverage(self,
                 overlapping: bool = False,
                 normalize: bool = True,
                 group_by: tp.GroupByLike = None,
                 wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
        &#34;&#34;&#34;Coverage, that is, the number of steps that are covered by all ranges.

        See `vectorbt.generic.nb.range_coverage_nb`.&#34;&#34;&#34;
        col_map = self.col_mapper.get_col_map(group_by=group_by)
        index_lens = self.wrapper.grouper.get_group_lens(group_by=group_by) * self.wrapper.shape[0]
        coverage = nb.range_coverage_nb(
            self.get_field_arr(&#39;start_idx&#39;),
            self.get_field_arr(&#39;end_idx&#39;),
            self.get_field_arr(&#39;status&#39;),
            col_map,
            index_lens,
            overlapping=overlapping,
            normalize=normalize
        )
        wrap_kwargs = merge_dicts(dict(name_or_index=&#39;coverage&#39;), wrap_kwargs)
        return self.wrapper.wrap_reduced(coverage, group_by=group_by, **wrap_kwargs)

    # ############# Stats ############# #

    @property
    def stats_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `Ranges.stats`.

        Merges `vectorbt.records.base.Records.stats_defaults` and
        `ranges.stats` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        ranges_stats_cfg = settings[&#39;ranges&#39;][&#39;stats&#39;]

        return merge_dicts(
            Records.stats_defaults.__get__(self),
            ranges_stats_cfg
        )

    _metrics: tp.ClassVar[Config] = Config(
        dict(
            start=dict(
                title=&#39;Start&#39;,
                calc_func=lambda self: self.wrapper.index[0],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            end=dict(
                title=&#39;End&#39;,
                calc_func=lambda self: self.wrapper.index[-1],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            period=dict(
                title=&#39;Period&#39;,
                calc_func=lambda self: len(self.wrapper.index),
                apply_to_timedelta=True,
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            coverage=dict(
                title=&#39;Coverage&#39;,
                calc_func=&#39;coverage&#39;,
                overlapping=False,
                normalize=False,
                apply_to_timedelta=True,
                tags=[&#39;ranges&#39;, &#39;coverage&#39;]
            ),
            overlap_coverage=dict(
                title=&#39;Overlap Coverage&#39;,
                calc_func=&#39;coverage&#39;,
                overlapping=True,
                normalize=False,
                apply_to_timedelta=True,
                tags=[&#39;ranges&#39;, &#39;coverage&#39;]
            ),
            total_records=dict(
                title=&#39;Total Records&#39;,
                calc_func=&#39;count&#39;,
                tags=&#39;records&#39;
            ),
            duration=dict(
                title=&#39;Duration&#39;,
                calc_func=&#39;duration.describe&#39;,
                post_calc_func=lambda self, out, settings: {
                    &#39;Min&#39;: out.loc[&#39;min&#39;],
                    &#39;Median&#39;: out.loc[&#39;50%&#39;],
                    &#39;Max&#39;: out.loc[&#39;max&#39;],
                    &#39;Mean&#39;: out.loc[&#39;mean&#39;],
                    &#39;Std&#39;: out.loc[&#39;std&#39;]
                },
                apply_to_timedelta=True,
                tags=[&#39;ranges&#39;, &#39;duration&#39;]
            ),
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def metrics(self) -&gt; Config:
        return self._metrics

    # ############# Plotting ############# #

    def plot(self,
             column: tp.Optional[tp.Label] = None,
             top_n: int = 5,
             plot_zones: bool = True,
             ts_trace_kwargs: tp.KwargsLike = None,
             start_trace_kwargs: tp.KwargsLike = None,
             end_trace_kwargs: tp.KwargsLike = None,
             open_shape_kwargs: tp.KwargsLike = None,
             closed_shape_kwargs: tp.KwargsLike = None,
             add_trace_kwargs: tp.KwargsLike = None,
             xref: str = &#39;x&#39;,
             yref: str = &#39;y&#39;,
             fig: tp.Optional[tp.BaseFigure] = None,
             **layout_kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
        &#34;&#34;&#34;Plot ranges.

        Args:
            column (str): Name of the column to plot.
            top_n (int): Filter top N range records by maximum duration.
            plot_zones (bool): Whether to plot zones.
            ts_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `Ranges.ts`.
            start_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for start values.
            end_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for end values.
            open_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for open zones.
            closed_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for closed zones.
            add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
            xref (str): X coordinate axis.
            yref (str): Y coordinate axis.
            fig (Figure or FigureWidget): Figure to add traces to.
            **layout_kwargs: Keyword arguments for layout.

        ## Example

        ```python-repl
        &gt;&gt;&gt; import vectorbt as vbt
        &gt;&gt;&gt; from datetime import datetime, timedelta
        &gt;&gt;&gt; import pandas as pd

        &gt;&gt;&gt; price = pd.Series([1, 2, 1, 2, 3, 2, 1, 2], name=&#39;Price&#39;)
        &gt;&gt;&gt; price.index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(len(price))]
        &gt;&gt;&gt; vbt.Ranges.from_ts(price &gt;= 2, wrapper_kwargs=dict(freq=&#39;1 day&#39;)).plot()
        ```

        ![](/docs/img/ranges_plot.svg)
        &#34;&#34;&#34;
        from vectorbt._settings import settings
        plotting_cfg = settings[&#39;plotting&#39;]

        self_col = self.select_one(column=column, group_by=False)
        if top_n is not None:
            self_col = self_col.apply_mask(self_col.duration.top_n_mask(top_n))

        if ts_trace_kwargs is None:
            ts_trace_kwargs = {}
        ts_trace_kwargs = merge_dicts(dict(
            line=dict(
                color=plotting_cfg[&#39;color_schema&#39;][&#39;blue&#39;]
            )
        ), ts_trace_kwargs)
        if start_trace_kwargs is None:
            start_trace_kwargs = {}
        if end_trace_kwargs is None:
            end_trace_kwargs = {}
        if open_shape_kwargs is None:
            open_shape_kwargs = {}
        if closed_shape_kwargs is None:
            closed_shape_kwargs = {}
        if add_trace_kwargs is None:
            add_trace_kwargs = {}

        if fig is None:
            fig = make_figure()
        fig.update_layout(**layout_kwargs)
        y_domain = get_domain(yref, fig)

        if self_col.ts is not None:
            fig = self_col.ts.vbt.plot(trace_kwargs=ts_trace_kwargs, add_trace_kwargs=add_trace_kwargs, fig=fig)

        if self_col.count() &gt; 0:
            # Extract information
            id_ = self_col.get_field_arr(&#39;id&#39;)
            id_title = self_col.get_field_title(&#39;id&#39;)

            start_idx = self_col.get_map_field_to_index(&#39;start_idx&#39;)
            start_idx_title = self_col.get_field_title(&#39;start_idx&#39;)
            if self_col.ts is not None:
                start_val = self_col.ts.loc[start_idx]
            else:
                start_val = np.full(len(start_idx), 0)

            end_idx = self_col.get_map_field_to_index(&#39;end_idx&#39;)
            end_idx_title = self_col.get_field_title(&#39;end_idx&#39;)
            if self_col.ts is not None:
                end_val = self_col.ts.loc[end_idx]
            else:
                end_val = np.full(len(end_idx), 0)

            duration = np.vectorize(str)(self_col.wrapper.to_timedelta(
                self_col.duration.values, to_pd=True, silence_warnings=True))

            status = self_col.get_field_arr(&#39;status&#39;)

            # Plot start markers
            start_customdata = id_[:, None]
            start_scatter = go.Scatter(
                x=start_idx,
                y=start_val,
                mode=&#39;markers&#39;,
                marker=dict(
                    symbol=&#39;diamond&#39;,
                    color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;blue&#39;],
                    size=7,
                    line=dict(
                        width=1,
                        color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;blue&#39;])
                    )
                ),
                name=&#39;Start&#39;,
                customdata=start_customdata,
                hovertemplate=f&#34;{id_title}: %{{customdata[0]}}&#34;
                              f&#34;&lt;br&gt;{start_idx_title}: %{{x}}&#34;
            )
            start_scatter.update(**start_trace_kwargs)
            fig.add_trace(start_scatter, **add_trace_kwargs)

            closed_mask = status == RangeStatus.Closed
            if closed_mask.any():
                # Plot end markers
                closed_end_customdata = np.stack((
                    id_[closed_mask],
                    duration[closed_mask]
                ), axis=1)
                closed_end_scatter = go.Scatter(
                    x=end_idx[closed_mask],
                    y=end_val[closed_mask],
                    mode=&#39;markers&#39;,
                    marker=dict(
                        symbol=&#39;diamond&#39;,
                        color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;green&#39;],
                        size=7,
                        line=dict(
                            width=1,
                            color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;green&#39;])
                        )
                    ),
                    name=&#39;Closed&#39;,
                    customdata=closed_end_customdata,
                    hovertemplate=f&#34;{id_title}: %{{customdata[0]}}&#34;
                                  f&#34;&lt;br&gt;{end_idx_title}: %{{x}}&#34;
                                  f&#34;&lt;br&gt;Duration: %{{customdata[1]}}&#34;
                )
                closed_end_scatter.update(**end_trace_kwargs)
                fig.add_trace(closed_end_scatter, **add_trace_kwargs)

                if plot_zones:
                    # Plot closed range zones
                    for i in range(len(id_[closed_mask])):
                        fig.add_shape(**merge_dicts(dict(
                            type=&#34;rect&#34;,
                            xref=xref,
                            yref=&#34;paper&#34;,
                            x0=start_idx[closed_mask][i],
                            y0=y_domain[0],
                            x1=end_idx[closed_mask][i],
                            y1=y_domain[1],
                            fillcolor=&#39;teal&#39;,
                            opacity=0.2,
                            layer=&#34;below&#34;,
                            line_width=0,
                        ), closed_shape_kwargs))

            open_mask = status == RangeStatus.Open
            if open_mask.any():
                # Plot end markers
                open_end_customdata = np.stack((
                    id_[open_mask],
                    duration[open_mask]
                ), axis=1)
                open_end_scatter = go.Scatter(
                    x=end_idx[open_mask],
                    y=end_val[open_mask],
                    mode=&#39;markers&#39;,
                    marker=dict(
                        symbol=&#39;diamond&#39;,
                        color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;orange&#39;],
                        size=7,
                        line=dict(
                            width=1,
                            color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;orange&#39;])
                        )
                    ),
                    name=&#39;Open&#39;,
                    customdata=open_end_customdata,
                    hovertemplate=f&#34;{id_title}: %{{customdata[0]}}&#34;
                                  f&#34;&lt;br&gt;{end_idx_title}: %{{x}}&#34;
                                  f&#34;&lt;br&gt;Duration: %{{customdata[1]}}&#34;
                )
                open_end_scatter.update(**end_trace_kwargs)
                fig.add_trace(open_end_scatter, **add_trace_kwargs)

                if plot_zones:
                    # Plot open range zones
                    for i in range(len(id_[open_mask])):
                        fig.add_shape(**merge_dicts(dict(
                            type=&#34;rect&#34;,
                            xref=xref,
                            yref=&#34;paper&#34;,
                            x0=start_idx[open_mask][i],
                            y0=y_domain[0],
                            x1=end_idx[open_mask][i],
                            y1=y_domain[1],
                            fillcolor=&#39;orange&#39;,
                            opacity=0.2,
                            layer=&#34;below&#34;,
                            line_width=0,
                        ), open_shape_kwargs))

        return fig

    @property
    def plots_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `Ranges.plots`.

        Merges `vectorbt.records.base.Records.plots_defaults` and
        `ranges.plots` from `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        ranges_plots_cfg = settings[&#39;ranges&#39;][&#39;plots&#39;]

        return merge_dicts(
            Records.plots_defaults.__get__(self),
            ranges_plots_cfg
        )

    _subplots: tp.ClassVar[Config] = Config(
        dict(
            plot=dict(
                title=&#34;Ranges&#34;,
                check_is_not_grouped=True,
                plot_func=&#39;plot&#39;,
                tags=&#39;ranges&#39;
            )
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def subplots(self) -&gt; Config:
        return self._subplots</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.records.base.Records" href="../records/base.html#vectorbt.records.base.Records">Records</a></li>
<li><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></li>
<li><a title="vectorbt.utils.config.Configured" href="../utils/config.html#vectorbt.utils.config.Configured">Configured</a></li>
<li><a title="vectorbt.utils.config.Pickleable" href="../utils/config.html#vectorbt.utils.config.Pickleable">Pickleable</a></li>
<li><a title="vectorbt.utils.docs.Documented" href="../utils/docs.html#vectorbt.utils.docs.Documented">Documented</a></li>
<li><a title="vectorbt.base.indexing.PandasIndexer" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer">PandasIndexer</a></li>
<li><a title="vectorbt.base.indexing.IndexingBase" href="../base/indexing.html#vectorbt.base.indexing.IndexingBase">IndexingBase</a></li>
<li><a title="vectorbt.utils.attr_.AttrResolver" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver">AttrResolver</a></li>
<li><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></li>
<li><a title="vectorbt.generic.plots_builder.PlotsBuilderMixin" href="plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin">PlotsBuilderMixin</a></li>
<li><a title="vectorbt.records.base.RecordsWithFields" href="../records/base.html#vectorbt.records.base.RecordsWithFields">RecordsWithFields</a></li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.generic.drawdowns.Drawdowns" href="drawdowns.html#vectorbt.generic.drawdowns.Drawdowns">Drawdowns</a></li>
<li><a title="vectorbt.portfolio.trades.Trades" href="../portfolio/trades.html#vectorbt.portfolio.trades.Trades">Trades</a></li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.generic.ranges.Ranges.field_config"><code class="name">var <span class="ident child-name">field_config</span></code></dt>
<dd>
<div class="desc"><p>Field config of <code><a title="vectorbt.generic.ranges.Ranges" href="#vectorbt.generic.ranges.Ranges">Ranges</a></code>.</p>
<pre><code class="language-json">Config({
    &quot;dtype&quot;: {
        &quot;id&quot;: &quot;int64&quot;,
        &quot;col&quot;: &quot;int64&quot;,
        &quot;start_idx&quot;: &quot;int64&quot;,
        &quot;end_idx&quot;: &quot;int64&quot;,
        &quot;status&quot;: &quot;int64&quot;
    },
    &quot;settings&quot;: {
        &quot;id&quot;: {
            &quot;name&quot;: &quot;id&quot;,
            &quot;title&quot;: &quot;Range Id&quot;
        },
        &quot;col&quot;: {
            &quot;name&quot;: &quot;col&quot;,
            &quot;title&quot;: &quot;Column&quot;,
            &quot;mapping&quot;: &quot;columns&quot;
        },
        &quot;idx&quot;: {
            &quot;name&quot;: &quot;end_idx&quot;,
            &quot;title&quot;: &quot;Timestamp&quot;,
            &quot;mapping&quot;: &quot;index&quot;
        },
        &quot;start_idx&quot;: {
            &quot;title&quot;: &quot;Start Timestamp&quot;,
            &quot;mapping&quot;: &quot;index&quot;
        },
        &quot;end_idx&quot;: {
            &quot;title&quot;: &quot;End Timestamp&quot;,
            &quot;mapping&quot;: &quot;index&quot;
        },
        &quot;status&quot;: {
            &quot;title&quot;: &quot;Status&quot;,
            &quot;mapping&quot;: {
                &quot;Open&quot;: 0,
                &quot;Closed&quot;: 1
            }
        }
    }
})
</code></pre></div>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.metrics"><code class="name">var <span class="ident child-name">metrics</span></code></dt>
<dd>
<div class="desc"><p>Metrics supported by <code><a title="vectorbt.generic.ranges.Ranges" href="#vectorbt.generic.ranges.Ranges">Ranges</a></code>.</p>
<pre><code class="language-json">Config({
    &quot;start&quot;: {
        &quot;title&quot;: &quot;Start&quot;,
        &quot;calc_func&quot;: &quot;&lt;function Ranges.&lt;lambda&gt; at 0x7f06a07d2a60&gt;&quot;,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    },
    &quot;end&quot;: {
        &quot;title&quot;: &quot;End&quot;,
        &quot;calc_func&quot;: &quot;&lt;function Ranges.&lt;lambda&gt; at 0x7f06a07d2ae8&gt;&quot;,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    },
    &quot;period&quot;: {
        &quot;title&quot;: &quot;Period&quot;,
        &quot;calc_func&quot;: &quot;&lt;function Ranges.&lt;lambda&gt; at 0x7f06a07d2b70&gt;&quot;,
        &quot;apply_to_timedelta&quot;: true,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    },
    &quot;coverage&quot;: {
        &quot;title&quot;: &quot;Coverage&quot;,
        &quot;calc_func&quot;: &quot;coverage&quot;,
        &quot;overlapping&quot;: false,
        &quot;normalize&quot;: false,
        &quot;apply_to_timedelta&quot;: true,
        &quot;tags&quot;: [
            &quot;ranges&quot;,
            &quot;coverage&quot;
        ]
    },
    &quot;overlap_coverage&quot;: {
        &quot;title&quot;: &quot;Overlap Coverage&quot;,
        &quot;calc_func&quot;: &quot;coverage&quot;,
        &quot;overlapping&quot;: true,
        &quot;normalize&quot;: false,
        &quot;apply_to_timedelta&quot;: true,
        &quot;tags&quot;: [
            &quot;ranges&quot;,
            &quot;coverage&quot;
        ]
    },
    &quot;total_records&quot;: {
        &quot;title&quot;: &quot;Total Records&quot;,
        &quot;calc_func&quot;: &quot;count&quot;,
        &quot;tags&quot;: &quot;records&quot;
    },
    &quot;duration&quot;: {
        &quot;title&quot;: &quot;Duration&quot;,
        &quot;calc_func&quot;: &quot;duration.describe&quot;,
        &quot;post_calc_func&quot;: &quot;&lt;function Ranges.&lt;lambda&gt; at 0x7f06a07d1d08&gt;&quot;,
        &quot;apply_to_timedelta&quot;: true,
        &quot;tags&quot;: [
            &quot;ranges&quot;,
            &quot;duration&quot;
        ]
    }
})
</code></pre>
<p>Returns <code>Ranges._metrics</code>, which gets (deep) copied upon creation of each instance.
Thus, changing this config won't affect the class.</p>
<p>To change metrics, you can either change the config in-place, override this property,
or overwrite the instance variable <code>Ranges._metrics</code>.</p></div>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.subplots"><code class="name">var <span class="ident child-name">subplots</span></code></dt>
<dd>
<div class="desc"><p>Subplots supported by <code><a title="vectorbt.generic.ranges.Ranges" href="#vectorbt.generic.ranges.Ranges">Ranges</a></code>.</p>
<pre><code class="language-json">Config({
    &quot;plot&quot;: {
        &quot;title&quot;: &quot;Ranges&quot;,
        &quot;check_is_not_grouped&quot;: true,
        &quot;plot_func&quot;: &quot;plot&quot;,
        &quot;tags&quot;: &quot;ranges&quot;
    }
})
</code></pre>
<p>Returns <code>Ranges._subplots</code>, which gets (deep) copied upon creation of each instance.
Thus, changing this config won't affect the class.</p>
<p>To change subplots, you can either change the config in-place, override this property,
or overwrite the instance variable <code>Ranges._subplots</code>.</p></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.generic.ranges.Ranges.from_ts"><code class="name flex">
<span>def <span class="ident child-name">from_ts</span></span>(<span class="params">ts, gap_value=None, attach_ts=True, wrapper_kwargs=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Build <code><a title="vectorbt.generic.ranges.Ranges" href="#vectorbt.generic.ranges.Ranges">Ranges</a></code> from time series <code>ts</code>.</p>
<p>Searches for sequences of</p>
<ul>
<li>True values in boolean data (False acts as a gap),</li>
<li>positive values in integer data (-1 acts as a gap), and</li>
<li>non-NaN values in any other data (NaN acts as a gap).</li>
</ul>
<p><code>**kwargs</code> will be passed to <code><a title="vectorbt.generic.ranges.Ranges" href="#vectorbt.generic.ranges.Ranges">Ranges</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_ts(cls: tp.Type[RangesT],
            ts: tp.ArrayLike,
            gap_value: tp.Optional[tp.Scalar] = None,
            attach_ts: bool = True,
            wrapper_kwargs: tp.KwargsLike = None,
            **kwargs) -&gt; RangesT:
    &#34;&#34;&#34;Build `Ranges` from time series `ts`.

    Searches for sequences of

    * True values in boolean data (False acts as a gap),
    * positive values in integer data (-1 acts as a gap), and
    * non-NaN values in any other data (NaN acts as a gap).

    `**kwargs` will be passed to `Ranges.__init__`.&#34;&#34;&#34;
    if wrapper_kwargs is None:
        wrapper_kwargs = {}

    ts_pd = to_pd_array(ts)
    ts_arr = to_2d_array(ts_pd)
    if gap_value is None:
        if np.issubdtype(ts_arr.dtype, np.bool_):
            gap_value = False
        elif np.issubdtype(ts_arr.dtype, np.integer):
            gap_value = -1
        else:
            gap_value = np.nan
    records_arr = nb.find_ranges_nb(ts_arr, gap_value)
    wrapper = ArrayWrapper.from_obj(ts_pd, **wrapper_kwargs)
    return cls(wrapper, records_arr, ts=ts_pd if attach_ts else None, **kwargs)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.generic.ranges.Ranges.closed"><code class="name">var <span class="ident child-name">closed</span></code></dt>
<dd>
<div class="desc"><p>Records filtered by <code>status == 1</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.col"><code class="name">var <span class="ident child-name">col</span></code></dt>
<dd>
<div class="desc"><p>Mapped array of the field <code>col</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.duration"><code class="name">var <span class="ident child-name">duration</span></code></dt>
<dd>
<div class="desc"><p>Duration of each range (in raw format).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.end_idx"><code class="name">var <span class="ident child-name">end_idx</span></code></dt>
<dd>
<div class="desc"><p>Mapped array of the field <code>end_idx</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.id"><code class="name">var <span class="ident child-name">id</span></code></dt>
<dd>
<div class="desc"><p>Mapped array of the field <code>id</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.open"><code class="name">var <span class="ident child-name">open</span></code></dt>
<dd>
<div class="desc"><p>Records filtered by <code>status == 0</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.plots_defaults"><code class="name">var <span class="ident child-name">plots_defaults</span></code></dt>
<dd>
<div class="desc"><p>Defaults for <code><a title="vectorbt.generic.ranges.Ranges.plots" href="plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">PlotsBuilderMixin.plots()</a></code>.</p>
<p>Merges <code><a title="vectorbt.records.base.Records.plots_defaults" href="../records/base.html#vectorbt.records.base.Records.plots_defaults">Records.plots_defaults</a></code> and
<code>ranges.plots</code> from <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def plots_defaults(self) -&gt; tp.Kwargs:
    &#34;&#34;&#34;Defaults for `Ranges.plots`.

    Merges `vectorbt.records.base.Records.plots_defaults` and
    `ranges.plots` from `vectorbt._settings.settings`.&#34;&#34;&#34;
    from vectorbt._settings import settings
    ranges_plots_cfg = settings[&#39;ranges&#39;][&#39;plots&#39;]

    return merge_dicts(
        Records.plots_defaults.__get__(self),
        ranges_plots_cfg
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.start_idx"><code class="name">var <span class="ident child-name">start_idx</span></code></dt>
<dd>
<div class="desc"><p>Mapped array of the field <code>start_idx</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.stats_defaults"><code class="name">var <span class="ident child-name">stats_defaults</span></code></dt>
<dd>
<div class="desc"><p>Defaults for <code><a title="vectorbt.generic.ranges.Ranges.stats" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code>.</p>
<p>Merges <code><a title="vectorbt.records.base.Records.stats_defaults" href="../records/base.html#vectorbt.records.base.Records.stats_defaults">Records.stats_defaults</a></code> and
<code>ranges.stats</code> from <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stats_defaults(self) -&gt; tp.Kwargs:
    &#34;&#34;&#34;Defaults for `Ranges.stats`.

    Merges `vectorbt.records.base.Records.stats_defaults` and
    `ranges.stats` from `vectorbt._settings.settings`.&#34;&#34;&#34;
    from vectorbt._settings import settings
    ranges_stats_cfg = settings[&#39;ranges&#39;][&#39;stats&#39;]

    return merge_dicts(
        Records.stats_defaults.__get__(self),
        ranges_stats_cfg
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.status"><code class="name">var <span class="ident child-name">status</span></code></dt>
<dd>
<div class="desc"><p>Mapped array of the field <code>status</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, instance: object, owner: tp.Optional[tp.Type] = None) -&gt; tp.Any:
    if instance is None:
        return self
    if not should_cache(self.name, instance, func=self.func, **self.flags):
        return super().__get__(instance, owner=owner)
    cache = instance.__dict__
    val = cache.get(self.attrname, _NOT_FOUND)
    if val is _NOT_FOUND:
        with self.lock:
            # check if another thread filled cache while we awaited lock
            val = cache.get(self.attrname, _NOT_FOUND)
            if val is _NOT_FOUND:
                val = self.func(instance)
                cache[self.attrname] = val
    return val</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.ts"><code class="name">var <span class="ident child-name">ts</span></code></dt>
<dd>
<div class="desc"><p>Original time series that records are built from (optional).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def ts(self) -&gt; tp.Optional[tp.SeriesFrame]:
    &#34;&#34;&#34;Original time series that records are built from (optional).&#34;&#34;&#34;
    return self._ts</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.generic.ranges.Ranges.avg_duration"><code class="name flex">
<span>def <span class="ident child-name">avg_duration</span></span>(<span class="params">self, group_by=None, wrap_kwargs=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Average range duration (as timedelta).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def avg_duration(self, group_by: tp.GroupByLike = None,
                 wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;Average range duration (as timedelta).&#34;&#34;&#34;
    wrap_kwargs = merge_dicts(dict(to_timedelta=True, name_or_index=&#39;avg_duration&#39;), wrap_kwargs)
    return self.duration.mean(group_by=group_by, wrap_kwargs=wrap_kwargs, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.coverage"><code class="name flex">
<span>def <span class="ident child-name">coverage</span></span>(<span class="params">self, overlapping=False, normalize=True, group_by=None, wrap_kwargs=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Coverage, that is, the number of steps that are covered by all ranges.</p>
<p>See <code><a title="vectorbt.generic.nb.range_coverage_nb" href="nb.html#vectorbt.generic.nb.range_coverage_nb">range_coverage_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def coverage(self,
             overlapping: bool = False,
             normalize: bool = True,
             group_by: tp.GroupByLike = None,
             wrap_kwargs: tp.KwargsLike = None) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;Coverage, that is, the number of steps that are covered by all ranges.

    See `vectorbt.generic.nb.range_coverage_nb`.&#34;&#34;&#34;
    col_map = self.col_mapper.get_col_map(group_by=group_by)
    index_lens = self.wrapper.grouper.get_group_lens(group_by=group_by) * self.wrapper.shape[0]
    coverage = nb.range_coverage_nb(
        self.get_field_arr(&#39;start_idx&#39;),
        self.get_field_arr(&#39;end_idx&#39;),
        self.get_field_arr(&#39;status&#39;),
        col_map,
        index_lens,
        overlapping=overlapping,
        normalize=normalize
    )
    wrap_kwargs = merge_dicts(dict(name_or_index=&#39;coverage&#39;), wrap_kwargs)
    return self.wrapper.wrap_reduced(coverage, group_by=group_by, **wrap_kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.indexing_func"><code class="name flex">
<span>def <span class="ident child-name">indexing_func</span></span>(<span class="params">self, pd_indexing_func, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Perform indexing on <code><a title="vectorbt.generic.ranges.Ranges" href="#vectorbt.generic.ranges.Ranges">Ranges</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def indexing_func(self: RangesT, pd_indexing_func: tp.PandasIndexingFunc, **kwargs) -&gt; RangesT:
    &#34;&#34;&#34;Perform indexing on `Ranges`.&#34;&#34;&#34;
    new_wrapper, new_records_arr, _, col_idxs = \
        Records.indexing_func_meta(self, pd_indexing_func, **kwargs)
    if self.ts is not None:
        new_ts = new_wrapper.wrap(self.ts.values[:, col_idxs], group_by=False)
    else:
        new_ts = None
    return self.replace(
        wrapper=new_wrapper,
        records_arr=new_records_arr,
        ts=new_ts
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.max_duration"><code class="name flex">
<span>def <span class="ident child-name">max_duration</span></span>(<span class="params">self, group_by=None, wrap_kwargs=None, **kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Maximum range duration (as timedelta).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@cached_method
def max_duration(self, group_by: tp.GroupByLike = None,
                 wrap_kwargs: tp.KwargsLike = None, **kwargs) -&gt; tp.MaybeSeries:
    &#34;&#34;&#34;Maximum range duration (as timedelta).&#34;&#34;&#34;
    wrap_kwargs = merge_dicts(dict(to_timedelta=True, name_or_index=&#39;max_duration&#39;), wrap_kwargs)
    return self.duration.max(group_by=group_by, wrap_kwargs=wrap_kwargs, **kwargs)</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.plot"><code class="name flex">
<span>def <span class="ident child-name">plot</span></span>(<span class="params">self, column=None, top_n=5, plot_zones=True, ts_trace_kwargs=None, start_trace_kwargs=None, end_trace_kwargs=None, open_shape_kwargs=None, closed_shape_kwargs=None, add_trace_kwargs=None, xref='x', yref='y', fig=None, **layout_kwargs)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Plot ranges.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the column to plot.</dd>
<dt><strong><code>top_n</code></strong> :&ensp;<code>int</code></dt>
<dd>Filter top N range records by maximum duration.</dd>
<dt><strong><code>plot_zones</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to plot zones.</dd>
<dt><strong><code>ts_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for <code><a title="vectorbt.generic.ranges.Ranges.ts" href="#vectorbt.generic.ranges.Ranges.ts">Ranges.ts</a></code>.</dd>
<dt><strong><code>start_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for start values.</dd>
<dt><strong><code>end_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Scatter</code> for end values.</dd>
<dt><strong><code>open_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for open zones.</dd>
<dt><strong><code>closed_shape_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>plotly.graph_objects.Figure.add_shape</code> for closed zones.</dd>
<dt><strong><code>add_trace_kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Keyword arguments passed to <code>add_trace</code>.</dd>
<dt><strong><code>xref</code></strong> :&ensp;<code>str</code></dt>
<dd>X coordinate axis.</dd>
<dt><strong><code>yref</code></strong> :&ensp;<code>str</code></dt>
<dd>Y coordinate axis.</dd>
<dt><strong><code>fig</code></strong> :&ensp;<code>Figure</code> or <code>FigureWidget</code></dt>
<dd>Figure to add traces to.</dd>
<dt><strong><code>**layout_kwargs</code></strong></dt>
<dd>Keyword arguments for layout.</dd>
</dl>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import vectorbt as vbt
&gt;&gt;&gt; from datetime import datetime, timedelta
&gt;&gt;&gt; import pandas as pd

&gt;&gt;&gt; price = pd.Series([1, 2, 1, 2, 3, 2, 1, 2], name='Price')
&gt;&gt;&gt; price.index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(len(price))]
&gt;&gt;&gt; vbt.Ranges.from_ts(price &gt;= 2, wrapper_kwargs=dict(freq='1 day')).plot()
</code></pre>
<p><img alt="" src="/docs/img/ranges_plot.svg"></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot(self,
         column: tp.Optional[tp.Label] = None,
         top_n: int = 5,
         plot_zones: bool = True,
         ts_trace_kwargs: tp.KwargsLike = None,
         start_trace_kwargs: tp.KwargsLike = None,
         end_trace_kwargs: tp.KwargsLike = None,
         open_shape_kwargs: tp.KwargsLike = None,
         closed_shape_kwargs: tp.KwargsLike = None,
         add_trace_kwargs: tp.KwargsLike = None,
         xref: str = &#39;x&#39;,
         yref: str = &#39;y&#39;,
         fig: tp.Optional[tp.BaseFigure] = None,
         **layout_kwargs) -&gt; tp.BaseFigure:  # pragma: no cover
    &#34;&#34;&#34;Plot ranges.

    Args:
        column (str): Name of the column to plot.
        top_n (int): Filter top N range records by maximum duration.
        plot_zones (bool): Whether to plot zones.
        ts_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for `Ranges.ts`.
        start_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for start values.
        end_trace_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Scatter` for end values.
        open_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for open zones.
        closed_shape_kwargs (dict): Keyword arguments passed to `plotly.graph_objects.Figure.add_shape` for closed zones.
        add_trace_kwargs (dict): Keyword arguments passed to `add_trace`.
        xref (str): X coordinate axis.
        yref (str): Y coordinate axis.
        fig (Figure or FigureWidget): Figure to add traces to.
        **layout_kwargs: Keyword arguments for layout.

    ## Example

    ```python-repl
    &gt;&gt;&gt; import vectorbt as vbt
    &gt;&gt;&gt; from datetime import datetime, timedelta
    &gt;&gt;&gt; import pandas as pd

    &gt;&gt;&gt; price = pd.Series([1, 2, 1, 2, 3, 2, 1, 2], name=&#39;Price&#39;)
    &gt;&gt;&gt; price.index = [datetime(2020, 1, 1) + timedelta(days=i) for i in range(len(price))]
    &gt;&gt;&gt; vbt.Ranges.from_ts(price &gt;= 2, wrapper_kwargs=dict(freq=&#39;1 day&#39;)).plot()
    ```

    ![](/docs/img/ranges_plot.svg)
    &#34;&#34;&#34;
    from vectorbt._settings import settings
    plotting_cfg = settings[&#39;plotting&#39;]

    self_col = self.select_one(column=column, group_by=False)
    if top_n is not None:
        self_col = self_col.apply_mask(self_col.duration.top_n_mask(top_n))

    if ts_trace_kwargs is None:
        ts_trace_kwargs = {}
    ts_trace_kwargs = merge_dicts(dict(
        line=dict(
            color=plotting_cfg[&#39;color_schema&#39;][&#39;blue&#39;]
        )
    ), ts_trace_kwargs)
    if start_trace_kwargs is None:
        start_trace_kwargs = {}
    if end_trace_kwargs is None:
        end_trace_kwargs = {}
    if open_shape_kwargs is None:
        open_shape_kwargs = {}
    if closed_shape_kwargs is None:
        closed_shape_kwargs = {}
    if add_trace_kwargs is None:
        add_trace_kwargs = {}

    if fig is None:
        fig = make_figure()
    fig.update_layout(**layout_kwargs)
    y_domain = get_domain(yref, fig)

    if self_col.ts is not None:
        fig = self_col.ts.vbt.plot(trace_kwargs=ts_trace_kwargs, add_trace_kwargs=add_trace_kwargs, fig=fig)

    if self_col.count() &gt; 0:
        # Extract information
        id_ = self_col.get_field_arr(&#39;id&#39;)
        id_title = self_col.get_field_title(&#39;id&#39;)

        start_idx = self_col.get_map_field_to_index(&#39;start_idx&#39;)
        start_idx_title = self_col.get_field_title(&#39;start_idx&#39;)
        if self_col.ts is not None:
            start_val = self_col.ts.loc[start_idx]
        else:
            start_val = np.full(len(start_idx), 0)

        end_idx = self_col.get_map_field_to_index(&#39;end_idx&#39;)
        end_idx_title = self_col.get_field_title(&#39;end_idx&#39;)
        if self_col.ts is not None:
            end_val = self_col.ts.loc[end_idx]
        else:
            end_val = np.full(len(end_idx), 0)

        duration = np.vectorize(str)(self_col.wrapper.to_timedelta(
            self_col.duration.values, to_pd=True, silence_warnings=True))

        status = self_col.get_field_arr(&#39;status&#39;)

        # Plot start markers
        start_customdata = id_[:, None]
        start_scatter = go.Scatter(
            x=start_idx,
            y=start_val,
            mode=&#39;markers&#39;,
            marker=dict(
                symbol=&#39;diamond&#39;,
                color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;blue&#39;],
                size=7,
                line=dict(
                    width=1,
                    color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;blue&#39;])
                )
            ),
            name=&#39;Start&#39;,
            customdata=start_customdata,
            hovertemplate=f&#34;{id_title}: %{{customdata[0]}}&#34;
                          f&#34;&lt;br&gt;{start_idx_title}: %{{x}}&#34;
        )
        start_scatter.update(**start_trace_kwargs)
        fig.add_trace(start_scatter, **add_trace_kwargs)

        closed_mask = status == RangeStatus.Closed
        if closed_mask.any():
            # Plot end markers
            closed_end_customdata = np.stack((
                id_[closed_mask],
                duration[closed_mask]
            ), axis=1)
            closed_end_scatter = go.Scatter(
                x=end_idx[closed_mask],
                y=end_val[closed_mask],
                mode=&#39;markers&#39;,
                marker=dict(
                    symbol=&#39;diamond&#39;,
                    color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;green&#39;],
                    size=7,
                    line=dict(
                        width=1,
                        color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;green&#39;])
                    )
                ),
                name=&#39;Closed&#39;,
                customdata=closed_end_customdata,
                hovertemplate=f&#34;{id_title}: %{{customdata[0]}}&#34;
                              f&#34;&lt;br&gt;{end_idx_title}: %{{x}}&#34;
                              f&#34;&lt;br&gt;Duration: %{{customdata[1]}}&#34;
            )
            closed_end_scatter.update(**end_trace_kwargs)
            fig.add_trace(closed_end_scatter, **add_trace_kwargs)

            if plot_zones:
                # Plot closed range zones
                for i in range(len(id_[closed_mask])):
                    fig.add_shape(**merge_dicts(dict(
                        type=&#34;rect&#34;,
                        xref=xref,
                        yref=&#34;paper&#34;,
                        x0=start_idx[closed_mask][i],
                        y0=y_domain[0],
                        x1=end_idx[closed_mask][i],
                        y1=y_domain[1],
                        fillcolor=&#39;teal&#39;,
                        opacity=0.2,
                        layer=&#34;below&#34;,
                        line_width=0,
                    ), closed_shape_kwargs))

        open_mask = status == RangeStatus.Open
        if open_mask.any():
            # Plot end markers
            open_end_customdata = np.stack((
                id_[open_mask],
                duration[open_mask]
            ), axis=1)
            open_end_scatter = go.Scatter(
                x=end_idx[open_mask],
                y=end_val[open_mask],
                mode=&#39;markers&#39;,
                marker=dict(
                    symbol=&#39;diamond&#39;,
                    color=plotting_cfg[&#39;contrast_color_schema&#39;][&#39;orange&#39;],
                    size=7,
                    line=dict(
                        width=1,
                        color=adjust_lightness(plotting_cfg[&#39;contrast_color_schema&#39;][&#39;orange&#39;])
                    )
                ),
                name=&#39;Open&#39;,
                customdata=open_end_customdata,
                hovertemplate=f&#34;{id_title}: %{{customdata[0]}}&#34;
                              f&#34;&lt;br&gt;{end_idx_title}: %{{x}}&#34;
                              f&#34;&lt;br&gt;Duration: %{{customdata[1]}}&#34;
            )
            open_end_scatter.update(**end_trace_kwargs)
            fig.add_trace(open_end_scatter, **add_trace_kwargs)

            if plot_zones:
                # Plot open range zones
                for i in range(len(id_[open_mask])):
                    fig.add_shape(**merge_dicts(dict(
                        type=&#34;rect&#34;,
                        xref=xref,
                        yref=&#34;paper&#34;,
                        x0=start_idx[open_mask][i],
                        y0=y_domain[0],
                        x1=end_idx[open_mask][i],
                        y1=y_domain[1],
                        fillcolor=&#39;orange&#39;,
                        opacity=0.2,
                        layer=&#34;below&#34;,
                        line_width=0,
                    ), open_shape_kwargs))

    return fig</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.ranges.Ranges.to_mask"><code class="name flex">
<span>def <span class="ident child-name">to_mask</span></span>(<span class="params">self, group_by=None, wrap_kwargs=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Convert ranges to a mask.</p>
<p>See <code><a title="vectorbt.generic.nb.ranges_to_mask_nb" href="nb.html#vectorbt.generic.nb.ranges_to_mask_nb">ranges_to_mask_nb()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_mask(self, group_by: tp.GroupByLike = None, wrap_kwargs: tp.KwargsLike = None) -&gt; tp.SeriesFrame:
    &#34;&#34;&#34;Convert ranges to a mask.

    See `vectorbt.generic.nb.ranges_to_mask_nb`.&#34;&#34;&#34;
    col_map = self.col_mapper.get_col_map(group_by=group_by)
    mask = nb.ranges_to_mask_nb(
        self.get_field_arr(&#39;start_idx&#39;),
        self.get_field_arr(&#39;end_idx&#39;),
        self.get_field_arr(&#39;status&#39;),
        col_map,
        len(self.wrapper.index)
    )
    return self.wrapper.wrap(mask, group_by=group_by, **merge_dicts({}, wrap_kwargs))</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vectorbt.records.base.Records" href="../records/base.html#vectorbt.records.base.Records">Records</a></b></code>:
<ul class="hlist">
<li><code><a title="vectorbt.records.base.Records.apply" href="../records/base.html#vectorbt.records.base.Records.apply">apply</a></code></li>
<li><code><a title="vectorbt.records.base.Records.apply_mask" href="../records/base.html#vectorbt.records.base.Records.apply_mask">apply_mask</a></code></li>
<li><code><a title="vectorbt.records.base.Records.build_field_config_doc" href="../records/base.html#vectorbt.records.base.Records.build_field_config_doc">build_field_config_doc</a></code></li>
<li><code><a title="vectorbt.records.base.Records.build_metrics_doc" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.records.base.Records.build_subplots_doc" href="plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.build_subplots_doc">build_subplots_doc</a></code></li>
<li><code><a title="vectorbt.records.base.Records.col_arr" href="../records/base.html#vectorbt.records.base.Records.col_arr">col_arr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.col_mapper" href="../records/base.html#vectorbt.records.base.Records.col_mapper">col_mapper</a></code></li>
<li><code><a title="vectorbt.records.base.Records.config" href="../utils/config.html#vectorbt.utils.config.Configured.config">config</a></code></li>
<li><code><a title="vectorbt.records.base.Records.copy" href="../utils/config.html#vectorbt.utils.config.Configured.copy">copy</a></code></li>
<li><code><a title="vectorbt.records.base.Records.count" href="../records/base.html#vectorbt.records.base.Records.count">count</a></code></li>
<li><code><a title="vectorbt.records.base.Records.deep_getattr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.deep_getattr">deep_getattr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.dumps" href="../utils/config.html#vectorbt.utils.config.Pickleable.dumps">dumps</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_apply_mapping_arr" href="../records/base.html#vectorbt.records.base.Records.get_apply_mapping_arr">get_apply_mapping_arr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_by_col_idxs" href="../records/base.html#vectorbt.records.base.Records.get_by_col_idxs">get_by_col_idxs</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_field_arr" href="../records/base.html#vectorbt.records.base.Records.get_field_arr">get_field_arr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_field_mapping" href="../records/base.html#vectorbt.records.base.Records.get_field_mapping">get_field_mapping</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_field_name" href="../records/base.html#vectorbt.records.base.Records.get_field_name">get_field_name</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_field_setting" href="../records/base.html#vectorbt.records.base.Records.get_field_setting">get_field_setting</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_field_title" href="../records/base.html#vectorbt.records.base.Records.get_field_title">get_field_title</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_map_field" href="../records/base.html#vectorbt.records.base.Records.get_map_field">get_map_field</a></code></li>
<li><code><a title="vectorbt.records.base.Records.get_map_field_to_index" href="../records/base.html#vectorbt.records.base.Records.get_map_field_to_index">get_map_field_to_index</a></code></li>
<li><code><a title="vectorbt.records.base.Records.id_arr" href="../records/base.html#vectorbt.records.base.Records.id_arr">id_arr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.idx_arr" href="../records/base.html#vectorbt.records.base.Records.idx_arr">idx_arr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.iloc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.iloc">iloc</a></code></li>
<li><code><a title="vectorbt.records.base.Records.indexing_func_meta" href="../records/base.html#vectorbt.records.base.Records.indexing_func_meta">indexing_func_meta</a></code></li>
<li><code><a title="vectorbt.records.base.Records.indexing_kwargs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.indexing_kwargs">indexing_kwargs</a></code></li>
<li><code><a title="vectorbt.records.base.Records.is_sorted" href="../records/base.html#vectorbt.records.base.Records.is_sorted">is_sorted</a></code></li>
<li><code><a title="vectorbt.records.base.Records.load" href="../utils/config.html#vectorbt.utils.config.Pickleable.load">load</a></code></li>
<li><code><a title="vectorbt.records.base.Records.loads" href="../utils/config.html#vectorbt.utils.config.Pickleable.loads">loads</a></code></li>
<li><code><a title="vectorbt.records.base.Records.loc" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.loc">loc</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map" href="../records/base.html#vectorbt.records.base.Records.map">map</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map_array" href="../records/base.html#vectorbt.records.base.Records.map_array">map_array</a></code></li>
<li><code><a title="vectorbt.records.base.Records.map_field" href="../records/base.html#vectorbt.records.base.Records.map_field">map_field</a></code></li>
<li><code><a title="vectorbt.records.base.Records.override_field_config_doc" href="../records/base.html#vectorbt.records.base.Records.override_field_config_doc">override_field_config_doc</a></code></li>
<li><code><a title="vectorbt.records.base.Records.override_metrics_doc" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.records.base.Records.override_subplots_doc" href="plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.override_subplots_doc">override_subplots_doc</a></code></li>
<li><code><a title="vectorbt.records.base.Records.plots" href="plots_builder.html#vectorbt.generic.plots_builder.PlotsBuilderMixin.plots">plots</a></code></li>
<li><code><a title="vectorbt.records.base.Records.post_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.post_resolve_attr">post_resolve_attr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.pre_resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.pre_resolve_attr">pre_resolve_attr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.records" href="../records/base.html#vectorbt.records.base.Records.records">records</a></code></li>
<li><code><a title="vectorbt.records.base.Records.records_arr" href="../records/base.html#vectorbt.records.base.Records.records_arr">records_arr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.records_readable" href="../records/base.html#vectorbt.records.base.Records.records_readable">records_readable</a></code></li>
<li><code><a title="vectorbt.records.base.Records.regroup" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.regroup">regroup</a></code></li>
<li><code><a title="vectorbt.records.base.Records.replace" href="../records/base.html#vectorbt.records.base.Records.replace">replace</a></code></li>
<li><code><a title="vectorbt.records.base.Records.resolve_attr" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.resolve_attr">resolve_attr</a></code></li>
<li><code><a title="vectorbt.records.base.Records.resolve_self" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.resolve_self">resolve_self</a></code></li>
<li><code><a title="vectorbt.records.base.Records.save" href="../utils/config.html#vectorbt.utils.config.Pickleable.save">save</a></code></li>
<li><code><a title="vectorbt.records.base.Records.select_one" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one">select_one</a></code></li>
<li><code><a title="vectorbt.records.base.Records.select_one_from_obj" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.select_one_from_obj">select_one_from_obj</a></code></li>
<li><code><a title="vectorbt.records.base.Records.self_aliases" href="../utils/attr_.html#vectorbt.utils.attr_.AttrResolver.self_aliases">self_aliases</a></code></li>
<li><code><a title="vectorbt.records.base.Records.sort" href="../records/base.html#vectorbt.records.base.Records.sort">sort</a></code></li>
<li><code><a title="vectorbt.records.base.Records.stats" href="stats_builder.html#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
<li><code><a title="vectorbt.records.base.Records.to_doc" href="../utils/docs.html#vectorbt.utils.docs.Documented.to_doc">to_doc</a></code></li>
<li><code><a title="vectorbt.records.base.Records.update_config" href="../utils/config.html#vectorbt.utils.config.Configured.update_config">update_config</a></code></li>
<li><code><a title="vectorbt.records.base.Records.values" href="../records/base.html#vectorbt.records.base.Records.values">values</a></code></li>
<li><code><a title="vectorbt.records.base.Records.wrapper" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping.wrapper">wrapper</a></code></li>
<li><code><a title="vectorbt.records.base.Records.writeable_attrs" href="../utils/config.html#vectorbt.utils.config.Configured.writeable_attrs">writeable_attrs</a></code></li>
<li><code><a title="vectorbt.records.base.Records.xs" href="../base/indexing.html#vectorbt.base.indexing.PandasIndexer.xs">xs</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRUYwMDAwO30KCS5zdDF7ZmlsbDojRkY5MDAwO30KCS5zdDJ7ZmlsbDojRkZERjAwO30KCS5zdDN7ZmlsbDojMjgyQzM0O30KPC9zdHlsZT4KPGc+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNTUuMywzMDAuMSAyODMuMSwwIDIwOCwwIDExMC44LDAgMzUuOCwwIDEuMiw0NTAuMiA3Ni4zLDQ1MC4yIAkJCSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjIzMC40LDMwMC4xIDM1OC4xLDAgMjgzLjEsMCAxODUuOCwwIDExMC44LDAgNzYuMyw0NTAuMiAxNTEuMyw0NTAuMiAJCQkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIzMDUuNCwzMDAuMSA0MzMuMSwwIDM1OC4xLDAgMzMxLjYsNjIuMyAyNjAuOCwwIDE4NS44LDAgMTUxLjMsNDUwLjIgMjI2LjQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iNTEwLjgsMCA0MzMuMSwwIDMwNS40LDMwMC4xIDMzOC40LDAgMjYwLjgsMCAyMjYuNCw0NTAuMiAzMDQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="/>
vectorbt <span class="version">0.23.0</span></a>
</header>
<div class="search-container" id="docsearch"></div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul>
<li><a href="#from-accessors">From accessors</a></li>
<li><a href="#stats">Stats</a></li>
<li><a href="#plots">Plots</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.generic" href="index.html">vectorbt.generic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="vectorbt.generic.ranges.ranges_attach_field_config" href="#vectorbt.generic.ranges.ranges_attach_field_config">ranges_attach_field_config</a></code></li>
<li><code><a title="vectorbt.generic.ranges.ranges_field_config" href="#vectorbt.generic.ranges.ranges_field_config">ranges_field_config</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.generic.ranges.Ranges" href="#vectorbt.generic.ranges.Ranges">Ranges</a></code></h4>
<ul class="two-column">
<li><code><a title="vectorbt.generic.ranges.Ranges.avg_duration" href="#vectorbt.generic.ranges.Ranges.avg_duration">avg_duration</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.closed" href="#vectorbt.generic.ranges.Ranges.closed">closed</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.col" href="#vectorbt.generic.ranges.Ranges.col">col</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.coverage" href="#vectorbt.generic.ranges.Ranges.coverage">coverage</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.duration" href="#vectorbt.generic.ranges.Ranges.duration">duration</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.end_idx" href="#vectorbt.generic.ranges.Ranges.end_idx">end_idx</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.field_config" href="#vectorbt.generic.ranges.Ranges.field_config">field_config</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.from_ts" href="#vectorbt.generic.ranges.Ranges.from_ts">from_ts</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.id" href="#vectorbt.generic.ranges.Ranges.id">id</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.indexing_func" href="#vectorbt.generic.ranges.Ranges.indexing_func">indexing_func</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.max_duration" href="#vectorbt.generic.ranges.Ranges.max_duration">max_duration</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.metrics" href="#vectorbt.generic.ranges.Ranges.metrics">metrics</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.open" href="#vectorbt.generic.ranges.Ranges.open">open</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.plot" href="#vectorbt.generic.ranges.Ranges.plot">plot</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.plots_defaults" href="#vectorbt.generic.ranges.Ranges.plots_defaults">plots_defaults</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.start_idx" href="#vectorbt.generic.ranges.Ranges.start_idx">start_idx</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.stats_defaults" href="#vectorbt.generic.ranges.Ranges.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.status" href="#vectorbt.generic.ranges.Ranges.status">status</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.subplots" href="#vectorbt.generic.ranges.Ranges.subplots">subplots</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.to_mask" href="#vectorbt.generic.ranges.Ranges.to_mask">to_mask</a></code></li>
<li><code><a title="vectorbt.generic.ranges.Ranges.ts" href="#vectorbt.generic.ranges.Ranges.ts">ts</a></code></li>
</ul>
</li>
</ul>
</li>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script src="https://cdn.jsdelivr.net/npm/@docsearch/js@alpha"></script>
<script type="text/javascript">
docsearch({
container: '#docsearch',
appId: 'KNQTBBHKVB',
indexName: 'vectorbt',
apiKey: 'a945e6e8f1cb2fdc30e936936aa3307b',
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous"></script>
<script>
$(document).ready(function() {
$("article dt[id], #section-intro [id]").each(function() {
const thisId = $(this).attr('id');
$(this).wrap('<a class="headerlink" href="#' + thisId + '">');
});
});
</script>
</body>
</html>