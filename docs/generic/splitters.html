<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>vectorbt.generic.splitters API documentation</title>
<meta name="description" content="Splitters for cross-validation â€¦" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#e82}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold;word-break:break-all}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;margin-left:-15px;margin-right:-15px;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-weight:400;font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script>
window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
ga('create', 'UA-142521178-3', 'auto'); ga('send', 'pageview');
</script><script async src='https://www.google-analytics.com/analytics.js'></script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:100px;max-height:100px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.generic.splitters</code></h1>
</header>
<section id="section-intro">
<p>Splitters for cross-validation.</p>
<p>Defines splitter classes similar (but may not compatible) to <code>sklearn.model_selection.BaseCrossValidator</code>.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Splitters for cross-validation.

Defines splitter classes similar (but may not compatible) to `sklearn.model_selection.BaseCrossValidator`.&#34;&#34;&#34;

import numpy as np
import pandas as pd
import math

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.base.index_fns import find_first_occurrence
from vectorbt.base.reshape_fns import to_any_array

RangesT = tp.Generator[tp.Sequence[tp.ArrayLikeSequence], None, None]


def split_ranges_into_sets(start_idxs: tp.ArrayLike, end_idxs: tp.ArrayLike,
                           set_lens: tp.MaybeSequence[tp.Sequence[float]] = (),
                           left_to_right: tp.MaybeSequence[bool] = True) -&gt; RangesT:
    &#34;&#34;&#34;Generate ranges between each in `start_idxs` and `end_idxs` and
    optionally split into one or more sets.

    Args:
        start_idxs (array_like): Start indices.
        end_idxs (array_like): End indices.
        set_lens (list of float): Lengths of sets in each range.

            The number of returned sets is the length of `set_lens` plus one,
            which stores the remaining elements.

            Can be passed per range.
        left_to_right (bool or list of bool): Whether to resolve `set_lens` from left to right.

            Makes the last set variable, otherwise makes the first set variable.

            Can be passed per range.

    ## Example

    * `set_lens=(0.5)`: 50% in training set, the rest in test set
    * `set_lens=(0.5, 0.25)`: 50% in training set, 25% in validation set, the rest in test set
    * `set_lens=(50, 30)`: 50 in training set, 30 in validation set, the rest in test set
    * `set_lens=(50, 30)` and `left_to_right=False`: 30 in test set, 50 in validation set,
        the rest in training set
    &#34;&#34;&#34;
    start_idxs = np.asarray(start_idxs)
    end_idxs = np.asarray(end_idxs)
    checks.assert_len_equal(start_idxs, end_idxs)

    for i in range(len(start_idxs)):
        start_idx = start_idxs[i]
        end_idx = end_idxs[i]

        range_len = end_idx - start_idx + 1
        new_set_lens = []
        if len(set_lens) == 0:
            yield (np.arange(start_idx, end_idx + 1),)
        else:
            if checks.is_sequence(set_lens[0]):
                _set_lens = set_lens[i]
            else:
                _set_lens = set_lens
            if checks.is_sequence(left_to_right):
                _left_to_right = left_to_right[i]
            else:
                _left_to_right = left_to_right
            for j, set_len in enumerate(_set_lens):
                if 0 &lt; set_len &lt; 1:
                    set_len = math.floor(set_len * range_len)
                if set_len == 0:
                    raise ValueError(f&#34;Set {j} in the range {i} is empty&#34;)
                new_set_lens.append(set_len)
            if sum(new_set_lens) &lt; range_len:
                if _left_to_right:
                    new_set_lens = new_set_lens + [range_len - sum(new_set_lens)]
                else:
                    new_set_lens = [range_len - sum(new_set_lens)] + new_set_lens
            else:
                raise ValueError(f&#34;Range of length {range_len} too short to split into {len(_set_lens) + 1} sets&#34;)

            # Split each range into sets
            idx_offset = 0
            set_ranges = []
            for set_len in new_set_lens:
                new_idx_offset = idx_offset + set_len
                set_ranges.append(np.arange(start_idx + idx_offset, start_idx + new_idx_offset))
                idx_offset = new_idx_offset

            yield tuple(set_ranges)


class SplitterT(tp.Protocol):
    def split(self, X: tp.ArrayLike, **kwargs) -&gt; RangesT:
        ...


class BaseSplitter:
    &#34;&#34;&#34;Abstract splitter class.&#34;&#34;&#34;

    def split(self, X: tp.ArrayLike, **kwargs) -&gt; RangesT:
        raise NotImplementedError


class RangeSplitter(BaseSplitter):
    &#34;&#34;&#34;Range splitter.&#34;&#34;&#34;

    def split(self, X: tp.ArrayLike, n: tp.Optional[int] = None, range_len: tp.Optional[float] = None,
              min_len: int = 1, start_idxs: tp.Optional[tp.ArrayLike] = None,
              end_idxs: tp.Optional[tp.ArrayLike] = None, **kwargs) -&gt; RangesT:
        &#34;&#34;&#34;Either split into `n` ranges each `range_len` long, or split into ranges between
        `start_idxs` and `end_idxs`, and concatenate along the column axis.

        At least one of `range_len`, `n`, or `start_idxs` and `end_idxs` must be set:

        * If `range_len` is None, are split evenly into `n` ranges.
        * If `n` is None, returns the maximum number of ranges of length `range_len` (can be a percentage).
        * If `start_idxs` and `end_idxs`, splits into ranges between both arrays.
        Both index arrays should be either NumPy arrays with absolute positions or
        pandas indexes with labels. The last index should be inclusive. The distance
        between each start and end index can be different, and smaller ranges are filled with NaNs.

        `range_len` can be a floating number between 0 and 1 to indicate a fraction of the total range.

        `**kwargs` are passed to `split_ranges_into_sets`.&#34;&#34;&#34;
        X = to_any_array(X)
        if isinstance(X, (pd.Series, pd.DataFrame)):
            index = X.index
        else:
            index = pd.Index(np.arange(X.shape[0]))

        # Resolve start_idxs and end_idxs
        if start_idxs is None and end_idxs is None:
            if range_len is None and n is None:
                raise ValueError(&#34;At least n, range_len, or start_idxs and end_idxs must be set&#34;)
            if range_len is None:
                range_len = len(index) // n
            if 0 &lt; range_len &lt; 1:
                range_len = math.floor(range_len * len(index))
            start_idxs = np.arange(len(index) - range_len + 1)
            end_idxs = np.arange(range_len - 1, len(index))
        elif start_idxs is None or end_idxs is None:
            raise ValueError(&#34;Both start_idxs and end_idxs must be set&#34;)
        else:
            if isinstance(start_idxs, pd.Index):
                start_idxs = np.asarray([find_first_occurrence(idx, index) for idx in start_idxs])
            else:
                start_idxs = np.asarray(start_idxs)
            if isinstance(end_idxs, pd.Index):
                end_idxs = np.asarray([find_first_occurrence(idx, index) for idx in end_idxs])
            else:
                end_idxs = np.asarray(end_idxs)

        # Filter out short ranges
        start_idxs, end_idxs = np.broadcast_arrays(start_idxs, end_idxs)
        range_lens = end_idxs - start_idxs + 1
        min_len_mask = range_lens &gt;= min_len
        if not np.any(min_len_mask):
            raise ValueError(f&#34;There are no ranges that meet range_len&gt;={min_len}&#34;)
        start_idxs = start_idxs[min_len_mask]
        end_idxs = end_idxs[min_len_mask]

        # Evenly select n ranges
        if n is not None:
            if n &gt; len(start_idxs):
                raise ValueError(f&#34;n cannot be bigger than the maximum number of ranges {len(start_idxs)}&#34;)
            idxs = np.round(np.linspace(0, len(start_idxs) - 1, n)).astype(int)
            start_idxs = start_idxs[idxs]
            end_idxs = end_idxs[idxs]

        return split_ranges_into_sets(start_idxs, end_idxs, **kwargs)


class RollingSplitter(BaseSplitter):
    &#34;&#34;&#34;Rolling walk-forward splitter.&#34;&#34;&#34;

    def split(self, X: tp.ArrayLike, n: tp.Optional[int] = None, window_len: tp.Optional[float] = None,
              min_len: int = 1, **kwargs) -&gt; RangesT:
        &#34;&#34;&#34;Split by rolling a window.

        `**kwargs` are passed to `split_ranges_into_sets`.&#34;&#34;&#34;
        X = to_any_array(X)
        if isinstance(X, (pd.Series, pd.DataFrame)):
            index = X.index
        else:
            index = pd.Index(np.arange(X.shape[0]))

        # Resolve start_idxs and end_idxs
        if window_len is None and n is None:
            raise ValueError(&#34;At least n or window_len must be set&#34;)
        if window_len is None:
            window_len = len(index) // n
        if 0 &lt; window_len &lt; 1:
            window_len = math.floor(window_len * len(index))
        start_idxs = np.arange(len(index) - window_len + 1)
        end_idxs = np.arange(window_len - 1, len(index))

        # Filter out short ranges
        window_lens = end_idxs - start_idxs + 1
        min_len_mask = window_lens &gt;= min_len
        if not np.any(min_len_mask):
            raise ValueError(f&#34;There are no ranges that meet window_len&gt;={min_len}&#34;)
        start_idxs = start_idxs[min_len_mask]
        end_idxs = end_idxs[min_len_mask]

        # Evenly select n ranges
        if n is not None:
            if n &gt; len(start_idxs):
                raise ValueError(f&#34;n cannot be bigger than the maximum number of windows {len(start_idxs)}&#34;)
            idxs = np.round(np.linspace(0, len(start_idxs) - 1, n)).astype(int)
            start_idxs = start_idxs[idxs]
            end_idxs = end_idxs[idxs]

        return split_ranges_into_sets(start_idxs, end_idxs, **kwargs)


class ExpandingSplitter(BaseSplitter):
    &#34;&#34;&#34;Expanding walk-forward splitter.&#34;&#34;&#34;

    def split(self, X: tp.ArrayLike, n: tp.Optional[int] = None, min_len: int = 1, **kwargs) -&gt; RangesT:
        &#34;&#34;&#34;Similar to `RollingSplitter.split`, but expanding.

        `**kwargs` are passed to `split_ranges_into_sets`.&#34;&#34;&#34;
        X = to_any_array(X)
        if isinstance(X, (pd.Series, pd.DataFrame)):
            index = X.index
        else:
            index = pd.Index(np.arange(X.shape[0]))

        # Resolve start_idxs and end_idxs
        start_idxs = np.full(len(index), 0)
        end_idxs = np.arange(len(index))

        # Filter out short ranges
        window_lens = end_idxs - start_idxs + 1
        min_len_mask = window_lens &gt;= min_len
        if not np.any(min_len_mask):
            raise ValueError(f&#34;There are no ranges that meet window_len&gt;={min_len}&#34;)
        start_idxs = start_idxs[min_len_mask]
        end_idxs = end_idxs[min_len_mask]

        # Evenly select n ranges
        if n is not None:
            if n &gt; len(start_idxs):
                raise ValueError(f&#34;n cannot be bigger than the maximum number of windows {len(start_idxs)}&#34;)
            idxs = np.round(np.linspace(0, len(start_idxs) - 1, n)).astype(int)
            start_idxs = start_idxs[idxs]
            end_idxs = end_idxs[idxs]

        return split_ranges_into_sets(start_idxs, end_idxs, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vectorbt.generic.splitters.split_ranges_into_sets"><code class="name flex">
<span>def <span class="ident">split_ranges_into_sets</span></span>(<span>start_idxs, end_idxs, set_lens=(), left_to_right=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate ranges between each in <code>start_idxs</code> and <code>end_idxs</code> and
optionally split into one or more sets.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start_idxs</code></strong> :&ensp;<code>array_like</code></dt>
<dd>Start indices.</dd>
<dt><strong><code>end_idxs</code></strong> :&ensp;<code>array_like</code></dt>
<dd>End indices.</dd>
<dt><strong><code>set_lens</code></strong> :&ensp;<code>list</code> of <code>float</code></dt>
<dd>
<p>Lengths of sets in each range.</p>
<p>The number of returned sets is the length of <code>set_lens</code> plus one,
which stores the remaining elements.</p>
<p>Can be passed per range.</p>
</dd>
<dt><strong><code>left_to_right</code></strong> :&ensp;<code>bool</code> or <code>list</code> of <code>bool</code></dt>
<dd>
<p>Whether to resolve <code>set_lens</code> from left to right.</p>
<p>Makes the last set variable, otherwise makes the first set variable.</p>
<p>Can be passed per range.</p>
</dd>
</dl>
<h2 id="example">Example</h2>
<ul>
<li><code>set_lens=(0.5)</code>: 50% in training set, the rest in test set</li>
<li><code>set_lens=(0.5, 0.25)</code>: 50% in training set, 25% in validation set, the rest in test set</li>
<li><code>set_lens=(50, 30)</code>: 50 in training set, 30 in validation set, the rest in test set</li>
<li><code>set_lens=(50, 30)</code> and <code>left_to_right=False</code>: 30 in test set, 50 in validation set,
the rest in training set</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split_ranges_into_sets(start_idxs: tp.ArrayLike, end_idxs: tp.ArrayLike,
                           set_lens: tp.MaybeSequence[tp.Sequence[float]] = (),
                           left_to_right: tp.MaybeSequence[bool] = True) -&gt; RangesT:
    &#34;&#34;&#34;Generate ranges between each in `start_idxs` and `end_idxs` and
    optionally split into one or more sets.

    Args:
        start_idxs (array_like): Start indices.
        end_idxs (array_like): End indices.
        set_lens (list of float): Lengths of sets in each range.

            The number of returned sets is the length of `set_lens` plus one,
            which stores the remaining elements.

            Can be passed per range.
        left_to_right (bool or list of bool): Whether to resolve `set_lens` from left to right.

            Makes the last set variable, otherwise makes the first set variable.

            Can be passed per range.

    ## Example

    * `set_lens=(0.5)`: 50% in training set, the rest in test set
    * `set_lens=(0.5, 0.25)`: 50% in training set, 25% in validation set, the rest in test set
    * `set_lens=(50, 30)`: 50 in training set, 30 in validation set, the rest in test set
    * `set_lens=(50, 30)` and `left_to_right=False`: 30 in test set, 50 in validation set,
        the rest in training set
    &#34;&#34;&#34;
    start_idxs = np.asarray(start_idxs)
    end_idxs = np.asarray(end_idxs)
    checks.assert_len_equal(start_idxs, end_idxs)

    for i in range(len(start_idxs)):
        start_idx = start_idxs[i]
        end_idx = end_idxs[i]

        range_len = end_idx - start_idx + 1
        new_set_lens = []
        if len(set_lens) == 0:
            yield (np.arange(start_idx, end_idx + 1),)
        else:
            if checks.is_sequence(set_lens[0]):
                _set_lens = set_lens[i]
            else:
                _set_lens = set_lens
            if checks.is_sequence(left_to_right):
                _left_to_right = left_to_right[i]
            else:
                _left_to_right = left_to_right
            for j, set_len in enumerate(_set_lens):
                if 0 &lt; set_len &lt; 1:
                    set_len = math.floor(set_len * range_len)
                if set_len == 0:
                    raise ValueError(f&#34;Set {j} in the range {i} is empty&#34;)
                new_set_lens.append(set_len)
            if sum(new_set_lens) &lt; range_len:
                if _left_to_right:
                    new_set_lens = new_set_lens + [range_len - sum(new_set_lens)]
                else:
                    new_set_lens = [range_len - sum(new_set_lens)] + new_set_lens
            else:
                raise ValueError(f&#34;Range of length {range_len} too short to split into {len(_set_lens) + 1} sets&#34;)

            # Split each range into sets
            idx_offset = 0
            set_ranges = []
            for set_len in new_set_lens:
                new_idx_offset = idx_offset + set_len
                set_ranges.append(np.arange(start_idx + idx_offset, start_idx + new_idx_offset))
                idx_offset = new_idx_offset

            yield tuple(set_ranges)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.generic.splitters.BaseSplitter"><code class="flex name class">
<span>class <span class="ident">BaseSplitter</span></span>
</code></dt>
<dd>
<div class="desc"><p>Abstract splitter class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseSplitter:
    &#34;&#34;&#34;Abstract splitter class.&#34;&#34;&#34;

    def split(self, X: tp.ArrayLike, **kwargs) -&gt; RangesT:
        raise NotImplementedError</code></pre>
</details>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.generic.splitters.ExpandingSplitter" href="#vectorbt.generic.splitters.ExpandingSplitter">ExpandingSplitter</a></li>
<li><a title="vectorbt.generic.splitters.RangeSplitter" href="#vectorbt.generic.splitters.RangeSplitter">RangeSplitter</a></li>
<li><a title="vectorbt.generic.splitters.RollingSplitter" href="#vectorbt.generic.splitters.RollingSplitter">RollingSplitter</a></li>
</ul>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.generic.splitters.BaseSplitter.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self, X, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self, X: tp.ArrayLike, **kwargs) -&gt; RangesT:
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.generic.splitters.ExpandingSplitter"><code class="flex name class">
<span>class <span class="ident">ExpandingSplitter</span></span>
</code></dt>
<dd>
<div class="desc"><p>Expanding walk-forward splitter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExpandingSplitter(BaseSplitter):
    &#34;&#34;&#34;Expanding walk-forward splitter.&#34;&#34;&#34;

    def split(self, X: tp.ArrayLike, n: tp.Optional[int] = None, min_len: int = 1, **kwargs) -&gt; RangesT:
        &#34;&#34;&#34;Similar to `RollingSplitter.split`, but expanding.

        `**kwargs` are passed to `split_ranges_into_sets`.&#34;&#34;&#34;
        X = to_any_array(X)
        if isinstance(X, (pd.Series, pd.DataFrame)):
            index = X.index
        else:
            index = pd.Index(np.arange(X.shape[0]))

        # Resolve start_idxs and end_idxs
        start_idxs = np.full(len(index), 0)
        end_idxs = np.arange(len(index))

        # Filter out short ranges
        window_lens = end_idxs - start_idxs + 1
        min_len_mask = window_lens &gt;= min_len
        if not np.any(min_len_mask):
            raise ValueError(f&#34;There are no ranges that meet window_len&gt;={min_len}&#34;)
        start_idxs = start_idxs[min_len_mask]
        end_idxs = end_idxs[min_len_mask]

        # Evenly select n ranges
        if n is not None:
            if n &gt; len(start_idxs):
                raise ValueError(f&#34;n cannot be bigger than the maximum number of windows {len(start_idxs)}&#34;)
            idxs = np.round(np.linspace(0, len(start_idxs) - 1, n)).astype(int)
            start_idxs = start_idxs[idxs]
            end_idxs = end_idxs[idxs]

        return split_ranges_into_sets(start_idxs, end_idxs, **kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.generic.splitters.BaseSplitter" href="#vectorbt.generic.splitters.BaseSplitter">BaseSplitter</a></li>
</ul>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.generic.splitters.ExpandingSplitter.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self, X, n=None, min_len=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Similar to <code><a title="vectorbt.generic.splitters.RollingSplitter.split" href="#vectorbt.generic.splitters.RollingSplitter.split">RollingSplitter.split()</a></code>, but expanding.</p>
<p><code>**kwargs</code> are passed to <code><a title="vectorbt.generic.splitters.split_ranges_into_sets" href="#vectorbt.generic.splitters.split_ranges_into_sets">split_ranges_into_sets()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self, X: tp.ArrayLike, n: tp.Optional[int] = None, min_len: int = 1, **kwargs) -&gt; RangesT:
    &#34;&#34;&#34;Similar to `RollingSplitter.split`, but expanding.

    `**kwargs` are passed to `split_ranges_into_sets`.&#34;&#34;&#34;
    X = to_any_array(X)
    if isinstance(X, (pd.Series, pd.DataFrame)):
        index = X.index
    else:
        index = pd.Index(np.arange(X.shape[0]))

    # Resolve start_idxs and end_idxs
    start_idxs = np.full(len(index), 0)
    end_idxs = np.arange(len(index))

    # Filter out short ranges
    window_lens = end_idxs - start_idxs + 1
    min_len_mask = window_lens &gt;= min_len
    if not np.any(min_len_mask):
        raise ValueError(f&#34;There are no ranges that meet window_len&gt;={min_len}&#34;)
    start_idxs = start_idxs[min_len_mask]
    end_idxs = end_idxs[min_len_mask]

    # Evenly select n ranges
    if n is not None:
        if n &gt; len(start_idxs):
            raise ValueError(f&#34;n cannot be bigger than the maximum number of windows {len(start_idxs)}&#34;)
        idxs = np.round(np.linspace(0, len(start_idxs) - 1, n)).astype(int)
        start_idxs = start_idxs[idxs]
        end_idxs = end_idxs[idxs]

    return split_ranges_into_sets(start_idxs, end_idxs, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.generic.splitters.RangeSplitter"><code class="flex name class">
<span>class <span class="ident">RangeSplitter</span></span>
</code></dt>
<dd>
<div class="desc"><p>Range splitter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RangeSplitter(BaseSplitter):
    &#34;&#34;&#34;Range splitter.&#34;&#34;&#34;

    def split(self, X: tp.ArrayLike, n: tp.Optional[int] = None, range_len: tp.Optional[float] = None,
              min_len: int = 1, start_idxs: tp.Optional[tp.ArrayLike] = None,
              end_idxs: tp.Optional[tp.ArrayLike] = None, **kwargs) -&gt; RangesT:
        &#34;&#34;&#34;Either split into `n` ranges each `range_len` long, or split into ranges between
        `start_idxs` and `end_idxs`, and concatenate along the column axis.

        At least one of `range_len`, `n`, or `start_idxs` and `end_idxs` must be set:

        * If `range_len` is None, are split evenly into `n` ranges.
        * If `n` is None, returns the maximum number of ranges of length `range_len` (can be a percentage).
        * If `start_idxs` and `end_idxs`, splits into ranges between both arrays.
        Both index arrays should be either NumPy arrays with absolute positions or
        pandas indexes with labels. The last index should be inclusive. The distance
        between each start and end index can be different, and smaller ranges are filled with NaNs.

        `range_len` can be a floating number between 0 and 1 to indicate a fraction of the total range.

        `**kwargs` are passed to `split_ranges_into_sets`.&#34;&#34;&#34;
        X = to_any_array(X)
        if isinstance(X, (pd.Series, pd.DataFrame)):
            index = X.index
        else:
            index = pd.Index(np.arange(X.shape[0]))

        # Resolve start_idxs and end_idxs
        if start_idxs is None and end_idxs is None:
            if range_len is None and n is None:
                raise ValueError(&#34;At least n, range_len, or start_idxs and end_idxs must be set&#34;)
            if range_len is None:
                range_len = len(index) // n
            if 0 &lt; range_len &lt; 1:
                range_len = math.floor(range_len * len(index))
            start_idxs = np.arange(len(index) - range_len + 1)
            end_idxs = np.arange(range_len - 1, len(index))
        elif start_idxs is None or end_idxs is None:
            raise ValueError(&#34;Both start_idxs and end_idxs must be set&#34;)
        else:
            if isinstance(start_idxs, pd.Index):
                start_idxs = np.asarray([find_first_occurrence(idx, index) for idx in start_idxs])
            else:
                start_idxs = np.asarray(start_idxs)
            if isinstance(end_idxs, pd.Index):
                end_idxs = np.asarray([find_first_occurrence(idx, index) for idx in end_idxs])
            else:
                end_idxs = np.asarray(end_idxs)

        # Filter out short ranges
        start_idxs, end_idxs = np.broadcast_arrays(start_idxs, end_idxs)
        range_lens = end_idxs - start_idxs + 1
        min_len_mask = range_lens &gt;= min_len
        if not np.any(min_len_mask):
            raise ValueError(f&#34;There are no ranges that meet range_len&gt;={min_len}&#34;)
        start_idxs = start_idxs[min_len_mask]
        end_idxs = end_idxs[min_len_mask]

        # Evenly select n ranges
        if n is not None:
            if n &gt; len(start_idxs):
                raise ValueError(f&#34;n cannot be bigger than the maximum number of ranges {len(start_idxs)}&#34;)
            idxs = np.round(np.linspace(0, len(start_idxs) - 1, n)).astype(int)
            start_idxs = start_idxs[idxs]
            end_idxs = end_idxs[idxs]

        return split_ranges_into_sets(start_idxs, end_idxs, **kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.generic.splitters.BaseSplitter" href="#vectorbt.generic.splitters.BaseSplitter">BaseSplitter</a></li>
</ul>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.generic.splitters.RangeSplitter.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self, X, n=None, range_len=None, min_len=1, start_idxs=None, end_idxs=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Either split into <code>n</code> ranges each <code>range_len</code> long, or split into ranges between
<code>start_idxs</code> and <code>end_idxs</code>, and concatenate along the column axis.</p>
<p>At least one of <code>range_len</code>, <code>n</code>, or <code>start_idxs</code> and <code>end_idxs</code> must be set:</p>
<ul>
<li>If <code>range_len</code> is None, are split evenly into <code>n</code> ranges.</li>
<li>If <code>n</code> is None, returns the maximum number of ranges of length <code>range_len</code> (can be a percentage).</li>
<li>If <code>start_idxs</code> and <code>end_idxs</code>, splits into ranges between both arrays.
Both index arrays should be either NumPy arrays with absolute positions or
pandas indexes with labels. The last index should be inclusive. The distance
between each start and end index can be different, and smaller ranges are filled with NaNs.</li>
</ul>
<p><code>range_len</code> can be a floating number between 0 and 1 to indicate a fraction of the total range.</p>
<p><code>**kwargs</code> are passed to <code><a title="vectorbt.generic.splitters.split_ranges_into_sets" href="#vectorbt.generic.splitters.split_ranges_into_sets">split_ranges_into_sets()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self, X: tp.ArrayLike, n: tp.Optional[int] = None, range_len: tp.Optional[float] = None,
          min_len: int = 1, start_idxs: tp.Optional[tp.ArrayLike] = None,
          end_idxs: tp.Optional[tp.ArrayLike] = None, **kwargs) -&gt; RangesT:
    &#34;&#34;&#34;Either split into `n` ranges each `range_len` long, or split into ranges between
    `start_idxs` and `end_idxs`, and concatenate along the column axis.

    At least one of `range_len`, `n`, or `start_idxs` and `end_idxs` must be set:

    * If `range_len` is None, are split evenly into `n` ranges.
    * If `n` is None, returns the maximum number of ranges of length `range_len` (can be a percentage).
    * If `start_idxs` and `end_idxs`, splits into ranges between both arrays.
    Both index arrays should be either NumPy arrays with absolute positions or
    pandas indexes with labels. The last index should be inclusive. The distance
    between each start and end index can be different, and smaller ranges are filled with NaNs.

    `range_len` can be a floating number between 0 and 1 to indicate a fraction of the total range.

    `**kwargs` are passed to `split_ranges_into_sets`.&#34;&#34;&#34;
    X = to_any_array(X)
    if isinstance(X, (pd.Series, pd.DataFrame)):
        index = X.index
    else:
        index = pd.Index(np.arange(X.shape[0]))

    # Resolve start_idxs and end_idxs
    if start_idxs is None and end_idxs is None:
        if range_len is None and n is None:
            raise ValueError(&#34;At least n, range_len, or start_idxs and end_idxs must be set&#34;)
        if range_len is None:
            range_len = len(index) // n
        if 0 &lt; range_len &lt; 1:
            range_len = math.floor(range_len * len(index))
        start_idxs = np.arange(len(index) - range_len + 1)
        end_idxs = np.arange(range_len - 1, len(index))
    elif start_idxs is None or end_idxs is None:
        raise ValueError(&#34;Both start_idxs and end_idxs must be set&#34;)
    else:
        if isinstance(start_idxs, pd.Index):
            start_idxs = np.asarray([find_first_occurrence(idx, index) for idx in start_idxs])
        else:
            start_idxs = np.asarray(start_idxs)
        if isinstance(end_idxs, pd.Index):
            end_idxs = np.asarray([find_first_occurrence(idx, index) for idx in end_idxs])
        else:
            end_idxs = np.asarray(end_idxs)

    # Filter out short ranges
    start_idxs, end_idxs = np.broadcast_arrays(start_idxs, end_idxs)
    range_lens = end_idxs - start_idxs + 1
    min_len_mask = range_lens &gt;= min_len
    if not np.any(min_len_mask):
        raise ValueError(f&#34;There are no ranges that meet range_len&gt;={min_len}&#34;)
    start_idxs = start_idxs[min_len_mask]
    end_idxs = end_idxs[min_len_mask]

    # Evenly select n ranges
    if n is not None:
        if n &gt; len(start_idxs):
            raise ValueError(f&#34;n cannot be bigger than the maximum number of ranges {len(start_idxs)}&#34;)
        idxs = np.round(np.linspace(0, len(start_idxs) - 1, n)).astype(int)
        start_idxs = start_idxs[idxs]
        end_idxs = end_idxs[idxs]

    return split_ranges_into_sets(start_idxs, end_idxs, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.generic.splitters.RollingSplitter"><code class="flex name class">
<span>class <span class="ident">RollingSplitter</span></span>
</code></dt>
<dd>
<div class="desc"><p>Rolling walk-forward splitter.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RollingSplitter(BaseSplitter):
    &#34;&#34;&#34;Rolling walk-forward splitter.&#34;&#34;&#34;

    def split(self, X: tp.ArrayLike, n: tp.Optional[int] = None, window_len: tp.Optional[float] = None,
              min_len: int = 1, **kwargs) -&gt; RangesT:
        &#34;&#34;&#34;Split by rolling a window.

        `**kwargs` are passed to `split_ranges_into_sets`.&#34;&#34;&#34;
        X = to_any_array(X)
        if isinstance(X, (pd.Series, pd.DataFrame)):
            index = X.index
        else:
            index = pd.Index(np.arange(X.shape[0]))

        # Resolve start_idxs and end_idxs
        if window_len is None and n is None:
            raise ValueError(&#34;At least n or window_len must be set&#34;)
        if window_len is None:
            window_len = len(index) // n
        if 0 &lt; window_len &lt; 1:
            window_len = math.floor(window_len * len(index))
        start_idxs = np.arange(len(index) - window_len + 1)
        end_idxs = np.arange(window_len - 1, len(index))

        # Filter out short ranges
        window_lens = end_idxs - start_idxs + 1
        min_len_mask = window_lens &gt;= min_len
        if not np.any(min_len_mask):
            raise ValueError(f&#34;There are no ranges that meet window_len&gt;={min_len}&#34;)
        start_idxs = start_idxs[min_len_mask]
        end_idxs = end_idxs[min_len_mask]

        # Evenly select n ranges
        if n is not None:
            if n &gt; len(start_idxs):
                raise ValueError(f&#34;n cannot be bigger than the maximum number of windows {len(start_idxs)}&#34;)
            idxs = np.round(np.linspace(0, len(start_idxs) - 1, n)).astype(int)
            start_idxs = start_idxs[idxs]
            end_idxs = end_idxs[idxs]

        return split_ranges_into_sets(start_idxs, end_idxs, **kwargs)</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li><a title="vectorbt.generic.splitters.BaseSplitter" href="#vectorbt.generic.splitters.BaseSplitter">BaseSplitter</a></li>
</ul>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.generic.splitters.RollingSplitter.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self, X, n=None, window_len=None, min_len=1, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Split by rolling a window.</p>
<p><code>**kwargs</code> are passed to <code><a title="vectorbt.generic.splitters.split_ranges_into_sets" href="#vectorbt.generic.splitters.split_ranges_into_sets">split_ranges_into_sets()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self, X: tp.ArrayLike, n: tp.Optional[int] = None, window_len: tp.Optional[float] = None,
          min_len: int = 1, **kwargs) -&gt; RangesT:
    &#34;&#34;&#34;Split by rolling a window.

    `**kwargs` are passed to `split_ranges_into_sets`.&#34;&#34;&#34;
    X = to_any_array(X)
    if isinstance(X, (pd.Series, pd.DataFrame)):
        index = X.index
    else:
        index = pd.Index(np.arange(X.shape[0]))

    # Resolve start_idxs and end_idxs
    if window_len is None and n is None:
        raise ValueError(&#34;At least n or window_len must be set&#34;)
    if window_len is None:
        window_len = len(index) // n
    if 0 &lt; window_len &lt; 1:
        window_len = math.floor(window_len * len(index))
    start_idxs = np.arange(len(index) - window_len + 1)
    end_idxs = np.arange(window_len - 1, len(index))

    # Filter out short ranges
    window_lens = end_idxs - start_idxs + 1
    min_len_mask = window_lens &gt;= min_len
    if not np.any(min_len_mask):
        raise ValueError(f&#34;There are no ranges that meet window_len&gt;={min_len}&#34;)
    start_idxs = start_idxs[min_len_mask]
    end_idxs = end_idxs[min_len_mask]

    # Evenly select n ranges
    if n is not None:
        if n &gt; len(start_idxs):
            raise ValueError(f&#34;n cannot be bigger than the maximum number of windows {len(start_idxs)}&#34;)
        idxs = np.round(np.linspace(0, len(start_idxs) - 1, n)).astype(int)
        start_idxs = start_idxs[idxs]
        end_idxs = end_idxs[idxs]

    return split_ranges_into_sets(start_idxs, end_idxs, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.generic.splitters.SplitterT"><code class="flex name class">
<span>class <span class="ident">SplitterT</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for protocol classes. Protocol classes are defined as::</p>
<p>class Proto(Protocol):
def meth(self) -&gt; int:
&hellip;</p>
<p>Such classes are primarily used with static type checkers that recognize
structural subtyping (static duck-typing), for example::</p>
<p>class C:
def meth(self) -&gt; int:
return 0</p>
<p>def func(x: Proto) -&gt; int:
return x.meth()</p>
<p>func(C())
# Passes static type check</p>
<p>See PEP 544 for details. Protocol classes decorated with
@typing_extensions.runtime act as simple-minded runtime protocol that checks
only the presence of given attributes, ignoring their type signatures.</p>
<p>Protocol classes can be generic, they are defined as::</p>
<p>class GenProto(Protocol[T]):
def meth(self) -&gt; T:
&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SplitterT(tp.Protocol):
    def split(self, X: tp.ArrayLike, **kwargs) -&gt; RangesT:
        ...</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>typing_extensions.Protocol</li>
</ul>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.generic.splitters.SplitterT.split"><code class="name flex">
<span>def <span class="ident">split</span></span>(<span>self, X, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def split(self, X: tp.ArrayLike, **kwargs) -&gt; RangesT:
    ...</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRUYwMDAwO30KCS5zdDF7ZmlsbDojRkY5MDAwO30KCS5zdDJ7ZmlsbDojRkZERjAwO30KCS5zdDN7ZmlsbDojMjgyQzM0O30KPC9zdHlsZT4KPGc+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNTUuMywzMDAuMSAyODMuMSwwIDIwOCwwIDExMC44LDAgMzUuOCwwIDEuMiw0NTAuMiA3Ni4zLDQ1MC4yIAkJCSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjIzMC40LDMwMC4xIDM1OC4xLDAgMjgzLjEsMCAxODUuOCwwIDExMC44LDAgNzYuMyw0NTAuMiAxNTEuMyw0NTAuMiAJCQkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIzMDUuNCwzMDAuMSA0MzMuMSwwIDM1OC4xLDAgMzMxLjYsNjIuMyAyNjAuOCwwIDE4NS44LDAgMTUxLjMsNDUwLjIgMjI2LjQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iNTEwLjgsMCA0MzMuMSwwIDMwNS40LDMwMC4xIDMzOC40LDAgMjYwLjgsMCAyMjYuNCw0NTAuMiAzMDQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="/>
vectorbt</a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.generic" href="index.html">vectorbt.generic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vectorbt.generic.splitters.split_ranges_into_sets" href="#vectorbt.generic.splitters.split_ranges_into_sets">split_ranges_into_sets</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.generic.splitters.BaseSplitter" href="#vectorbt.generic.splitters.BaseSplitter">BaseSplitter</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.generic.splitters.BaseSplitter.split" href="#vectorbt.generic.splitters.BaseSplitter.split">split</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.generic.splitters.ExpandingSplitter" href="#vectorbt.generic.splitters.ExpandingSplitter">ExpandingSplitter</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.generic.splitters.ExpandingSplitter.split" href="#vectorbt.generic.splitters.ExpandingSplitter.split">split</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.generic.splitters.RangeSplitter" href="#vectorbt.generic.splitters.RangeSplitter">RangeSplitter</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.generic.splitters.RangeSplitter.split" href="#vectorbt.generic.splitters.RangeSplitter.split">split</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.generic.splitters.RollingSplitter" href="#vectorbt.generic.splitters.RollingSplitter">RollingSplitter</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.generic.splitters.RollingSplitter.split" href="#vectorbt.generic.splitters.RollingSplitter.split">split</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.generic.splitters.SplitterT" href="#vectorbt.generic.splitters.SplitterT">SplitterT</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.generic.splitters.SplitterT.split" href="#vectorbt.generic.splitters.SplitterT.split">split</a></code></li>
</ul>
</li>
</ul>
</li>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
</body>
</html>