<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>vectorbt.generic.stats_builder API documentation</title>
<meta name="description" content="Mixin for building statistics out of performance metrics." />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-2/css/all.min.css" integrity="sha256-46r060N2LrChLLb5zowXQ72/iKKNiw/lAmygmHExk/o=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.1.0/styles/atom-one-dark.min.css" rel="stylesheet">
<style>:root{--highlight-color:#e82}body{line-height:1.5em}.version{font-weight:normal;font-style:italic;font-size:.75em;color:#8b949e}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar>*:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #eee;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}h2[id^="header-"]{margin-top:2em}.ident{color:#900}.headerlink{color:inherit}.headerlink:hover{color:inherit}pre code{background:#f8f8f8}.hljs{padding:1.25rem 1.5rem;border:1px solid #eee;border-radius:6px;background:#282c34 !important;color:#9da29e !important;word-break:normal}.hljs-keyword{color:#ff7b72 !important}.hljs-comment{color:#8b949e !important}.hljs-meta{color:#8b949e !important}.python{color:#c5c8c6 !important}code{background:#f2f2f1;padding:1px 4px;font-size:90%}h1 code{background:transparent}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{padding-bottom:.5em;border-bottom:1px solid #e82}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 1.5em}#header-classes+dl>dd{margin-bottom:3em}dd dd{margin-left:1em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name>span:first-child{white-space:nowrap}.name.class>span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-weight:400;font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary>*{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}.badge{display:inline-block;padding:0.25em 0.4em;font-size:75%;font-weight:700;line-height:1;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.25rem;transition:color 0.15s ease-in-out,background-color 0.15s ease-in-out,border-color 0.15s ease-in-out,box-shadow 0.15s ease-in-out}@media (prefers-reduced-motion:reduce){.badge{transition:none}}a.badge:hover,a.badge:focus{text-decoration:none}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.badge-pill{padding-right:0.6em;padding-left:0.6em;border-radius:10rem}.badge-primary{color:#fff;background-color:#007bff}a.badge-primary:hover,a.badge-primary:focus{color:#fff;background-color:#0062cc}a.badge-primary:focus,a.badge-primary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(0,123,255,0.5)}.badge-secondary{color:#fff;background-color:#6c757d}a.badge-secondary:hover,a.badge-secondary:focus{color:#fff;background-color:#545b62}a.badge-secondary:focus,a.badge-secondary.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(108,117,125,0.5)}.badge-success{color:#fff;background-color:#28a745}a.badge-success:hover,a.badge-success:focus{color:#fff;background-color:#1e7e34}a.badge-success:focus,a.badge-success.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(40,167,69,0.5)}.badge-info{color:#fff;background-color:#17a2b8}a.badge-info:hover,a.badge-info:focus{color:#fff;background-color:#117a8b}a.badge-info:focus,a.badge-info.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(23,162,184,0.5)}.badge-warning{color:#212529;background-color:#ffc107}a.badge-warning:hover,a.badge-warning:focus{color:#212529;background-color:#d39e00}a.badge-warning:focus,a.badge-warning.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(255,193,7,0.5)}.badge-danger{color:#fff;background-color:#dc3545}a.badge-danger:hover,a.badge-danger:focus{color:#fff;background-color:#bd2130}a.badge-danger:focus,a.badge-danger.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(220,53,69,0.5)}.badge-light{color:#212529;background-color:#f8f9fa}a.badge-light:hover,a.badge-light:focus{color:#212529;background-color:#dae0e5}a.badge-light:focus,a.badge-light.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(248,249,250,0.5)}.badge-dark{color:#fff;background-color:#343a40}a.badge-dark:hover,a.badge-dark:focus{color:#fff;background-color:#1d2124}a.badge-dark:focus,a.badge-dark.focus{outline:0;box-shadow:0 0 0 0.2rem rgba(52,58,64,0.5)}.search-container{width:100%;margin-top:15px;margin-bottom:15px}#search_input{display:inline-block;width:100%;height:40px;padding:.375rem .75rem;font-size:1rem;line-height:1.5;color:white;background:#282c34 !important;border:none;border-radius:6px;border-bottom:1px solid #e82;outline:none}.algolia-autocomplete{width:100%;background:rgba(0,0,0,.2);border:none;border-radius:6px}.algolia-autocomplete input{display:none}.index-caption{color:white}#index a,#index h3,.toc a{color:white}#index a:hover,.toc a:hover{color:#e82}#sidebar{background:#393f4a}.toc ul ul,#index ul{padding-left:1.5em}.toc>ul>li{margin-top:.5em}pre{position:relative;background:#fafafa}pre .btnIcon{position:absolute;top:4px;z-index:2;cursor:pointer;border:1px solid transparent;padding:0;color:#383a42;background-color:transparent;height:30px;transition:all .25s ease-out}pre .btnIcon:hover{text-decoration:none}.btnIcon__body{align-items:center;display:flex;color:#abb2bf}.btnIcon svg{fill:currentColor;margin-right:.4em}.btnIcon__label{font-size:11px}.btnClipboard{right:10px}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{min-width:400px;height:100vh;overflow:visible;position:sticky;top:0}#content{width:100%;max-width:100ch;padding:3em 4em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.scrollable-index{overflow-y:scroll;height:calc(100vh - 250px)}.hljs{margin-left:-15px;margin-right:-15px}.source pre code{margin-left:0px;margin-right:0px}dd{margin:0 0 1em 3em}dd dd{margin-left:2em}.flex{display:flex !important}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4QLCS0J048"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-4QLCS0J048');
</script>
<style>.homelink{display:block;font-size:2em;font-weight:bold;color:white}.homelink:hover{color:#e82}.homelink img{max-width:100px;max-height:100px;margin:auto;margin-bottom:.3em}</style>
<link rel="apple-touch-icon" sizes="180x180" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon-16x16.png">
<link rel="manifest" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/site.webmanifest">
<link rel="icon" href="https://raw.githubusercontent.com/polakowo/vectorbt/master/static/favicon/favicon.ico">
<meta name="msapplication-TileColor" content="#282c34">
<meta name="theme-color" content="#282c34">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vectorbt.generic.stats_builder</code></h1>
</header>
<section id="section-intro">
<p>Mixin for building statistics out of performance metrics.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright (c) 2021 Oleg Polakow. All rights reserved.
# This code is licensed under Apache 2.0 with Commons Clause license (see LICENSE.md for details)

&#34;&#34;&#34;Mixin for building statistics out of performance metrics.&#34;&#34;&#34;

import pandas as pd
import numpy as np
from collections import Counter
import warnings
import inspect
import string

from vectorbt import _typing as tp
from vectorbt.utils import checks
from vectorbt.utils.config import Config, merge_dicts, get_func_arg_names
from vectorbt.utils.template import deep_substitute
from vectorbt.utils.tags import match_tags
from vectorbt.utils.attr import get_dict_attr
from vectorbt.base.array_wrapper import Wrapping


class MetaStatsBuilderMixin(type):
    &#34;&#34;&#34;Meta class that exposes a read-only class property `StatsBuilderMixin.metrics`.&#34;&#34;&#34;

    @property
    def metrics(cls) -&gt; Config:
        &#34;&#34;&#34;Metrics supported by `StatsBuilderMixin.stats`.&#34;&#34;&#34;
        return cls._metrics


class StatsBuilderMixin(metaclass=MetaStatsBuilderMixin):
    &#34;&#34;&#34;Mixin that implements `StatsBuilderMixin.stats`.

    Required to be a subclass of `vectorbt.base.array_wrapper.Wrapping`.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        checks.assert_instance_of(self, Wrapping)

        # Copy writeable attrs
        self._metrics = self.__class__._metrics.copy()

    @property
    def writeable_attrs(self) -&gt; tp.Set[str]:
        &#34;&#34;&#34;Set of writeable attributes that will be saved/copied along with the config.&#34;&#34;&#34;
        return {&#39;_metrics&#39;}

    @property
    def stats_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `StatsBuilderMixin.stats`.

        See `stats_builder` in `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        stats_builder_cfg = settings[&#39;stats_builder&#39;]

        return merge_dicts(
            stats_builder_cfg,
            dict(settings=dict(freq=self.wrapper.freq))
        )

    _metrics: tp.ClassVar[Config] = Config(
        dict(
            start=dict(
                title=&#39;Start&#39;,
                calc_func=lambda self: self.wrapper.index[0],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            end=dict(
                title=&#39;End&#39;,
                calc_func=lambda self: self.wrapper.index[-1],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            period=dict(
                title=&#39;Period&#39;,
                calc_func=lambda self: len(self.wrapper.index),
                apply_to_timedelta=True,
                agg_func=None,
                tags=&#39;wrapper&#39;
            )
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def metrics(self) -&gt; Config:
        &#34;&#34;&#34;Metrics supported by `${cls_name}`.

        ```json
        ${metrics}
        ```

        Returns `${cls_name}._metrics`, which gets (deep) copied upon creation of each instance.
        Thus, changing this config won&#39;t affect the class.

        To change metrics, you can either change the config in-place, override this property,
        or overwrite the instance variable `${cls_name}._metrics`.&#34;&#34;&#34;
        return self._metrics

    def stats(self,
              metrics: tp.Optional[tp.MaybeIterable[tp.Union[str, tp.Tuple[str, tp.Kwargs]]]] = None,
              tags: tp.Optional[tp.MaybeIterable[str]] = None,
              column: tp.Optional[tp.Label] = None,
              group_by: tp.GroupByLike = None,
              agg_func: tp.Optional[tp.Callable] = np.mean,
              silence_warnings: tp.Optional[bool] = None,
              template_mapping: tp.Optional[tp.Mapping] = None,
              settings: tp.KwargsLike = None,
              filters: tp.KwargsLike = None,
              metric_settings: tp.KwargsLike = None) -&gt; tp.Optional[tp.SeriesFrame]:
        &#34;&#34;&#34;Compute various metrics on this object.

        Args:
            metrics (str, tuple, iterable, or dict): Metrics to calculate.

                Each element can be either:

                * a metric name (see keys in `StatsBuilderMixin.metrics`)
                * a tuple of a metric name and a settings dict as in `StatsBuilderMixin.metrics`.

                The settings dict can contain the following keys:

                * `title`: Title of the metric. Defaults to the name.
                * `tags`: Single or multiple tags to associate this metric with.
                    If any of these tags is in `tags`, keeps this metric.
                * `check_{filter}` and `inv_check_{filter}`: Whether to check this metric against a
                    filter defined in `filters`. True (or False for inverse) means to keep this metric.
                * `calc_func` (required): Calculation function for custom metrics.
                    Should return either a scalar for one column/group, pd.Series for multiple columns/groups,
                    or a dict of such for multiple sub-metrics.
                * `resolve_calc_func`: whether to resolve `calc_func`. If the function can be accessed
                    by traversing attributes of this object, you can specify the path to this function
                    as a string (see `vectorbt.utils.attr.deep_getattr` for the path format).
                    If `calc_func` is a function, arguments from merged metric settings are matched with
                    arguments in the signature (see below). If `resolve_calc_func` is False, `calc_func`
                    should accept (resolved) self and dictionary of merged metric settings.
                    Defaults to True.
                * `post_calc_func`: Function to post-process the result of `calc_func`.
                    Should accept (resolved) self, output of `calc_func`, and dictionary of merged metric settings,
                    and return whatever is acceptable to be returned by `calc_func`. Defaults to None.
                * `fill_wrap_kwargs`: Whether to fill `wrap_kwargs` with `to_timedelta` and `silence_warnings`.
                    Defaults to False.
                * `apply_to_timedelta`: Whether to apply `vectorbt.base.array_wrapper.ArrayWrapper.to_timedelta`
                    on the result. To disable this globally, pass `to_timedelta=False` in `settings`.
                    Defaults to False.
                * `pass_{arg}`: Whether to pass any argument from the settings (see below). Defaults to True if
                    this argument was found in the function&#39;s signature. Set to False to not pass.
                    If argument to be passed was not found, `pass_{arg}` is removed.
                * `resolve_path_{arg}`: Whether to resolve an argument that is meant to be an attribute of
                    this object and is the first part of the path of `calc_func`. Passes only optional arguments.
                    Defaults to True. See `vectorbt.utils.attr.AttrResolver.resolve_attr`.
                * `resolve_{arg}`: Whether to resolve an argument that is meant to be an attribute of
                    this object and is present in the function&#39;s signature. Defaults to False.
                    See `vectorbt.utils.attr.AttrResolver.resolve_attr`.
                * `template_mapping`: Mapping to replace templates in metric settings. Used across all settings.
                * Any other keyword argument that overrides the settings or is passed directly to `calc_func`.

                If `resolve_calc_func` is True, the calculation function may &#34;request&#34; any of the
                following arguments by accepting them or if `pass_{arg}` was found in the settings dict:

                * Each of `vectorbt.utils.attr.AttrResolver.self_aliases`: original object
                    (ungrouped, with no column selected)
                * `group_by`: won&#39;t be passed if it was used in resolving the first attribute of `calc_func`
                    specified as a path, use `pass_group_by=True` to pass anyway
                * `column`
                * `metric_name`
                * `agg_func`
                * `silence_warnings`
                * `to_timedelta`: replaced by True if None and frequency is set
                * Any argument from `settings`
                * Any attribute of this object if it meant to be resolved
                    (see `vectorbt.utils.attr.AttrResolver.resolve_attr`)

                Pass `metrics=&#39;all&#39;` to calculate all supported metrics.
            tags (str or iterable): Tags to select.

                See `vectorbt.utils.tags.match_tags`.
            column (str): Name of the column/group.

                !!! hint
                    There are two ways to select a column: `obj[&#39;a&#39;].stats()` and `obj.stats(column=&#39;a&#39;)`.
                    They both accomplish the same thing but in different ways: `obj[&#39;a&#39;].stats()` computes
                    statistics of the column &#39;a&#39; only, while `obj.stats(column=&#39;a&#39;)` computes statistics of
                    all columns first and only then selects the column &#39;a&#39;. The first method is preferred
                    when you have a lot of data or caching is disabled. The second method is preferred when
                    most attributes have already been cached.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            agg_func (callable): Aggregation function to aggregate statistics across all columns.
                Defaults to mean.

                Should take `pd.Series` and return a const.

                Has only effect if `column` was specified or this object contains only one column of data.

                If `agg_func` has been overridden by a metric:

                * it only takes effect if global `agg_func` is not None
                * will raise a warning if it&#39;s None but the result of calculation has multiple values
            silence_warnings (bool): Whether to silence all warnings.
            template_mapping (mapping): Global mapping to replace templates.

                Gets merged over `template_mapping` from `StatsBuilderMixin.stats_defaults`.

                Applied on `settings` and then on each metric settings.
            filters (dict): Filters to apply.

                Each item consists of the filter name and settings dict.

                The settings dict can contain the following keys:

                * `filter_func`: Filter function that should accept resolved self and
                    merged settings for a metric, and return either True or False.
                * `warning_message`: Warning message to be shown when skipping a metric.
                    Can be a template that will be substituted using merged metric settings as mapping.
                    Defaults to None.
                * `inv_warning_message`: Same as `warning_message` but for inverse checks.

                Gets merged over `filters` from `StatsBuilderMixin.stats_defaults`.
            settings (dict): Global settings and resolution arguments.

                Extends/overrides `settings` from `StatsBuilderMixin.stats_defaults`.
                Gets extended/overridden by metric settings.
            metric_settings (dict): Keyword arguments for each metric.

                Extends/overrides all global and metric settings.

        For template logic, see `vectorbt.utils.template`.

        For defaults, see `StatsBuilderMixin.stats_defaults`.

        !!! hint
            There are two types of arguments: optional (or resolution) and mandatory arguments.
            Optional arguments are only passed if they are found in the function&#39;s signature.
            Mandatory arguments are passed regardless of this. Optional arguments can only be defined
            using `settings` (that is, globally), while mandatory arguments can be defined both using
            default metric settings and `{metric_name}_kwargs`. Overriding optional arguments using default
            metric settings or `{metric_name}_kwargs` won&#39;t turn them into mandatory. For this, pass `pass_{arg}=True`.

        !!! hint
            Make sure to resolve and then to re-use as many object attributes as possible to
            utilize built-in caching (even if global caching is disabled).

        ## Example

        See `vectorbt.portfolio.base` for examples.
        &#34;&#34;&#34;
        # Resolve defaults
        if silence_warnings is None:
            silence_warnings = self.stats_defaults.get(&#39;silence_warnings&#39;, False)
        template_mapping = merge_dicts(self.stats_defaults.get(&#39;template_mapping&#39;, {}), template_mapping)
        filters = merge_dicts(self.stats_defaults.get(&#39;filters&#39;, {}), filters)
        settings = merge_dicts(self.stats_defaults.get(&#39;settings&#39;, {}), settings)
        metric_settings = merge_dicts(self.stats_defaults.get(&#39;metric_settings&#39;, {}), metric_settings)

        # Replace templates globally (not used at metric level)
        if len(template_mapping) &gt; 0:
            sub_settings = deep_substitute(settings, mapping=template_mapping)
        else:
            sub_settings = settings

        # Resolve self
        reself = self.resolve_self(
            cond_kwargs=sub_settings,
            impacts_caching=False,
            silence_warnings=silence_warnings
        )

        # Prepare metrics
        if metrics is None:
            metrics = reself.stats_defaults.get(&#39;metrics&#39;, &#39;all&#39;)
        if metrics == &#39;all&#39;:
            metrics = reself.metrics
        if isinstance(metrics, dict):
            metrics = list(metrics.items())
        if isinstance(metrics, (str, tuple)):
            metrics = [metrics]

        # Prepare tags
        if tags is None:
            tags = reself.stats_defaults.get(&#39;tags&#39;, &#39;all&#39;)
        if isinstance(tags, str) and tags == &#39;all&#39;:
            tags = None
        if isinstance(tags, (str, tuple)):
            tags = [tags]

        # Bring to the same shape
        new_metrics = []
        for i, metric in enumerate(metrics):
            if isinstance(metric, str):
                metric = (metric, reself.metrics[metric])
            if not isinstance(metric, tuple):
                raise TypeError(f&#34;Metric at index {i} must be either a string or a tuple&#34;)
            new_metrics.append(metric)
        metrics = new_metrics

        # Handle duplicate names
        metric_counts = Counter(list(map(lambda x: x[0], metrics)))
        metric_i = {k: -1 for k in metric_counts.keys()}
        metrics_dct = {}
        for i, (metric_name, _metric_settings) in enumerate(metrics):
            if metric_counts[metric_name] &gt; 1:
                metric_i[metric_name] += 1
                metric_name = metric_name + &#39;_&#39; + str(metric_i[metric_name])
            metrics_dct[metric_name] = _metric_settings

        # Check metric_settings
        missed_keys = set(metric_settings.keys()).difference(set(metrics_dct.keys()))
        if len(missed_keys) &gt; 0:
            raise ValueError(f&#34;Keys {missed_keys} in metric_settings could not be matched with any metric&#34;)

        # Merge settings
        opt_arg_names_dct = {}
        custom_arg_names_dct = {}
        resolved_self_dct = {}
        mapping_dct = {}
        for metric_name, _metric_settings in list(metrics_dct.items()):
            opt_settings = merge_dicts(
                {name: reself for name in reself.self_aliases},
                dict(
                    column=column,
                    group_by=group_by,
                    metric_name=metric_name,
                    agg_func=agg_func,
                    silence_warnings=silence_warnings,
                    to_timedelta=None
                ),
                settings
            )
            _metric_settings = _metric_settings.copy()
            passed_metric_settings = metric_settings.get(metric_name, {})
            merged_settings = merge_dicts(
                opt_settings,
                _metric_settings,
                passed_metric_settings
            )
            metric_template_mapping = merged_settings.pop(&#39;template_mapping&#39;, {})
            template_mapping_merged = merge_dicts(template_mapping, metric_template_mapping)
            template_mapping_merged = deep_substitute(template_mapping_merged, mapping=merged_settings)
            mapping = merge_dicts(template_mapping_merged, merged_settings)
            merged_settings = deep_substitute(merged_settings, mapping=mapping)

            # Filter by tag
            if tags is not None:
                in_tags = merged_settings.get(&#39;tags&#39;, None)
                if in_tags is None or not match_tags(tags, in_tags):
                    metrics_dct.pop(metric_name, None)
                    continue

            custom_arg_names = set(_metric_settings.keys()).union(set(passed_metric_settings.keys()))
            opt_arg_names = set(opt_settings.keys())
            custom_reself = reself.resolve_self(
                cond_kwargs=merged_settings,
                custom_arg_names=custom_arg_names,
                impacts_caching=True,
                silence_warnings=merged_settings[&#39;silence_warnings&#39;]
            )

            metrics_dct[metric_name] = merged_settings
            custom_arg_names_dct[metric_name] = custom_arg_names
            opt_arg_names_dct[metric_name] = opt_arg_names
            resolved_self_dct[metric_name] = custom_reself
            mapping_dct[metric_name] = mapping

        # Filter metrics
        for metric_name, _metric_settings in list(metrics_dct.items()):
            custom_reself = resolved_self_dct[metric_name]
            mapping = mapping_dct[metric_name]
            _silence_warnings = _metric_settings.get(&#39;silence_warnings&#39;)

            metric_filters = set()
            for k in _metric_settings.keys():
                filter_name = None
                if k.startswith(&#39;check_&#39;):
                    filter_name = k[len(&#39;check_&#39;):]
                elif k.startswith(&#39;inv_check_&#39;):
                    filter_name = k[len(&#39;inv_check_&#39;):]
                if filter_name is not None:
                    if filter_name not in filters:
                        raise ValueError(f&#34;Metric &#39;{metric_name}&#39; requires filter &#39;{filter_name}&#39;&#34;)
                    metric_filters.add(filter_name)

            for filter_name in metric_filters:
                filter_settings = filters[filter_name]
                _filter_settings = deep_substitute(filter_settings, mapping=mapping)
                filter_func = _filter_settings[&#39;filter_func&#39;]
                warning_message = _filter_settings.get(&#39;warning_message&#39;, None)
                inv_warning_message = _filter_settings.get(&#39;inv_warning_message&#39;, None)
                to_check = _metric_settings.get(&#39;check_&#39; + filter_name, False)
                inv_to_check = _metric_settings.get(&#39;inv_check_&#39; + filter_name, False)

                if to_check or inv_to_check:
                    whether_true = filter_func(custom_reself, _metric_settings)
                    to_remove = (to_check and not whether_true) or (inv_to_check and whether_true)
                    if to_remove:
                        if to_check and warning_message is not None and not _silence_warnings:
                            warnings.warn(warning_message)
                        if inv_to_check and inv_warning_message is not None and not _silence_warnings:
                            warnings.warn(inv_warning_message)

                        metrics_dct.pop(metric_name, None)
                        custom_arg_names_dct.pop(metric_name, None)
                        opt_arg_names_dct.pop(metric_name, None)
                        resolved_self_dct.pop(metric_name, None)
                        mapping_dct.pop(metric_name, None)
                        break

        # Any metrics left?
        if len(metrics_dct) == 0:
            if not silence_warnings:
                warnings.warn(&#34;No metrics to calculate&#34;, stacklevel=2)
            return None

        # Compute stats
        arg_cache_dct = {}
        stats_dct = {}
        used_agg_func = False
        for i, (metric_name, _metric_settings) in enumerate(metrics_dct.items()):
            try:
                final_kwargs = _metric_settings.copy()
                opt_arg_names = opt_arg_names_dct[metric_name]
                custom_arg_names = custom_arg_names_dct[metric_name]
                custom_reself = resolved_self_dct[metric_name]

                # Clean up keys
                for k, v in list(final_kwargs.items()):
                    if k.startswith(&#39;check_&#39;) or k.startswith(&#39;inv_check_&#39;) or k in (&#39;tags&#39;,):
                        final_kwargs.pop(k, None)

                # Get metric-specific values
                _column = final_kwargs.get(&#39;column&#39;)
                _group_by = final_kwargs.get(&#39;group_by&#39;)
                _agg_func = final_kwargs.get(&#39;agg_func&#39;)
                _silence_warnings = final_kwargs.get(&#39;silence_warnings&#39;)
                if final_kwargs[&#39;to_timedelta&#39;] is None:
                    final_kwargs[&#39;to_timedelta&#39;] = custom_reself.wrapper.freq is not None
                to_timedelta = final_kwargs.get(&#39;to_timedelta&#39;)
                title = final_kwargs.pop(&#39;title&#39;, metric_name)
                calc_func = final_kwargs.pop(&#39;calc_func&#39;)
                resolve_calc_func = final_kwargs.pop(&#39;resolve_calc_func&#39;, True)
                post_calc_func = final_kwargs.pop(&#39;post_calc_func&#39;, None)
                use_caching = final_kwargs.pop(&#39;use_caching&#39;, True)
                fill_wrap_kwargs = final_kwargs.pop(&#39;fill_wrap_kwargs&#39;, False)
                if fill_wrap_kwargs:
                    final_kwargs[&#39;wrap_kwargs&#39;] = merge_dicts(
                        dict(to_timedelta=to_timedelta, silence_warnings=_silence_warnings),
                        final_kwargs.get(&#39;wrap_kwargs&#39;, None)
                    )
                apply_to_timedelta = final_kwargs.pop(&#39;apply_to_timedelta&#39;, False)

                # Resolve calc_func
                if resolve_calc_func:
                    if not callable(calc_func):
                        passed_kwargs_out = {}

                        def _getattr_func(obj: tp.Any,
                                          attr: str,
                                          args: tp.ArgsLike = None,
                                          kwargs: tp.KwargsLike = None,
                                          call_attr: bool = True,
                                          _final_kwargs: tp.Kwargs = final_kwargs,
                                          _opt_arg_names: tp.Set[str] = opt_arg_names,
                                          _custom_arg_names: tp.Set[str] = custom_arg_names,
                                          _arg_cache_dct: tp.Kwargs = arg_cache_dct) -&gt; tp.Any:
                            if attr in final_kwargs:
                                return final_kwargs[attr]
                            if args is None:
                                args = ()
                            if kwargs is None:
                                kwargs = {}
                            if obj is custom_reself and _final_kwargs.pop(&#39;resolve_path_&#39; + attr, True):
                                if call_attr:
                                    return custom_reself.resolve_attr(
                                        attr,
                                        args=args,
                                        cond_kwargs={k: v for k, v in _final_kwargs.items() if k in _opt_arg_names},
                                        kwargs=kwargs,
                                        custom_arg_names=_custom_arg_names,
                                        cache_dct=_arg_cache_dct,
                                        use_caching=use_caching,
                                        passed_kwargs_out=passed_kwargs_out
                                    )
                                return getattr(obj, attr)
                            out = getattr(obj, attr)
                            if callable(out) and call_attr:
                                return out(*args, **kwargs)
                            return out

                        calc_func = custom_reself.deep_getattr(
                            calc_func,
                            getattr_func=_getattr_func,
                            call_last_attr=False
                        )

                        if &#39;group_by&#39; in passed_kwargs_out:
                            if &#39;pass_group_by&#39; not in final_kwargs:
                                final_kwargs.pop(&#39;group_by&#39;, None)

                    # Resolve arguments
                    if callable(calc_func):
                        func_arg_names = get_func_arg_names(calc_func)
                        for k in func_arg_names:
                            if k not in final_kwargs:
                                if final_kwargs.pop(&#39;resolve_&#39; + k, False):
                                    try:
                                        arg_out = custom_reself.resolve_attr(
                                            k,
                                            cond_kwargs=final_kwargs,
                                            custom_arg_names=custom_arg_names,
                                            cache_dct=arg_cache_dct,
                                            use_caching=use_caching
                                        )
                                    except AttributeError:
                                        continue
                                    final_kwargs[k] = arg_out
                        for k in list(final_kwargs.keys()):
                            if k in opt_arg_names:
                                if &#39;pass_&#39; + k in final_kwargs:
                                    if not final_kwargs.get(&#39;pass_&#39; + k):  # first priority
                                        final_kwargs.pop(k, None)
                                elif k not in func_arg_names:  # second priority
                                    final_kwargs.pop(k, None)
                        for k in list(final_kwargs.keys()):
                            if k.startswith(&#39;pass_&#39;) or k.startswith(&#39;resolve_&#39;):
                                final_kwargs.pop(k, None)  # cleanup

                        # Call calc_func
                        out = calc_func(**final_kwargs)
                    else:
                        # calc_func is already a result
                        out = calc_func
                else:
                    # Do not resolve calc_func
                    out = calc_func(custom_reself, _metric_settings)

                # Call post_calc_func
                if post_calc_func is not None:
                    out = post_calc_func(custom_reself, out, _metric_settings)

                # Post-process and store the metric
                multiple = True
                if not isinstance(out, dict):
                    multiple = False
                    out = {None: out}
                for k, v in out.items():
                    # Resolve title
                    if multiple:
                        if title is None:
                            t = str(k)
                        else:
                            t = title + &#39;: &#39; + str(k)
                    else:
                        t = title

                    # Check result type
                    if checks.is_any_array(v) and not checks.is_series(v):
                        raise TypeError(&#34;calc_func must return either a scalar for one column/group, &#34;
                                        &#34;pd.Series for multiple columns/groups, or a dict of such. &#34;
                                        f&#34;Not {type(v)}.&#34;)

                    # Handle apply_to_timedelta
                    if apply_to_timedelta and to_timedelta:
                        v = custom_reself.wrapper.to_timedelta(v, silence_warnings=_silence_warnings)

                    # Select column or aggregate
                    if checks.is_series(v):
                        if _column is not None:
                            v = custom_reself.select_one_from_obj(
                                v, custom_reself.wrapper.regroup(_group_by), column=_column)
                        elif _agg_func is not None and agg_func is not None:
                            v = _agg_func(v)
                            used_agg_func = True
                        elif _agg_func is None and agg_func is not None:
                            if not _silence_warnings:
                                warnings.warn(f&#34;Metric &#39;{metric_name}&#39; returned multiple values &#34;
                                              f&#34;despite having no aggregation function&#34;, stacklevel=2)
                            continue

                    # Store metric
                    if t in stats_dct:
                        if not _silence_warnings:
                            warnings.warn(f&#34;Duplicate metric title &#39;{t}&#39;&#34;, stacklevel=2)
                    stats_dct[t] = v
            except Exception as e:
                warnings.warn(f&#34;Metric &#39;{metric_name}&#39; raised an exception&#34;, stacklevel=2)
                raise e

        # Return the stats
        if reself.wrapper.get_ndim(group_by=group_by) == 1:
            return pd.Series(stats_dct, name=reself.wrapper.get_name(group_by=group_by))
        if column is not None:
            return pd.Series(stats_dct, name=column)
        if agg_func is not None:
            if used_agg_func and not silence_warnings:
                warnings.warn(f&#34;Object has multiple columns. Aggregating using {agg_func}. &#34;
                              f&#34;Pass column to select a single column/group.&#34;, stacklevel=2)
            return pd.Series(stats_dct, name=&#39;agg_func_&#39; + agg_func.__name__)
        new_index = reself.wrapper.grouper.get_columns(group_by=group_by)
        stats_df = pd.DataFrame(stats_dct, index=new_index)
        return stats_df

    # ############# Docs ############# #

    @classmethod
    def build_metrics_doc(cls, source_cls: tp.Optional[type] = None) -&gt; str:
        &#34;&#34;&#34;Build metrics documentation.&#34;&#34;&#34;
        if source_cls is None:
            source_cls = StatsBuilderMixin
        return string.Template(
            inspect.cleandoc(get_dict_attr(source_cls, &#39;metrics&#39;).__doc__)
        ).substitute(
            {&#39;metrics&#39;: cls.metrics.to_doc(), &#39;cls_name&#39;: cls.__name__}
        )

    @classmethod
    def override_metrics_doc(cls, __pdoc__: dict, source_cls: tp.Optional[type] = None) -&gt; None:
        &#34;&#34;&#34;Call this method on each subclass that overrides `metrics`.&#34;&#34;&#34;
        __pdoc__[cls.__name__ + &#39;.metrics&#39;] = cls.build_metrics_doc(source_cls=source_cls)


__pdoc__ = dict()
StatsBuilderMixin.override_metrics_doc(__pdoc__)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vectorbt.generic.stats_builder.MetaStatsBuilderMixin"><code class="flex name class">
<span>class <span class="ident parent-name">MetaStatsBuilderMixin</span></span>
(<span class="params">*args, **kwargs</span>)
</code></dt>
<dd>
<div class="desc"><p>Meta class that exposes a read-only class property <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.metrics" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.metrics">StatsBuilderMixin.metrics</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MetaStatsBuilderMixin(type):
    &#34;&#34;&#34;Meta class that exposes a read-only class property `StatsBuilderMixin.metrics`.&#34;&#34;&#34;

    @property
    def metrics(cls) -&gt; Config:
        &#34;&#34;&#34;Metrics supported by `StatsBuilderMixin.stats`.&#34;&#34;&#34;
        return cls._metrics</code></pre>
</details>
<h3 class="section-subtitle">Ancestors</h3>
<ul class="hlist">
<li>builtins.type</li>
</ul>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.data.base.MetaData" href="../data/base.html#vectorbt.data.base.MetaData">MetaData</a></li>
<li><a title="vectorbt.generic.accessors.MetaGenericAccessor" href="accessors.html#vectorbt.generic.accessors.MetaGenericAccessor">MetaGenericAccessor</a></li>
<li><a title="vectorbt.indicators.factory.MetaIndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.MetaIndicatorBase">MetaIndicatorBase</a></li>
<li><a title="vectorbt.portfolio.base.MetaPortfolio" href="../portfolio/base.html#vectorbt.portfolio.base.MetaPortfolio">MetaPortfolio</a></li>
<li><a title="vectorbt.records.base.MetaRecords" href="../records/base.html#vectorbt.records.base.MetaRecords">MetaRecords</a></li>
<li><a title="vectorbt.records.mapped_array.MetaMappedArray" href="../records/mapped_array.html#vectorbt.records.mapped_array.MetaMappedArray">MetaMappedArray</a></li>
</ul>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.generic.stats_builder.MetaStatsBuilderMixin.metrics"><code class="name">var <span class="ident child-name">metrics</span></code></dt>
<dd>
<div class="desc"><p>Metrics supported by <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def metrics(cls) -&gt; Config:
    &#34;&#34;&#34;Metrics supported by `StatsBuilderMixin.stats`.&#34;&#34;&#34;
    return cls._metrics</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vectorbt.generic.stats_builder.StatsBuilderMixin"><code class="flex name class">
<span>class <span class="ident parent-name">StatsBuilderMixin</span></span>
</code></dt>
<dd>
<div class="desc"><p>Mixin that implements <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code>.</p>
<p>Required to be a subclass of <code><a title="vectorbt.base.array_wrapper.Wrapping" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.Wrapping">Wrapping</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StatsBuilderMixin(metaclass=MetaStatsBuilderMixin):
    &#34;&#34;&#34;Mixin that implements `StatsBuilderMixin.stats`.

    Required to be a subclass of `vectorbt.base.array_wrapper.Wrapping`.&#34;&#34;&#34;

    def __init__(self) -&gt; None:
        checks.assert_instance_of(self, Wrapping)

        # Copy writeable attrs
        self._metrics = self.__class__._metrics.copy()

    @property
    def writeable_attrs(self) -&gt; tp.Set[str]:
        &#34;&#34;&#34;Set of writeable attributes that will be saved/copied along with the config.&#34;&#34;&#34;
        return {&#39;_metrics&#39;}

    @property
    def stats_defaults(self) -&gt; tp.Kwargs:
        &#34;&#34;&#34;Defaults for `StatsBuilderMixin.stats`.

        See `stats_builder` in `vectorbt._settings.settings`.&#34;&#34;&#34;
        from vectorbt._settings import settings
        stats_builder_cfg = settings[&#39;stats_builder&#39;]

        return merge_dicts(
            stats_builder_cfg,
            dict(settings=dict(freq=self.wrapper.freq))
        )

    _metrics: tp.ClassVar[Config] = Config(
        dict(
            start=dict(
                title=&#39;Start&#39;,
                calc_func=lambda self: self.wrapper.index[0],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            end=dict(
                title=&#39;End&#39;,
                calc_func=lambda self: self.wrapper.index[-1],
                agg_func=None,
                tags=&#39;wrapper&#39;
            ),
            period=dict(
                title=&#39;Period&#39;,
                calc_func=lambda self: len(self.wrapper.index),
                apply_to_timedelta=True,
                agg_func=None,
                tags=&#39;wrapper&#39;
            )
        ),
        copy_kwargs=dict(copy_mode=&#39;deep&#39;)
    )

    @property
    def metrics(self) -&gt; Config:
        &#34;&#34;&#34;Metrics supported by `${cls_name}`.

        ```json
        ${metrics}
        ```

        Returns `${cls_name}._metrics`, which gets (deep) copied upon creation of each instance.
        Thus, changing this config won&#39;t affect the class.

        To change metrics, you can either change the config in-place, override this property,
        or overwrite the instance variable `${cls_name}._metrics`.&#34;&#34;&#34;
        return self._metrics

    def stats(self,
              metrics: tp.Optional[tp.MaybeIterable[tp.Union[str, tp.Tuple[str, tp.Kwargs]]]] = None,
              tags: tp.Optional[tp.MaybeIterable[str]] = None,
              column: tp.Optional[tp.Label] = None,
              group_by: tp.GroupByLike = None,
              agg_func: tp.Optional[tp.Callable] = np.mean,
              silence_warnings: tp.Optional[bool] = None,
              template_mapping: tp.Optional[tp.Mapping] = None,
              settings: tp.KwargsLike = None,
              filters: tp.KwargsLike = None,
              metric_settings: tp.KwargsLike = None) -&gt; tp.Optional[tp.SeriesFrame]:
        &#34;&#34;&#34;Compute various metrics on this object.

        Args:
            metrics (str, tuple, iterable, or dict): Metrics to calculate.

                Each element can be either:

                * a metric name (see keys in `StatsBuilderMixin.metrics`)
                * a tuple of a metric name and a settings dict as in `StatsBuilderMixin.metrics`.

                The settings dict can contain the following keys:

                * `title`: Title of the metric. Defaults to the name.
                * `tags`: Single or multiple tags to associate this metric with.
                    If any of these tags is in `tags`, keeps this metric.
                * `check_{filter}` and `inv_check_{filter}`: Whether to check this metric against a
                    filter defined in `filters`. True (or False for inverse) means to keep this metric.
                * `calc_func` (required): Calculation function for custom metrics.
                    Should return either a scalar for one column/group, pd.Series for multiple columns/groups,
                    or a dict of such for multiple sub-metrics.
                * `resolve_calc_func`: whether to resolve `calc_func`. If the function can be accessed
                    by traversing attributes of this object, you can specify the path to this function
                    as a string (see `vectorbt.utils.attr.deep_getattr` for the path format).
                    If `calc_func` is a function, arguments from merged metric settings are matched with
                    arguments in the signature (see below). If `resolve_calc_func` is False, `calc_func`
                    should accept (resolved) self and dictionary of merged metric settings.
                    Defaults to True.
                * `post_calc_func`: Function to post-process the result of `calc_func`.
                    Should accept (resolved) self, output of `calc_func`, and dictionary of merged metric settings,
                    and return whatever is acceptable to be returned by `calc_func`. Defaults to None.
                * `fill_wrap_kwargs`: Whether to fill `wrap_kwargs` with `to_timedelta` and `silence_warnings`.
                    Defaults to False.
                * `apply_to_timedelta`: Whether to apply `vectorbt.base.array_wrapper.ArrayWrapper.to_timedelta`
                    on the result. To disable this globally, pass `to_timedelta=False` in `settings`.
                    Defaults to False.
                * `pass_{arg}`: Whether to pass any argument from the settings (see below). Defaults to True if
                    this argument was found in the function&#39;s signature. Set to False to not pass.
                    If argument to be passed was not found, `pass_{arg}` is removed.
                * `resolve_path_{arg}`: Whether to resolve an argument that is meant to be an attribute of
                    this object and is the first part of the path of `calc_func`. Passes only optional arguments.
                    Defaults to True. See `vectorbt.utils.attr.AttrResolver.resolve_attr`.
                * `resolve_{arg}`: Whether to resolve an argument that is meant to be an attribute of
                    this object and is present in the function&#39;s signature. Defaults to False.
                    See `vectorbt.utils.attr.AttrResolver.resolve_attr`.
                * `template_mapping`: Mapping to replace templates in metric settings. Used across all settings.
                * Any other keyword argument that overrides the settings or is passed directly to `calc_func`.

                If `resolve_calc_func` is True, the calculation function may &#34;request&#34; any of the
                following arguments by accepting them or if `pass_{arg}` was found in the settings dict:

                * Each of `vectorbt.utils.attr.AttrResolver.self_aliases`: original object
                    (ungrouped, with no column selected)
                * `group_by`: won&#39;t be passed if it was used in resolving the first attribute of `calc_func`
                    specified as a path, use `pass_group_by=True` to pass anyway
                * `column`
                * `metric_name`
                * `agg_func`
                * `silence_warnings`
                * `to_timedelta`: replaced by True if None and frequency is set
                * Any argument from `settings`
                * Any attribute of this object if it meant to be resolved
                    (see `vectorbt.utils.attr.AttrResolver.resolve_attr`)

                Pass `metrics=&#39;all&#39;` to calculate all supported metrics.
            tags (str or iterable): Tags to select.

                See `vectorbt.utils.tags.match_tags`.
            column (str): Name of the column/group.

                !!! hint
                    There are two ways to select a column: `obj[&#39;a&#39;].stats()` and `obj.stats(column=&#39;a&#39;)`.
                    They both accomplish the same thing but in different ways: `obj[&#39;a&#39;].stats()` computes
                    statistics of the column &#39;a&#39; only, while `obj.stats(column=&#39;a&#39;)` computes statistics of
                    all columns first and only then selects the column &#39;a&#39;. The first method is preferred
                    when you have a lot of data or caching is disabled. The second method is preferred when
                    most attributes have already been cached.
            group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
            agg_func (callable): Aggregation function to aggregate statistics across all columns.
                Defaults to mean.

                Should take `pd.Series` and return a const.

                Has only effect if `column` was specified or this object contains only one column of data.

                If `agg_func` has been overridden by a metric:

                * it only takes effect if global `agg_func` is not None
                * will raise a warning if it&#39;s None but the result of calculation has multiple values
            silence_warnings (bool): Whether to silence all warnings.
            template_mapping (mapping): Global mapping to replace templates.

                Gets merged over `template_mapping` from `StatsBuilderMixin.stats_defaults`.

                Applied on `settings` and then on each metric settings.
            filters (dict): Filters to apply.

                Each item consists of the filter name and settings dict.

                The settings dict can contain the following keys:

                * `filter_func`: Filter function that should accept resolved self and
                    merged settings for a metric, and return either True or False.
                * `warning_message`: Warning message to be shown when skipping a metric.
                    Can be a template that will be substituted using merged metric settings as mapping.
                    Defaults to None.
                * `inv_warning_message`: Same as `warning_message` but for inverse checks.

                Gets merged over `filters` from `StatsBuilderMixin.stats_defaults`.
            settings (dict): Global settings and resolution arguments.

                Extends/overrides `settings` from `StatsBuilderMixin.stats_defaults`.
                Gets extended/overridden by metric settings.
            metric_settings (dict): Keyword arguments for each metric.

                Extends/overrides all global and metric settings.

        For template logic, see `vectorbt.utils.template`.

        For defaults, see `StatsBuilderMixin.stats_defaults`.

        !!! hint
            There are two types of arguments: optional (or resolution) and mandatory arguments.
            Optional arguments are only passed if they are found in the function&#39;s signature.
            Mandatory arguments are passed regardless of this. Optional arguments can only be defined
            using `settings` (that is, globally), while mandatory arguments can be defined both using
            default metric settings and `{metric_name}_kwargs`. Overriding optional arguments using default
            metric settings or `{metric_name}_kwargs` won&#39;t turn them into mandatory. For this, pass `pass_{arg}=True`.

        !!! hint
            Make sure to resolve and then to re-use as many object attributes as possible to
            utilize built-in caching (even if global caching is disabled).

        ## Example

        See `vectorbt.portfolio.base` for examples.
        &#34;&#34;&#34;
        # Resolve defaults
        if silence_warnings is None:
            silence_warnings = self.stats_defaults.get(&#39;silence_warnings&#39;, False)
        template_mapping = merge_dicts(self.stats_defaults.get(&#39;template_mapping&#39;, {}), template_mapping)
        filters = merge_dicts(self.stats_defaults.get(&#39;filters&#39;, {}), filters)
        settings = merge_dicts(self.stats_defaults.get(&#39;settings&#39;, {}), settings)
        metric_settings = merge_dicts(self.stats_defaults.get(&#39;metric_settings&#39;, {}), metric_settings)

        # Replace templates globally (not used at metric level)
        if len(template_mapping) &gt; 0:
            sub_settings = deep_substitute(settings, mapping=template_mapping)
        else:
            sub_settings = settings

        # Resolve self
        reself = self.resolve_self(
            cond_kwargs=sub_settings,
            impacts_caching=False,
            silence_warnings=silence_warnings
        )

        # Prepare metrics
        if metrics is None:
            metrics = reself.stats_defaults.get(&#39;metrics&#39;, &#39;all&#39;)
        if metrics == &#39;all&#39;:
            metrics = reself.metrics
        if isinstance(metrics, dict):
            metrics = list(metrics.items())
        if isinstance(metrics, (str, tuple)):
            metrics = [metrics]

        # Prepare tags
        if tags is None:
            tags = reself.stats_defaults.get(&#39;tags&#39;, &#39;all&#39;)
        if isinstance(tags, str) and tags == &#39;all&#39;:
            tags = None
        if isinstance(tags, (str, tuple)):
            tags = [tags]

        # Bring to the same shape
        new_metrics = []
        for i, metric in enumerate(metrics):
            if isinstance(metric, str):
                metric = (metric, reself.metrics[metric])
            if not isinstance(metric, tuple):
                raise TypeError(f&#34;Metric at index {i} must be either a string or a tuple&#34;)
            new_metrics.append(metric)
        metrics = new_metrics

        # Handle duplicate names
        metric_counts = Counter(list(map(lambda x: x[0], metrics)))
        metric_i = {k: -1 for k in metric_counts.keys()}
        metrics_dct = {}
        for i, (metric_name, _metric_settings) in enumerate(metrics):
            if metric_counts[metric_name] &gt; 1:
                metric_i[metric_name] += 1
                metric_name = metric_name + &#39;_&#39; + str(metric_i[metric_name])
            metrics_dct[metric_name] = _metric_settings

        # Check metric_settings
        missed_keys = set(metric_settings.keys()).difference(set(metrics_dct.keys()))
        if len(missed_keys) &gt; 0:
            raise ValueError(f&#34;Keys {missed_keys} in metric_settings could not be matched with any metric&#34;)

        # Merge settings
        opt_arg_names_dct = {}
        custom_arg_names_dct = {}
        resolved_self_dct = {}
        mapping_dct = {}
        for metric_name, _metric_settings in list(metrics_dct.items()):
            opt_settings = merge_dicts(
                {name: reself for name in reself.self_aliases},
                dict(
                    column=column,
                    group_by=group_by,
                    metric_name=metric_name,
                    agg_func=agg_func,
                    silence_warnings=silence_warnings,
                    to_timedelta=None
                ),
                settings
            )
            _metric_settings = _metric_settings.copy()
            passed_metric_settings = metric_settings.get(metric_name, {})
            merged_settings = merge_dicts(
                opt_settings,
                _metric_settings,
                passed_metric_settings
            )
            metric_template_mapping = merged_settings.pop(&#39;template_mapping&#39;, {})
            template_mapping_merged = merge_dicts(template_mapping, metric_template_mapping)
            template_mapping_merged = deep_substitute(template_mapping_merged, mapping=merged_settings)
            mapping = merge_dicts(template_mapping_merged, merged_settings)
            merged_settings = deep_substitute(merged_settings, mapping=mapping)

            # Filter by tag
            if tags is not None:
                in_tags = merged_settings.get(&#39;tags&#39;, None)
                if in_tags is None or not match_tags(tags, in_tags):
                    metrics_dct.pop(metric_name, None)
                    continue

            custom_arg_names = set(_metric_settings.keys()).union(set(passed_metric_settings.keys()))
            opt_arg_names = set(opt_settings.keys())
            custom_reself = reself.resolve_self(
                cond_kwargs=merged_settings,
                custom_arg_names=custom_arg_names,
                impacts_caching=True,
                silence_warnings=merged_settings[&#39;silence_warnings&#39;]
            )

            metrics_dct[metric_name] = merged_settings
            custom_arg_names_dct[metric_name] = custom_arg_names
            opt_arg_names_dct[metric_name] = opt_arg_names
            resolved_self_dct[metric_name] = custom_reself
            mapping_dct[metric_name] = mapping

        # Filter metrics
        for metric_name, _metric_settings in list(metrics_dct.items()):
            custom_reself = resolved_self_dct[metric_name]
            mapping = mapping_dct[metric_name]
            _silence_warnings = _metric_settings.get(&#39;silence_warnings&#39;)

            metric_filters = set()
            for k in _metric_settings.keys():
                filter_name = None
                if k.startswith(&#39;check_&#39;):
                    filter_name = k[len(&#39;check_&#39;):]
                elif k.startswith(&#39;inv_check_&#39;):
                    filter_name = k[len(&#39;inv_check_&#39;):]
                if filter_name is not None:
                    if filter_name not in filters:
                        raise ValueError(f&#34;Metric &#39;{metric_name}&#39; requires filter &#39;{filter_name}&#39;&#34;)
                    metric_filters.add(filter_name)

            for filter_name in metric_filters:
                filter_settings = filters[filter_name]
                _filter_settings = deep_substitute(filter_settings, mapping=mapping)
                filter_func = _filter_settings[&#39;filter_func&#39;]
                warning_message = _filter_settings.get(&#39;warning_message&#39;, None)
                inv_warning_message = _filter_settings.get(&#39;inv_warning_message&#39;, None)
                to_check = _metric_settings.get(&#39;check_&#39; + filter_name, False)
                inv_to_check = _metric_settings.get(&#39;inv_check_&#39; + filter_name, False)

                if to_check or inv_to_check:
                    whether_true = filter_func(custom_reself, _metric_settings)
                    to_remove = (to_check and not whether_true) or (inv_to_check and whether_true)
                    if to_remove:
                        if to_check and warning_message is not None and not _silence_warnings:
                            warnings.warn(warning_message)
                        if inv_to_check and inv_warning_message is not None and not _silence_warnings:
                            warnings.warn(inv_warning_message)

                        metrics_dct.pop(metric_name, None)
                        custom_arg_names_dct.pop(metric_name, None)
                        opt_arg_names_dct.pop(metric_name, None)
                        resolved_self_dct.pop(metric_name, None)
                        mapping_dct.pop(metric_name, None)
                        break

        # Any metrics left?
        if len(metrics_dct) == 0:
            if not silence_warnings:
                warnings.warn(&#34;No metrics to calculate&#34;, stacklevel=2)
            return None

        # Compute stats
        arg_cache_dct = {}
        stats_dct = {}
        used_agg_func = False
        for i, (metric_name, _metric_settings) in enumerate(metrics_dct.items()):
            try:
                final_kwargs = _metric_settings.copy()
                opt_arg_names = opt_arg_names_dct[metric_name]
                custom_arg_names = custom_arg_names_dct[metric_name]
                custom_reself = resolved_self_dct[metric_name]

                # Clean up keys
                for k, v in list(final_kwargs.items()):
                    if k.startswith(&#39;check_&#39;) or k.startswith(&#39;inv_check_&#39;) or k in (&#39;tags&#39;,):
                        final_kwargs.pop(k, None)

                # Get metric-specific values
                _column = final_kwargs.get(&#39;column&#39;)
                _group_by = final_kwargs.get(&#39;group_by&#39;)
                _agg_func = final_kwargs.get(&#39;agg_func&#39;)
                _silence_warnings = final_kwargs.get(&#39;silence_warnings&#39;)
                if final_kwargs[&#39;to_timedelta&#39;] is None:
                    final_kwargs[&#39;to_timedelta&#39;] = custom_reself.wrapper.freq is not None
                to_timedelta = final_kwargs.get(&#39;to_timedelta&#39;)
                title = final_kwargs.pop(&#39;title&#39;, metric_name)
                calc_func = final_kwargs.pop(&#39;calc_func&#39;)
                resolve_calc_func = final_kwargs.pop(&#39;resolve_calc_func&#39;, True)
                post_calc_func = final_kwargs.pop(&#39;post_calc_func&#39;, None)
                use_caching = final_kwargs.pop(&#39;use_caching&#39;, True)
                fill_wrap_kwargs = final_kwargs.pop(&#39;fill_wrap_kwargs&#39;, False)
                if fill_wrap_kwargs:
                    final_kwargs[&#39;wrap_kwargs&#39;] = merge_dicts(
                        dict(to_timedelta=to_timedelta, silence_warnings=_silence_warnings),
                        final_kwargs.get(&#39;wrap_kwargs&#39;, None)
                    )
                apply_to_timedelta = final_kwargs.pop(&#39;apply_to_timedelta&#39;, False)

                # Resolve calc_func
                if resolve_calc_func:
                    if not callable(calc_func):
                        passed_kwargs_out = {}

                        def _getattr_func(obj: tp.Any,
                                          attr: str,
                                          args: tp.ArgsLike = None,
                                          kwargs: tp.KwargsLike = None,
                                          call_attr: bool = True,
                                          _final_kwargs: tp.Kwargs = final_kwargs,
                                          _opt_arg_names: tp.Set[str] = opt_arg_names,
                                          _custom_arg_names: tp.Set[str] = custom_arg_names,
                                          _arg_cache_dct: tp.Kwargs = arg_cache_dct) -&gt; tp.Any:
                            if attr in final_kwargs:
                                return final_kwargs[attr]
                            if args is None:
                                args = ()
                            if kwargs is None:
                                kwargs = {}
                            if obj is custom_reself and _final_kwargs.pop(&#39;resolve_path_&#39; + attr, True):
                                if call_attr:
                                    return custom_reself.resolve_attr(
                                        attr,
                                        args=args,
                                        cond_kwargs={k: v for k, v in _final_kwargs.items() if k in _opt_arg_names},
                                        kwargs=kwargs,
                                        custom_arg_names=_custom_arg_names,
                                        cache_dct=_arg_cache_dct,
                                        use_caching=use_caching,
                                        passed_kwargs_out=passed_kwargs_out
                                    )
                                return getattr(obj, attr)
                            out = getattr(obj, attr)
                            if callable(out) and call_attr:
                                return out(*args, **kwargs)
                            return out

                        calc_func = custom_reself.deep_getattr(
                            calc_func,
                            getattr_func=_getattr_func,
                            call_last_attr=False
                        )

                        if &#39;group_by&#39; in passed_kwargs_out:
                            if &#39;pass_group_by&#39; not in final_kwargs:
                                final_kwargs.pop(&#39;group_by&#39;, None)

                    # Resolve arguments
                    if callable(calc_func):
                        func_arg_names = get_func_arg_names(calc_func)
                        for k in func_arg_names:
                            if k not in final_kwargs:
                                if final_kwargs.pop(&#39;resolve_&#39; + k, False):
                                    try:
                                        arg_out = custom_reself.resolve_attr(
                                            k,
                                            cond_kwargs=final_kwargs,
                                            custom_arg_names=custom_arg_names,
                                            cache_dct=arg_cache_dct,
                                            use_caching=use_caching
                                        )
                                    except AttributeError:
                                        continue
                                    final_kwargs[k] = arg_out
                        for k in list(final_kwargs.keys()):
                            if k in opt_arg_names:
                                if &#39;pass_&#39; + k in final_kwargs:
                                    if not final_kwargs.get(&#39;pass_&#39; + k):  # first priority
                                        final_kwargs.pop(k, None)
                                elif k not in func_arg_names:  # second priority
                                    final_kwargs.pop(k, None)
                        for k in list(final_kwargs.keys()):
                            if k.startswith(&#39;pass_&#39;) or k.startswith(&#39;resolve_&#39;):
                                final_kwargs.pop(k, None)  # cleanup

                        # Call calc_func
                        out = calc_func(**final_kwargs)
                    else:
                        # calc_func is already a result
                        out = calc_func
                else:
                    # Do not resolve calc_func
                    out = calc_func(custom_reself, _metric_settings)

                # Call post_calc_func
                if post_calc_func is not None:
                    out = post_calc_func(custom_reself, out, _metric_settings)

                # Post-process and store the metric
                multiple = True
                if not isinstance(out, dict):
                    multiple = False
                    out = {None: out}
                for k, v in out.items():
                    # Resolve title
                    if multiple:
                        if title is None:
                            t = str(k)
                        else:
                            t = title + &#39;: &#39; + str(k)
                    else:
                        t = title

                    # Check result type
                    if checks.is_any_array(v) and not checks.is_series(v):
                        raise TypeError(&#34;calc_func must return either a scalar for one column/group, &#34;
                                        &#34;pd.Series for multiple columns/groups, or a dict of such. &#34;
                                        f&#34;Not {type(v)}.&#34;)

                    # Handle apply_to_timedelta
                    if apply_to_timedelta and to_timedelta:
                        v = custom_reself.wrapper.to_timedelta(v, silence_warnings=_silence_warnings)

                    # Select column or aggregate
                    if checks.is_series(v):
                        if _column is not None:
                            v = custom_reself.select_one_from_obj(
                                v, custom_reself.wrapper.regroup(_group_by), column=_column)
                        elif _agg_func is not None and agg_func is not None:
                            v = _agg_func(v)
                            used_agg_func = True
                        elif _agg_func is None and agg_func is not None:
                            if not _silence_warnings:
                                warnings.warn(f&#34;Metric &#39;{metric_name}&#39; returned multiple values &#34;
                                              f&#34;despite having no aggregation function&#34;, stacklevel=2)
                            continue

                    # Store metric
                    if t in stats_dct:
                        if not _silence_warnings:
                            warnings.warn(f&#34;Duplicate metric title &#39;{t}&#39;&#34;, stacklevel=2)
                    stats_dct[t] = v
            except Exception as e:
                warnings.warn(f&#34;Metric &#39;{metric_name}&#39; raised an exception&#34;, stacklevel=2)
                raise e

        # Return the stats
        if reself.wrapper.get_ndim(group_by=group_by) == 1:
            return pd.Series(stats_dct, name=reself.wrapper.get_name(group_by=group_by))
        if column is not None:
            return pd.Series(stats_dct, name=column)
        if agg_func is not None:
            if used_agg_func and not silence_warnings:
                warnings.warn(f&#34;Object has multiple columns. Aggregating using {agg_func}. &#34;
                              f&#34;Pass column to select a single column/group.&#34;, stacklevel=2)
            return pd.Series(stats_dct, name=&#39;agg_func_&#39; + agg_func.__name__)
        new_index = reself.wrapper.grouper.get_columns(group_by=group_by)
        stats_df = pd.DataFrame(stats_dct, index=new_index)
        return stats_df

    # ############# Docs ############# #

    @classmethod
    def build_metrics_doc(cls, source_cls: tp.Optional[type] = None) -&gt; str:
        &#34;&#34;&#34;Build metrics documentation.&#34;&#34;&#34;
        if source_cls is None:
            source_cls = StatsBuilderMixin
        return string.Template(
            inspect.cleandoc(get_dict_attr(source_cls, &#39;metrics&#39;).__doc__)
        ).substitute(
            {&#39;metrics&#39;: cls.metrics.to_doc(), &#39;cls_name&#39;: cls.__name__}
        )

    @classmethod
    def override_metrics_doc(cls, __pdoc__: dict, source_cls: tp.Optional[type] = None) -&gt; None:
        &#34;&#34;&#34;Call this method on each subclass that overrides `metrics`.&#34;&#34;&#34;
        __pdoc__[cls.__name__ + &#39;.metrics&#39;] = cls.build_metrics_doc(source_cls=source_cls)</code></pre>
</details>
<h3 class="section-subtitle">Subclasses</h3>
<ul class="hlist">
<li><a title="vectorbt.data.base.Data" href="../data/base.html#vectorbt.data.base.Data">Data</a></li>
<li><a title="vectorbt.generic.accessors.GenericAccessor" href="accessors.html#vectorbt.generic.accessors.GenericAccessor">GenericAccessor</a></li>
<li><a title="vectorbt.indicators.factory.IndicatorBase" href="../indicators/factory.html#vectorbt.indicators.factory.IndicatorBase">IndicatorBase</a></li>
<li><a title="vectorbt.portfolio.base.Portfolio" href="../portfolio/base.html#vectorbt.portfolio.base.Portfolio">Portfolio</a></li>
<li><a title="vectorbt.records.base.Records" href="../records/base.html#vectorbt.records.base.Records">Records</a></li>
<li><a title="vectorbt.records.mapped_array.MappedArray" href="../records/mapped_array.html#vectorbt.records.mapped_array.MappedArray">MappedArray</a></li>
</ul>
<h3 class="section-subtitle">Class variables</h3>
<dl>
<dt id="vectorbt.generic.stats_builder.StatsBuilderMixin.metrics"><code class="name">var <span class="ident child-name">metrics</span></code></dt>
<dd>
<div class="desc"><p>Metrics supported by <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></code>.</p>
<pre><code class="language-json">Config({
    &quot;start&quot;: {
        &quot;title&quot;: &quot;Start&quot;,
        &quot;calc_func&quot;: &quot;&lt;function StatsBuilderMixin.&lt;lambda&gt; at 0x7fcd578c1e18&gt;&quot;,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    },
    &quot;end&quot;: {
        &quot;title&quot;: &quot;End&quot;,
        &quot;calc_func&quot;: &quot;&lt;function StatsBuilderMixin.&lt;lambda&gt; at 0x7fcd578c1ea0&gt;&quot;,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    },
    &quot;period&quot;: {
        &quot;title&quot;: &quot;Period&quot;,
        &quot;calc_func&quot;: &quot;&lt;function StatsBuilderMixin.&lt;lambda&gt; at 0x7fcd578c1f28&gt;&quot;,
        &quot;apply_to_timedelta&quot;: true,
        &quot;agg_func&quot;: null,
        &quot;tags&quot;: &quot;wrapper&quot;
    }
})
</code></pre>
<p>Returns <code>StatsBuilderMixin._metrics</code>, which gets (deep) copied upon creation of each instance.
Thus, changing this config won't affect the class.</p>
<p>To change metrics, you can either change the config in-place, override this property,
or overwrite the instance variable <code>StatsBuilderMixin._metrics</code>.</p></div>
</dd>
</dl>
<h3 class="section-subtitle">Static methods</h3>
<dl>
<dt id="vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc"><code class="name flex">
<span>def <span class="ident child-name">build_metrics_doc</span></span>(<span class="params">source_cls=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Build metrics documentation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def build_metrics_doc(cls, source_cls: tp.Optional[type] = None) -&gt; str:
    &#34;&#34;&#34;Build metrics documentation.&#34;&#34;&#34;
    if source_cls is None:
        source_cls = StatsBuilderMixin
    return string.Template(
        inspect.cleandoc(get_dict_attr(source_cls, &#39;metrics&#39;).__doc__)
    ).substitute(
        {&#39;metrics&#39;: cls.metrics.to_doc(), &#39;cls_name&#39;: cls.__name__}
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc"><code class="name flex">
<span>def <span class="ident child-name">override_metrics_doc</span></span>(<span class="params">__pdoc__, source_cls=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Call this method on each subclass that overrides <code>metrics</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def override_metrics_doc(cls, __pdoc__: dict, source_cls: tp.Optional[type] = None) -&gt; None:
    &#34;&#34;&#34;Call this method on each subclass that overrides `metrics`.&#34;&#34;&#34;
    __pdoc__[cls.__name__ + &#39;.metrics&#39;] = cls.build_metrics_doc(source_cls=source_cls)</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Instance variables</h3>
<dl>
<dt id="vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults"><code class="name">var <span class="ident child-name">stats_defaults</span></code></dt>
<dd>
<div class="desc"><p>Defaults for <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">StatsBuilderMixin.stats()</a></code>.</p>
<p>See <code>stats_builder</code> in <code><a title="vectorbt._settings.settings" href="../_settings.html#vectorbt._settings.settings">settings</a></code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def stats_defaults(self) -&gt; tp.Kwargs:
    &#34;&#34;&#34;Defaults for `StatsBuilderMixin.stats`.

    See `stats_builder` in `vectorbt._settings.settings`.&#34;&#34;&#34;
    from vectorbt._settings import settings
    stats_builder_cfg = settings[&#39;stats_builder&#39;]

    return merge_dicts(
        stats_builder_cfg,
        dict(settings=dict(freq=self.wrapper.freq))
    )</code></pre>
</details>
</dd>
<dt id="vectorbt.generic.stats_builder.StatsBuilderMixin.writeable_attrs"><code class="name">var <span class="ident child-name">writeable_attrs</span></code></dt>
<dd>
<div class="desc"><p>Set of writeable attributes that will be saved/copied along with the config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def writeable_attrs(self) -&gt; tp.Set[str]:
    &#34;&#34;&#34;Set of writeable attributes that will be saved/copied along with the config.&#34;&#34;&#34;
    return {&#39;_metrics&#39;}</code></pre>
</details>
</dd>
</dl>
<h3 class="section-subtitle">Methods</h3>
<dl>
<dt id="vectorbt.generic.stats_builder.StatsBuilderMixin.stats"><code class="name flex">
<span>def <span class="ident child-name">stats</span></span>(<span class="params">self, metrics=None, tags=None, column=None, group_by=None, agg_func=&lt;function mean&gt;, silence_warnings=None, template_mapping=None, settings=None, filters=None, metric_settings=None)</span><span class="return_type"></span>
</code></dt>
<dd>
<div class="desc"><p>Compute various metrics on this object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metrics</code></strong> :&ensp;<code>str, tuple, iterable,</code> or <code>dict</code></dt>
<dd>
<p>Metrics to calculate.</p>
<p>Each element can be either:</p>
<ul>
<li>a metric name (see keys in <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.metrics" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.metrics">StatsBuilderMixin.metrics</a></code>)</li>
<li>a tuple of a metric name and a settings dict as in <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.metrics" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.metrics">StatsBuilderMixin.metrics</a></code>.</li>
</ul>
<p>The settings dict can contain the following keys:</p>
<ul>
<li><code>title</code>: Title of the metric. Defaults to the name.</li>
<li><code>tags</code>: Single or multiple tags to associate this metric with.
If any of these tags is in <code>tags</code>, keeps this metric.</li>
<li><code>check_{filter}</code> and <code>inv_check_{filter}</code>: Whether to check this metric against a
filter defined in <code>filters</code>. True (or False for inverse) means to keep this metric.</li>
<li><code>calc_func</code> (required): Calculation function for custom metrics.
Should return either a scalar for one column/group, pd.Series for multiple columns/groups,
or a dict of such for multiple sub-metrics.</li>
<li><code>resolve_calc_func</code>: whether to resolve <code>calc_func</code>. If the function can be accessed
by traversing attributes of this object, you can specify the path to this function
as a string (see <code><a title="vectorbt.utils.attr.deep_getattr" href="../utils/attr.html#vectorbt.utils.attr.deep_getattr">deep_getattr()</a></code> for the path format).
If <code>calc_func</code> is a function, arguments from merged metric settings are matched with
arguments in the signature (see below). If <code>resolve_calc_func</code> is False, <code>calc_func</code>
should accept (resolved) self and dictionary of merged metric settings.
Defaults to True.</li>
<li><code>post_calc_func</code>: Function to post-process the result of <code>calc_func</code>.
Should accept (resolved) self, output of <code>calc_func</code>, and dictionary of merged metric settings,
and return whatever is acceptable to be returned by <code>calc_func</code>. Defaults to None.</li>
<li><code>fill_wrap_kwargs</code>: Whether to fill <code>wrap_kwargs</code> with <code>to_timedelta</code> and <code>silence_warnings</code>.
Defaults to False.</li>
<li><code>apply_to_timedelta</code>: Whether to apply <code><a title="vectorbt.base.array_wrapper.ArrayWrapper.to_timedelta" href="../base/array_wrapper.html#vectorbt.base.array_wrapper.ArrayWrapper.to_timedelta">ArrayWrapper.to_timedelta()</a></code>
on the result. To disable this globally, pass <code>to_timedelta=False</code> in <code>settings</code>.
Defaults to False.</li>
<li><code>pass_{arg}</code>: Whether to pass any argument from the settings (see below). Defaults to True if
this argument was found in the function's signature. Set to False to not pass.
If argument to be passed was not found, <code>pass_{arg}</code> is removed.</li>
<li><code>resolve_path_{arg}</code>: Whether to resolve an argument that is meant to be an attribute of
this object and is the first part of the path of <code>calc_func</code>. Passes only optional arguments.
Defaults to True. See <code><a title="vectorbt.utils.attr.AttrResolver.resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.resolve_attr">AttrResolver.resolve_attr()</a></code>.</li>
<li><code>resolve_{arg}</code>: Whether to resolve an argument that is meant to be an attribute of
this object and is present in the function's signature. Defaults to False.
See <code><a title="vectorbt.utils.attr.AttrResolver.resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.resolve_attr">AttrResolver.resolve_attr()</a></code>.</li>
<li><code>template_mapping</code>: Mapping to replace templates in metric settings. Used across all settings.</li>
<li>Any other keyword argument that overrides the settings or is passed directly to <code>calc_func</code>.</li>
</ul>
<p>If <code>resolve_calc_func</code> is True, the calculation function may "request" any of the
following arguments by accepting them or if <code>pass_{arg}</code> was found in the settings dict:</p>
<ul>
<li>Each of <code><a title="vectorbt.utils.attr.AttrResolver.self_aliases" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.self_aliases">AttrResolver.self_aliases</a></code>: original object
(ungrouped, with no column selected)</li>
<li><code>group_by</code>: won't be passed if it was used in resolving the first attribute of <code>calc_func</code>
specified as a path, use <code>pass_group_by=True</code> to pass anyway</li>
<li><code>column</code></li>
<li><code>metric_name</code></li>
<li><code>agg_func</code></li>
<li><code>silence_warnings</code></li>
<li><code>to_timedelta</code>: replaced by True if None and frequency is set</li>
<li>Any argument from <code>settings</code></li>
<li>Any attribute of this object if it meant to be resolved
(see <code><a title="vectorbt.utils.attr.AttrResolver.resolve_attr" href="../utils/attr.html#vectorbt.utils.attr.AttrResolver.resolve_attr">AttrResolver.resolve_attr()</a></code>)</li>
</ul>
<p>Pass <code>metrics='all'</code> to calculate all supported metrics.</p>
</dd>
<dt><strong><code>tags</code></strong> :&ensp;<code>str</code> or <code>iterable</code></dt>
<dd>
<p>Tags to select.</p>
<p>See <code><a title="vectorbt.utils.tags.match_tags" href="../utils/tags.html#vectorbt.utils.tags.match_tags">match_tags()</a></code>.</p>
</dd>
<dt><strong><code>column</code></strong> :&ensp;<code>str</code></dt>
<dd>
<p>Name of the column/group.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>There are two ways to select a column: <code>obj['a'].stats()</code> and <code>obj.stats(column='a')</code>.
They both accomplish the same thing but in different ways: <code>obj['a'].stats()</code> computes
statistics of the column 'a' only, while <code>obj.stats(column='a')</code> computes statistics of
all columns first and only then selects the column 'a'. The first method is preferred
when you have a lot of data or caching is disabled. The second method is preferred when
most attributes have already been cached.</p>
</div>
</dd>
<dt><strong><code>group_by</code></strong> :&ensp;<code>any</code></dt>
<dd>Group or ungroup columns. See <code><a title="vectorbt.base.column_grouper.ColumnGrouper" href="../base/column_grouper.html#vectorbt.base.column_grouper.ColumnGrouper">ColumnGrouper</a></code>.</dd>
<dt><strong><code>agg_func</code></strong> :&ensp;<code>callable</code></dt>
<dd>
<p>Aggregation function to aggregate statistics across all columns.
Defaults to mean.</p>
<p>Should take <code>pd.Series</code> and return a const.</p>
<p>Has only effect if <code>column</code> was specified or this object contains only one column of data.</p>
<p>If <code>agg_func</code> has been overridden by a metric:</p>
<ul>
<li>it only takes effect if global <code>agg_func</code> is not None</li>
<li>will raise a warning if it's None but the result of calculation has multiple values</li>
</ul>
</dd>
<dt><strong><code>silence_warnings</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether to silence all warnings.</dd>
<dt><strong><code>template_mapping</code></strong> :&ensp;<code>mapping</code></dt>
<dd>
<p>Global mapping to replace templates.</p>
<p>Gets merged over <code>template_mapping</code> from <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">StatsBuilderMixin.stats_defaults</a></code>.</p>
<p>Applied on <code>settings</code> and then on each metric settings.</p>
</dd>
<dt><strong><code>filters</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Filters to apply.</p>
<p>Each item consists of the filter name and settings dict.</p>
<p>The settings dict can contain the following keys:</p>
<ul>
<li><code>filter_func</code>: Filter function that should accept resolved self and
merged settings for a metric, and return either True or False.</li>
<li><code>warning_message</code>: Warning message to be shown when skipping a metric.
Can be a template that will be substituted using merged metric settings as mapping.
Defaults to None.</li>
<li><code>inv_warning_message</code>: Same as <code>warning_message</code> but for inverse checks.</li>
</ul>
<p>Gets merged over <code>filters</code> from <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">StatsBuilderMixin.stats_defaults</a></code>.</p>
</dd>
<dt><strong><code>settings</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Global settings and resolution arguments.</p>
<p>Extends/overrides <code>settings</code> from <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">StatsBuilderMixin.stats_defaults</a></code>.
Gets extended/overridden by metric settings.</p>
</dd>
<dt><strong><code>metric_settings</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Keyword arguments for each metric.</p>
<p>Extends/overrides all global and metric settings.</p>
</dd>
</dl>
<p>For template logic, see <code><a title="vectorbt.utils.template" href="../utils/template.html">vectorbt.utils.template</a></code>.</p>
<p>For defaults, see <code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">StatsBuilderMixin.stats_defaults</a></code>.</p>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>There are two types of arguments: optional (or resolution) and mandatory arguments.
Optional arguments are only passed if they are found in the function's signature.
Mandatory arguments are passed regardless of this. Optional arguments can only be defined
using <code>settings</code> (that is, globally), while mandatory arguments can be defined both using
default metric settings and <code>{metric_name}_kwargs</code>. Overriding optional arguments using default
metric settings or <code>{metric_name}_kwargs</code> won't turn them into mandatory. For this, pass <code>pass_{arg}=True</code>.</p>
</div>
<div class="admonition hint">
<p class="admonition-title">Hint</p>
<p>Make sure to resolve and then to re-use as many object attributes as possible to
utilize built-in caching (even if global caching is disabled).</p>
</div>
<h2 id="example">Example</h2>
<p>See <code><a title="vectorbt.portfolio.base" href="../portfolio/base.html">vectorbt.portfolio.base</a></code> for examples.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stats(self,
          metrics: tp.Optional[tp.MaybeIterable[tp.Union[str, tp.Tuple[str, tp.Kwargs]]]] = None,
          tags: tp.Optional[tp.MaybeIterable[str]] = None,
          column: tp.Optional[tp.Label] = None,
          group_by: tp.GroupByLike = None,
          agg_func: tp.Optional[tp.Callable] = np.mean,
          silence_warnings: tp.Optional[bool] = None,
          template_mapping: tp.Optional[tp.Mapping] = None,
          settings: tp.KwargsLike = None,
          filters: tp.KwargsLike = None,
          metric_settings: tp.KwargsLike = None) -&gt; tp.Optional[tp.SeriesFrame]:
    &#34;&#34;&#34;Compute various metrics on this object.

    Args:
        metrics (str, tuple, iterable, or dict): Metrics to calculate.

            Each element can be either:

            * a metric name (see keys in `StatsBuilderMixin.metrics`)
            * a tuple of a metric name and a settings dict as in `StatsBuilderMixin.metrics`.

            The settings dict can contain the following keys:

            * `title`: Title of the metric. Defaults to the name.
            * `tags`: Single or multiple tags to associate this metric with.
                If any of these tags is in `tags`, keeps this metric.
            * `check_{filter}` and `inv_check_{filter}`: Whether to check this metric against a
                filter defined in `filters`. True (or False for inverse) means to keep this metric.
            * `calc_func` (required): Calculation function for custom metrics.
                Should return either a scalar for one column/group, pd.Series for multiple columns/groups,
                or a dict of such for multiple sub-metrics.
            * `resolve_calc_func`: whether to resolve `calc_func`. If the function can be accessed
                by traversing attributes of this object, you can specify the path to this function
                as a string (see `vectorbt.utils.attr.deep_getattr` for the path format).
                If `calc_func` is a function, arguments from merged metric settings are matched with
                arguments in the signature (see below). If `resolve_calc_func` is False, `calc_func`
                should accept (resolved) self and dictionary of merged metric settings.
                Defaults to True.
            * `post_calc_func`: Function to post-process the result of `calc_func`.
                Should accept (resolved) self, output of `calc_func`, and dictionary of merged metric settings,
                and return whatever is acceptable to be returned by `calc_func`. Defaults to None.
            * `fill_wrap_kwargs`: Whether to fill `wrap_kwargs` with `to_timedelta` and `silence_warnings`.
                Defaults to False.
            * `apply_to_timedelta`: Whether to apply `vectorbt.base.array_wrapper.ArrayWrapper.to_timedelta`
                on the result. To disable this globally, pass `to_timedelta=False` in `settings`.
                Defaults to False.
            * `pass_{arg}`: Whether to pass any argument from the settings (see below). Defaults to True if
                this argument was found in the function&#39;s signature. Set to False to not pass.
                If argument to be passed was not found, `pass_{arg}` is removed.
            * `resolve_path_{arg}`: Whether to resolve an argument that is meant to be an attribute of
                this object and is the first part of the path of `calc_func`. Passes only optional arguments.
                Defaults to True. See `vectorbt.utils.attr.AttrResolver.resolve_attr`.
            * `resolve_{arg}`: Whether to resolve an argument that is meant to be an attribute of
                this object and is present in the function&#39;s signature. Defaults to False.
                See `vectorbt.utils.attr.AttrResolver.resolve_attr`.
            * `template_mapping`: Mapping to replace templates in metric settings. Used across all settings.
            * Any other keyword argument that overrides the settings or is passed directly to `calc_func`.

            If `resolve_calc_func` is True, the calculation function may &#34;request&#34; any of the
            following arguments by accepting them or if `pass_{arg}` was found in the settings dict:

            * Each of `vectorbt.utils.attr.AttrResolver.self_aliases`: original object
                (ungrouped, with no column selected)
            * `group_by`: won&#39;t be passed if it was used in resolving the first attribute of `calc_func`
                specified as a path, use `pass_group_by=True` to pass anyway
            * `column`
            * `metric_name`
            * `agg_func`
            * `silence_warnings`
            * `to_timedelta`: replaced by True if None and frequency is set
            * Any argument from `settings`
            * Any attribute of this object if it meant to be resolved
                (see `vectorbt.utils.attr.AttrResolver.resolve_attr`)

            Pass `metrics=&#39;all&#39;` to calculate all supported metrics.
        tags (str or iterable): Tags to select.

            See `vectorbt.utils.tags.match_tags`.
        column (str): Name of the column/group.

            !!! hint
                There are two ways to select a column: `obj[&#39;a&#39;].stats()` and `obj.stats(column=&#39;a&#39;)`.
                They both accomplish the same thing but in different ways: `obj[&#39;a&#39;].stats()` computes
                statistics of the column &#39;a&#39; only, while `obj.stats(column=&#39;a&#39;)` computes statistics of
                all columns first and only then selects the column &#39;a&#39;. The first method is preferred
                when you have a lot of data or caching is disabled. The second method is preferred when
                most attributes have already been cached.
        group_by (any): Group or ungroup columns. See `vectorbt.base.column_grouper.ColumnGrouper`.
        agg_func (callable): Aggregation function to aggregate statistics across all columns.
            Defaults to mean.

            Should take `pd.Series` and return a const.

            Has only effect if `column` was specified or this object contains only one column of data.

            If `agg_func` has been overridden by a metric:

            * it only takes effect if global `agg_func` is not None
            * will raise a warning if it&#39;s None but the result of calculation has multiple values
        silence_warnings (bool): Whether to silence all warnings.
        template_mapping (mapping): Global mapping to replace templates.

            Gets merged over `template_mapping` from `StatsBuilderMixin.stats_defaults`.

            Applied on `settings` and then on each metric settings.
        filters (dict): Filters to apply.

            Each item consists of the filter name and settings dict.

            The settings dict can contain the following keys:

            * `filter_func`: Filter function that should accept resolved self and
                merged settings for a metric, and return either True or False.
            * `warning_message`: Warning message to be shown when skipping a metric.
                Can be a template that will be substituted using merged metric settings as mapping.
                Defaults to None.
            * `inv_warning_message`: Same as `warning_message` but for inverse checks.

            Gets merged over `filters` from `StatsBuilderMixin.stats_defaults`.
        settings (dict): Global settings and resolution arguments.

            Extends/overrides `settings` from `StatsBuilderMixin.stats_defaults`.
            Gets extended/overridden by metric settings.
        metric_settings (dict): Keyword arguments for each metric.

            Extends/overrides all global and metric settings.

    For template logic, see `vectorbt.utils.template`.

    For defaults, see `StatsBuilderMixin.stats_defaults`.

    !!! hint
        There are two types of arguments: optional (or resolution) and mandatory arguments.
        Optional arguments are only passed if they are found in the function&#39;s signature.
        Mandatory arguments are passed regardless of this. Optional arguments can only be defined
        using `settings` (that is, globally), while mandatory arguments can be defined both using
        default metric settings and `{metric_name}_kwargs`. Overriding optional arguments using default
        metric settings or `{metric_name}_kwargs` won&#39;t turn them into mandatory. For this, pass `pass_{arg}=True`.

    !!! hint
        Make sure to resolve and then to re-use as many object attributes as possible to
        utilize built-in caching (even if global caching is disabled).

    ## Example

    See `vectorbt.portfolio.base` for examples.
    &#34;&#34;&#34;
    # Resolve defaults
    if silence_warnings is None:
        silence_warnings = self.stats_defaults.get(&#39;silence_warnings&#39;, False)
    template_mapping = merge_dicts(self.stats_defaults.get(&#39;template_mapping&#39;, {}), template_mapping)
    filters = merge_dicts(self.stats_defaults.get(&#39;filters&#39;, {}), filters)
    settings = merge_dicts(self.stats_defaults.get(&#39;settings&#39;, {}), settings)
    metric_settings = merge_dicts(self.stats_defaults.get(&#39;metric_settings&#39;, {}), metric_settings)

    # Replace templates globally (not used at metric level)
    if len(template_mapping) &gt; 0:
        sub_settings = deep_substitute(settings, mapping=template_mapping)
    else:
        sub_settings = settings

    # Resolve self
    reself = self.resolve_self(
        cond_kwargs=sub_settings,
        impacts_caching=False,
        silence_warnings=silence_warnings
    )

    # Prepare metrics
    if metrics is None:
        metrics = reself.stats_defaults.get(&#39;metrics&#39;, &#39;all&#39;)
    if metrics == &#39;all&#39;:
        metrics = reself.metrics
    if isinstance(metrics, dict):
        metrics = list(metrics.items())
    if isinstance(metrics, (str, tuple)):
        metrics = [metrics]

    # Prepare tags
    if tags is None:
        tags = reself.stats_defaults.get(&#39;tags&#39;, &#39;all&#39;)
    if isinstance(tags, str) and tags == &#39;all&#39;:
        tags = None
    if isinstance(tags, (str, tuple)):
        tags = [tags]

    # Bring to the same shape
    new_metrics = []
    for i, metric in enumerate(metrics):
        if isinstance(metric, str):
            metric = (metric, reself.metrics[metric])
        if not isinstance(metric, tuple):
            raise TypeError(f&#34;Metric at index {i} must be either a string or a tuple&#34;)
        new_metrics.append(metric)
    metrics = new_metrics

    # Handle duplicate names
    metric_counts = Counter(list(map(lambda x: x[0], metrics)))
    metric_i = {k: -1 for k in metric_counts.keys()}
    metrics_dct = {}
    for i, (metric_name, _metric_settings) in enumerate(metrics):
        if metric_counts[metric_name] &gt; 1:
            metric_i[metric_name] += 1
            metric_name = metric_name + &#39;_&#39; + str(metric_i[metric_name])
        metrics_dct[metric_name] = _metric_settings

    # Check metric_settings
    missed_keys = set(metric_settings.keys()).difference(set(metrics_dct.keys()))
    if len(missed_keys) &gt; 0:
        raise ValueError(f&#34;Keys {missed_keys} in metric_settings could not be matched with any metric&#34;)

    # Merge settings
    opt_arg_names_dct = {}
    custom_arg_names_dct = {}
    resolved_self_dct = {}
    mapping_dct = {}
    for metric_name, _metric_settings in list(metrics_dct.items()):
        opt_settings = merge_dicts(
            {name: reself for name in reself.self_aliases},
            dict(
                column=column,
                group_by=group_by,
                metric_name=metric_name,
                agg_func=agg_func,
                silence_warnings=silence_warnings,
                to_timedelta=None
            ),
            settings
        )
        _metric_settings = _metric_settings.copy()
        passed_metric_settings = metric_settings.get(metric_name, {})
        merged_settings = merge_dicts(
            opt_settings,
            _metric_settings,
            passed_metric_settings
        )
        metric_template_mapping = merged_settings.pop(&#39;template_mapping&#39;, {})
        template_mapping_merged = merge_dicts(template_mapping, metric_template_mapping)
        template_mapping_merged = deep_substitute(template_mapping_merged, mapping=merged_settings)
        mapping = merge_dicts(template_mapping_merged, merged_settings)
        merged_settings = deep_substitute(merged_settings, mapping=mapping)

        # Filter by tag
        if tags is not None:
            in_tags = merged_settings.get(&#39;tags&#39;, None)
            if in_tags is None or not match_tags(tags, in_tags):
                metrics_dct.pop(metric_name, None)
                continue

        custom_arg_names = set(_metric_settings.keys()).union(set(passed_metric_settings.keys()))
        opt_arg_names = set(opt_settings.keys())
        custom_reself = reself.resolve_self(
            cond_kwargs=merged_settings,
            custom_arg_names=custom_arg_names,
            impacts_caching=True,
            silence_warnings=merged_settings[&#39;silence_warnings&#39;]
        )

        metrics_dct[metric_name] = merged_settings
        custom_arg_names_dct[metric_name] = custom_arg_names
        opt_arg_names_dct[metric_name] = opt_arg_names
        resolved_self_dct[metric_name] = custom_reself
        mapping_dct[metric_name] = mapping

    # Filter metrics
    for metric_name, _metric_settings in list(metrics_dct.items()):
        custom_reself = resolved_self_dct[metric_name]
        mapping = mapping_dct[metric_name]
        _silence_warnings = _metric_settings.get(&#39;silence_warnings&#39;)

        metric_filters = set()
        for k in _metric_settings.keys():
            filter_name = None
            if k.startswith(&#39;check_&#39;):
                filter_name = k[len(&#39;check_&#39;):]
            elif k.startswith(&#39;inv_check_&#39;):
                filter_name = k[len(&#39;inv_check_&#39;):]
            if filter_name is not None:
                if filter_name not in filters:
                    raise ValueError(f&#34;Metric &#39;{metric_name}&#39; requires filter &#39;{filter_name}&#39;&#34;)
                metric_filters.add(filter_name)

        for filter_name in metric_filters:
            filter_settings = filters[filter_name]
            _filter_settings = deep_substitute(filter_settings, mapping=mapping)
            filter_func = _filter_settings[&#39;filter_func&#39;]
            warning_message = _filter_settings.get(&#39;warning_message&#39;, None)
            inv_warning_message = _filter_settings.get(&#39;inv_warning_message&#39;, None)
            to_check = _metric_settings.get(&#39;check_&#39; + filter_name, False)
            inv_to_check = _metric_settings.get(&#39;inv_check_&#39; + filter_name, False)

            if to_check or inv_to_check:
                whether_true = filter_func(custom_reself, _metric_settings)
                to_remove = (to_check and not whether_true) or (inv_to_check and whether_true)
                if to_remove:
                    if to_check and warning_message is not None and not _silence_warnings:
                        warnings.warn(warning_message)
                    if inv_to_check and inv_warning_message is not None and not _silence_warnings:
                        warnings.warn(inv_warning_message)

                    metrics_dct.pop(metric_name, None)
                    custom_arg_names_dct.pop(metric_name, None)
                    opt_arg_names_dct.pop(metric_name, None)
                    resolved_self_dct.pop(metric_name, None)
                    mapping_dct.pop(metric_name, None)
                    break

    # Any metrics left?
    if len(metrics_dct) == 0:
        if not silence_warnings:
            warnings.warn(&#34;No metrics to calculate&#34;, stacklevel=2)
        return None

    # Compute stats
    arg_cache_dct = {}
    stats_dct = {}
    used_agg_func = False
    for i, (metric_name, _metric_settings) in enumerate(metrics_dct.items()):
        try:
            final_kwargs = _metric_settings.copy()
            opt_arg_names = opt_arg_names_dct[metric_name]
            custom_arg_names = custom_arg_names_dct[metric_name]
            custom_reself = resolved_self_dct[metric_name]

            # Clean up keys
            for k, v in list(final_kwargs.items()):
                if k.startswith(&#39;check_&#39;) or k.startswith(&#39;inv_check_&#39;) or k in (&#39;tags&#39;,):
                    final_kwargs.pop(k, None)

            # Get metric-specific values
            _column = final_kwargs.get(&#39;column&#39;)
            _group_by = final_kwargs.get(&#39;group_by&#39;)
            _agg_func = final_kwargs.get(&#39;agg_func&#39;)
            _silence_warnings = final_kwargs.get(&#39;silence_warnings&#39;)
            if final_kwargs[&#39;to_timedelta&#39;] is None:
                final_kwargs[&#39;to_timedelta&#39;] = custom_reself.wrapper.freq is not None
            to_timedelta = final_kwargs.get(&#39;to_timedelta&#39;)
            title = final_kwargs.pop(&#39;title&#39;, metric_name)
            calc_func = final_kwargs.pop(&#39;calc_func&#39;)
            resolve_calc_func = final_kwargs.pop(&#39;resolve_calc_func&#39;, True)
            post_calc_func = final_kwargs.pop(&#39;post_calc_func&#39;, None)
            use_caching = final_kwargs.pop(&#39;use_caching&#39;, True)
            fill_wrap_kwargs = final_kwargs.pop(&#39;fill_wrap_kwargs&#39;, False)
            if fill_wrap_kwargs:
                final_kwargs[&#39;wrap_kwargs&#39;] = merge_dicts(
                    dict(to_timedelta=to_timedelta, silence_warnings=_silence_warnings),
                    final_kwargs.get(&#39;wrap_kwargs&#39;, None)
                )
            apply_to_timedelta = final_kwargs.pop(&#39;apply_to_timedelta&#39;, False)

            # Resolve calc_func
            if resolve_calc_func:
                if not callable(calc_func):
                    passed_kwargs_out = {}

                    def _getattr_func(obj: tp.Any,
                                      attr: str,
                                      args: tp.ArgsLike = None,
                                      kwargs: tp.KwargsLike = None,
                                      call_attr: bool = True,
                                      _final_kwargs: tp.Kwargs = final_kwargs,
                                      _opt_arg_names: tp.Set[str] = opt_arg_names,
                                      _custom_arg_names: tp.Set[str] = custom_arg_names,
                                      _arg_cache_dct: tp.Kwargs = arg_cache_dct) -&gt; tp.Any:
                        if attr in final_kwargs:
                            return final_kwargs[attr]
                        if args is None:
                            args = ()
                        if kwargs is None:
                            kwargs = {}
                        if obj is custom_reself and _final_kwargs.pop(&#39;resolve_path_&#39; + attr, True):
                            if call_attr:
                                return custom_reself.resolve_attr(
                                    attr,
                                    args=args,
                                    cond_kwargs={k: v for k, v in _final_kwargs.items() if k in _opt_arg_names},
                                    kwargs=kwargs,
                                    custom_arg_names=_custom_arg_names,
                                    cache_dct=_arg_cache_dct,
                                    use_caching=use_caching,
                                    passed_kwargs_out=passed_kwargs_out
                                )
                            return getattr(obj, attr)
                        out = getattr(obj, attr)
                        if callable(out) and call_attr:
                            return out(*args, **kwargs)
                        return out

                    calc_func = custom_reself.deep_getattr(
                        calc_func,
                        getattr_func=_getattr_func,
                        call_last_attr=False
                    )

                    if &#39;group_by&#39; in passed_kwargs_out:
                        if &#39;pass_group_by&#39; not in final_kwargs:
                            final_kwargs.pop(&#39;group_by&#39;, None)

                # Resolve arguments
                if callable(calc_func):
                    func_arg_names = get_func_arg_names(calc_func)
                    for k in func_arg_names:
                        if k not in final_kwargs:
                            if final_kwargs.pop(&#39;resolve_&#39; + k, False):
                                try:
                                    arg_out = custom_reself.resolve_attr(
                                        k,
                                        cond_kwargs=final_kwargs,
                                        custom_arg_names=custom_arg_names,
                                        cache_dct=arg_cache_dct,
                                        use_caching=use_caching
                                    )
                                except AttributeError:
                                    continue
                                final_kwargs[k] = arg_out
                    for k in list(final_kwargs.keys()):
                        if k in opt_arg_names:
                            if &#39;pass_&#39; + k in final_kwargs:
                                if not final_kwargs.get(&#39;pass_&#39; + k):  # first priority
                                    final_kwargs.pop(k, None)
                            elif k not in func_arg_names:  # second priority
                                final_kwargs.pop(k, None)
                    for k in list(final_kwargs.keys()):
                        if k.startswith(&#39;pass_&#39;) or k.startswith(&#39;resolve_&#39;):
                            final_kwargs.pop(k, None)  # cleanup

                    # Call calc_func
                    out = calc_func(**final_kwargs)
                else:
                    # calc_func is already a result
                    out = calc_func
            else:
                # Do not resolve calc_func
                out = calc_func(custom_reself, _metric_settings)

            # Call post_calc_func
            if post_calc_func is not None:
                out = post_calc_func(custom_reself, out, _metric_settings)

            # Post-process and store the metric
            multiple = True
            if not isinstance(out, dict):
                multiple = False
                out = {None: out}
            for k, v in out.items():
                # Resolve title
                if multiple:
                    if title is None:
                        t = str(k)
                    else:
                        t = title + &#39;: &#39; + str(k)
                else:
                    t = title

                # Check result type
                if checks.is_any_array(v) and not checks.is_series(v):
                    raise TypeError(&#34;calc_func must return either a scalar for one column/group, &#34;
                                    &#34;pd.Series for multiple columns/groups, or a dict of such. &#34;
                                    f&#34;Not {type(v)}.&#34;)

                # Handle apply_to_timedelta
                if apply_to_timedelta and to_timedelta:
                    v = custom_reself.wrapper.to_timedelta(v, silence_warnings=_silence_warnings)

                # Select column or aggregate
                if checks.is_series(v):
                    if _column is not None:
                        v = custom_reself.select_one_from_obj(
                            v, custom_reself.wrapper.regroup(_group_by), column=_column)
                    elif _agg_func is not None and agg_func is not None:
                        v = _agg_func(v)
                        used_agg_func = True
                    elif _agg_func is None and agg_func is not None:
                        if not _silence_warnings:
                            warnings.warn(f&#34;Metric &#39;{metric_name}&#39; returned multiple values &#34;
                                          f&#34;despite having no aggregation function&#34;, stacklevel=2)
                        continue

                # Store metric
                if t in stats_dct:
                    if not _silence_warnings:
                        warnings.warn(f&#34;Duplicate metric title &#39;{t}&#39;&#34;, stacklevel=2)
                stats_dct[t] = v
        except Exception as e:
            warnings.warn(f&#34;Metric &#39;{metric_name}&#39; raised an exception&#34;, stacklevel=2)
            raise e

    # Return the stats
    if reself.wrapper.get_ndim(group_by=group_by) == 1:
        return pd.Series(stats_dct, name=reself.wrapper.get_name(group_by=group_by))
    if column is not None:
        return pd.Series(stats_dct, name=column)
    if agg_func is not None:
        if used_agg_func and not silence_warnings:
            warnings.warn(f&#34;Object has multiple columns. Aggregating using {agg_func}. &#34;
                          f&#34;Pass column to select a single column/group.&#34;, stacklevel=2)
        return pd.Series(stats_dct, name=&#39;agg_func_&#39; + agg_func.__name__)
    new_index = reself.wrapper.grouper.get_columns(group_by=group_by)
    stats_df = pd.DataFrame(stats_dct, index=new_index)
    return stats_df</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="pdoc Home" href="https://github.com/polakowo/vectorbt">
<img src="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPCEtLSBHZW5lcmF0b3I6IEFkb2JlIElsbHVzdHJhdG9yIDI1LjAuMSwgU1ZHIEV4cG9ydCBQbHVnLUluIC4gU1ZHIFZlcnNpb246IDYuMDAgQnVpbGQgMCkgIC0tPgo8c3ZnIHZlcnNpb249IjEuMSIgaWQ9IkNhcGFfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiCgkgdmlld0JveD0iMCAwIDUxMiA1MTIiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDUxMiA1MTI7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4KCS5zdDB7ZmlsbDojRUYwMDAwO30KCS5zdDF7ZmlsbDojRkY5MDAwO30KCS5zdDJ7ZmlsbDojRkZERjAwO30KCS5zdDN7ZmlsbDojMjgyQzM0O30KPC9zdHlsZT4KPGc+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MCIgcG9pbnRzPSIxNTUuMywzMDAuMSAyODMuMSwwIDIwOCwwIDExMC44LDAgMzUuOCwwIDEuMiw0NTAuMiA3Ni4zLDQ1MC4yIAkJCSIvPgoJCTwvZz4KCTwvZz4KCTxnPgoJCTxnPgoJCQk8cG9seWdvbiBjbGFzcz0ic3QxIiBwb2ludHM9IjIzMC40LDMwMC4xIDM1OC4xLDAgMjgzLjEsMCAxODUuOCwwIDExMC44LDAgNzYuMyw0NTAuMiAxNTEuMyw0NTAuMiAJCQkiLz4KCQk8L2c+Cgk8L2c+Cgk8Zz4KCQk8Zz4KCQkJPHBvbHlnb24gY2xhc3M9InN0MiIgcG9pbnRzPSIzMDUuNCwzMDAuMSA0MzMuMSwwIDM1OC4xLDAgMzMxLjYsNjIuMyAyNjAuOCwwIDE4NS44LDAgMTUxLjMsNDUwLjIgMjI2LjQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgoJPGc+CgkJPGc+CgkJCTxwb2x5Z29uIGNsYXNzPSJzdDMiIHBvaW50cz0iNTEwLjgsMCA0MzMuMSwwIDMwNS40LDMwMC4xIDMzOC40LDAgMjYwLjgsMCAyMjYuNCw0NTAuMiAzMDQsNDUwLjIgCQkJIi8+CgkJPC9nPgoJPC9nPgo8L2c+Cjwvc3ZnPgo="/>
vectorbt <span class="version">0.21.0</span></a>
</header>
<div class="search-container">
<input
id="search_input"
type="text"
placeholder="Search"
title="Search"
/>
</div>
<div class="scrollable-index">
<h1 class="index-caption">Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vectorbt.generic" href="index.html">vectorbt.generic</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vectorbt.generic.stats_builder.MetaStatsBuilderMixin" href="#vectorbt.generic.stats_builder.MetaStatsBuilderMixin">MetaStatsBuilderMixin</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.generic.stats_builder.MetaStatsBuilderMixin.metrics" href="#vectorbt.generic.stats_builder.MetaStatsBuilderMixin.metrics">metrics</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin" href="#vectorbt.generic.stats_builder.StatsBuilderMixin">StatsBuilderMixin</a></code></h4>
<ul class="">
<li><code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.build_metrics_doc">build_metrics_doc</a></code></li>
<li><code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.metrics" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.metrics">metrics</a></code></li>
<li><code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.override_metrics_doc">override_metrics_doc</a></code></li>
<li><code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.stats">stats</a></code></li>
<li><code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.stats_defaults">stats_defaults</a></code></li>
<li><code><a title="vectorbt.generic.stats_builder.StatsBuilderMixin.writeable_attrs" href="#vectorbt.generic.stats_builder.StatsBuilderMixin.writeable_attrs">writeable_attrs</a></code></li>
</ul>
</li>
</ul>
</li>
</nav>
</main>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
<script type="text/javascript">
docsearch({
apiKey: 'ac97cfdd96a6e6fcdc67c570adaeaf94',
indexName: 'vectorbt',
inputSelector: '#search_input',
autocompleteOptions: {
autoWidth: false
},
debug: true // Set debug to true if you want to inspect the dropdown
});
</script>
<script src="https://buttons.github.io/buttons.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.0/clipboard.min.js"></script>
<script>
// Turn off ESLint for this file because it's sent down to users as-is.
/* eslint-disable */
window.addEventListener('load', function() {
function button(label, ariaLabel, icon, className) {
const btn = document.createElement('button');
btn.classList.add('btnIcon', className);
btn.setAttribute('type', 'button');
btn.setAttribute('aria-label', ariaLabel);
btn.innerHTML =
'<div class="btnIcon__body">' +
icon +
'<strong class="btnIcon__label">' +
label +
'</strong>' +
'</div>';
return btn;
}
function addButtons(codeBlockSelector, btn) {
document.querySelectorAll(codeBlockSelector).forEach(function(code) {
code.parentNode.appendChild(btn.cloneNode(true));
});
}
const copyIcon =
'<svg width="12" height="12" viewBox="340 364 14 15" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M342 375.974h4v.998h-4v-.998zm5-5.987h-5v.998h5v-.998zm2 2.994v-1.995l-3 2.993 3 2.994v-1.996h5v-1.995h-5zm-4.5-.997H342v.998h2.5v-.997zm-2.5 2.993h2.5v-.998H342v.998zm9 .998h1v1.996c-.016.28-.11.514-.297.702-.187.187-.422.28-.703.296h-10c-.547 0-1-.452-1-.998v-10.976c0-.546.453-.998 1-.998h3c0-1.107.89-1.996 2-1.996 1.11 0 2 .89 2 1.996h3c.547 0 1 .452 1 .998v4.99h-1v-2.995h-10v8.98h10v-1.996zm-9-7.983h8c0-.544-.453-.996-1-.996h-1c-.547 0-1-.453-1-.998 0-.546-.453-.998-1-.998-.547 0-1 .452-1 .998 0 .545-.453.998-1 .998h-1c-.547 0-1 .452-1 .997z" fill-rule="evenodd"/></svg>';
addButtons(
'.hljs',
button('Copy', 'Copy code to clipboard', copyIcon, 'btnClipboard'),
);
const clipboard = new ClipboardJS('.btnClipboard', {
target: function(trigger) {
return trigger.parentNode.querySelector('code');
},
});
clipboard.on('success', function(event) {
event.clearSelection();
const textEl = event.trigger.querySelector('.btnIcon__label');
textEl.textContent = 'Copied';
setTimeout(function() {
textEl.textContent = 'Copy';
}, 2000);
});
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" integrity="sha512-894YE6QWD5I59HgZOGReFYm4dnWc1Qt5NtvYSaNcOP+u1T9qYdvdihz0PPSiiqn/+/3e7Jo4EaG7TubfWGUrMQ==" crossorigin="anonymous"></script>
<script>
$(document).ready(function() {
$("article dt[id], #section-intro [id]").each(function() {
const thisId = $(this).attr('id');
$(this).wrap('<a class="headerlink" href="#' + thisId + '">');
});
});
</script>
</body>
</html>